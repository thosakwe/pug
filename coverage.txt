/Users/tobe/Source/Dart/pug/test/syntax/scan/scan_test.dart
       |import 'package:test/test.dart';
       |import 'common.dart';
       |
       |main() {
      1|  group('simple', () {
      1|    test('tag+attributes', () {
      1|      expect(
       |          'foo(bar="baz")',
      2|          equalsScanned([
       |            TokenType.TAG_NAME,
       |            TokenType.LPAREN,
       |            TokenType.TAG_NAME,
       |            TokenType.EQUALS,
       |            TokenType.DOUBLE_QUOTED_STRING,
       |            TokenType.RPAREN
       |          ]));
       |    });
       |  });
       |
      1|  group('whitespace control', () {
      1|    test('plain text block', () {
      1|      expect(
       |          'p.\n  Hello\n  world',
      1|          equalsScanned(
      1|              [TokenType.TAG_NAME, TokenType.DOT, TokenType.ARBITRARY_TEXT]));
       |    });
       |  });
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/test.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:path/path.dart' as p;
       |
       |import 'src/backend/declarer.dart';
       |import 'src/backend/invoker.dart';
       |import 'src/backend/test_platform.dart';
       |import 'src/frontend/timeout.dart';
       |import 'src/runner/configuration/suite.dart';
       |import 'src/runner/engine.dart';
       |import 'src/runner/plugin/environment.dart';
       |import 'src/runner/reporter/expanded.dart';
       |import 'src/runner/runner_suite.dart';
       |import 'src/utils.dart';
       |
       |export 'package:matcher/matcher.dart';
       |
       |export 'src/frontend/expect.dart' hide formatFailure;
       |export 'src/frontend/expect_async.dart';
       |export 'src/frontend/future_matchers.dart';
       |export 'src/frontend/on_platform.dart';
       |export 'src/frontend/prints_matcher.dart';
       |export 'src/frontend/skip.dart';
       |export 'src/frontend/spawn_hybrid.dart';
       |export 'src/frontend/stream_matcher.dart';
       |export 'src/frontend/stream_matchers.dart';
       |export 'src/frontend/tags.dart';
       |export 'src/frontend/test_on.dart';
       |export 'src/frontend/throws_matcher.dart';
       |export 'src/frontend/throws_matchers.dart';
       |export 'src/frontend/timeout.dart';
       |
       |/// The global declarer.
       |///
       |/// This is used if a test file is run directly, rather than through the runner.
       |Declarer _globalDeclarer;
       |
       |/// Gets the declarer for the current scope.
       |///
       |/// When using the runner, this returns the [Zone]-scoped declarer that's set by
       |/// [IsolateListener] or [IframeListener]. If the test file is run directly,
       |/// this returns [_globalDeclarer] (and sets it up on the first call).
       |Declarer get _declarer {
      1|  var declarer = Declarer.current;
       |  if (declarer != null) return declarer;
       |  if (_globalDeclarer != null) return _globalDeclarer;
       |
       |  // Since there's no Zone-scoped declarer, the test file is being run directly.
       |  // In order to run the tests, we set up our own Declarer via
       |  // [_globalDeclarer], and schedule a microtask to run the tests once they're
       |  // finished being defined.
      1|  _globalDeclarer = new Declarer();
      1|  scheduleMicrotask(() async {
      1|    var suite = new RunnerSuite(const PluginEnvironment(),
      2|        SuiteConfiguration.empty, _globalDeclarer.build(),
      2|        path: p.prettyUri(Uri.base),
       |        platform: TestPlatform.vm,
      1|        os: currentOSGuess);
       |
      1|    var engine = new Engine();
      2|    engine.suiteSink.add(suite);
      2|    engine.suiteSink.close();
      1|    ExpandedReporter.watch(engine,
       |        color: true, printPath: false, printPlatform: false);
       |
      2|    var success = await engine.run();
       |    // TODO(nweiz): Set the exit code on the VM when issue 6943 is fixed.
      0|    if (success) return null;
      1|    print('');
      1|    new Future.error("Dummy exception to set exit code.");
      1|  });
       |  return _globalDeclarer;
       |}
       |
       |// TODO(nweiz): This and other top-level functions should throw exceptions if
       |// they're called after the declarer has finished declaring.
       |/// Creates a new test case with the given description (converted to a string)
       |/// and body.
       |///
       |/// The description will be added to the descriptions of any surrounding
       |/// [group]s. If [testOn] is passed, it's parsed as a [platform selector][]; the
       |/// test will only be run on matching platforms.
       |///
       |/// [platform selector]: https://github.com/dart-lang/test/#platform-selector-syntax
       |///
       |/// If [timeout] is passed, it's used to modify or replace the default timeout
       |/// of 30 seconds. Timeout modifications take precedence in suite-group-test
       |/// order, so [timeout] will also modify any timeouts set on the group or suite.
       |///
       |/// If [skip] is a String or `true`, the test is skipped. If it's a String, it
       |/// should explain why the test is skipped; this reason will be printed instead
       |/// of running the test.
       |///
       |/// If [tags] is passed, it declares user-defined tags that are applied to the
       |/// test. These tags can be used to select or skip the test on the command line,
       |/// or to do bulk test configuration. All tags should be declared in the
       |/// [package configuration file][configuring tags]. The parameter can be an
       |/// [Iterable] of tag names, or a [String] representing a single tag.
       |///
       |/// [configuring tags]: https://github.com/dart-lang/test/blob/master/doc/package_config.md#configuring-tags
       |///
       |/// [onPlatform] allows tests to be configured on a platform-by-platform
       |/// basis. It's a map from strings that are parsed as [PlatformSelector]s to
       |/// annotation classes: [Timeout], [Skip], or lists of those. These
       |/// annotations apply only on the given platforms. For example:
       |///
       |///     test("potentially slow test", () {
       |///       // ...
       |///     }, onPlatform: {
       |///       // This test is especially slow on Windows.
       |///       "windows": new Timeout.factor(2),
       |///       "browser": [
       |///         new Skip("TODO: add browser support"),
       |///         // This will be slow on browsers once it works on them.
       |///         new Timeout.factor(2)
       |///       ]
       |///     });
       |///
       |/// If multiple platforms match, the annotations apply in order as through
       |/// they were in nested groups.
       |void test(description, body(),
       |    {String testOn,
       |    Timeout timeout,
       |    skip,
       |    tags,
       |    Map<String, dynamic> onPlatform}) {
      3|  _declarer.test(description.toString(), body,
       |      testOn: testOn,
       |      timeout: timeout,
       |      skip: skip,
       |      onPlatform: onPlatform,
       |      tags: tags);
       |
       |  // Force dart2js not to inline this function. We need it to be separate from
       |  // `main()` in JS stack traces in order to properly determine the line and
       |  // column where the test was defined. See sdk#26705.
       |  return;
       |  return;
       |}
       |
       |/// Creates a group of tests.
       |///
       |/// A group's description (converted to a string) is included in the descriptions
       |/// of any tests or sub-groups it contains. [setUp] and [tearDown] are also scoped
       |/// to the containing group.
       |///
       |/// If [testOn] is passed, it's parsed as a [platform selector][]; the test will
       |/// only be run on matching platforms.
       |///
       |/// [platform selector]: https://github.com/dart-lang/test/#platform-selector-syntax
       |///
       |/// If [timeout] is passed, it's used to modify or replace the default timeout
       |/// of 30 seconds. Timeout modifications take precedence in suite-group-test
       |/// order, so [timeout] will also modify any timeouts set on the suite, and will
       |/// be modified by any timeouts set on individual tests.
       |///
       |/// If [skip] is a String or `true`, the group is skipped. If it's a String, it
       |/// should explain why the group is skipped; this reason will be printed instead
       |/// of running the group's tests.
       |///
       |/// If [tags] is passed, it declares user-defined tags that are applied to the
       |/// test. These tags can be used to select or skip the test on the command line,
       |/// or to do bulk test configuration. All tags should be declared in the
       |/// [package configuration file][configuring tags]. The parameter can be an
       |/// [Iterable] of tag names, or a [String] representing a single tag.
       |///
       |/// [configuring tags]: https://github.com/dart-lang/test/blob/master/doc/package_config.md#configuring-tags
       |///
       |/// [onPlatform] allows groups to be configured on a platform-by-platform
       |/// basis. It's a map from strings that are parsed as [PlatformSelector]s to
       |/// annotation classes: [Timeout], [Skip], or lists of those. These
       |/// annotations apply only on the given platforms. For example:
       |///
       |///     group("potentially slow tests", () {
       |///       // ...
       |///     }, onPlatform: {
       |///       // These tests are especially slow on Windows.
       |///       "windows": new Timeout.factor(2),
       |///       "browser": [
       |///         new Skip("TODO: add browser support"),
       |///         // They'll be slow on browsers once it works on them.
       |///         new Timeout.factor(2)
       |///       ]
       |///     });
       |///
       |/// If multiple platforms match, the annotations apply in order as through
       |/// they were in nested groups.
       |void group(description, body(),
       |    {String testOn,
       |    Timeout timeout,
       |    skip,
       |    tags,
       |    Map<String, dynamic> onPlatform}) {
      3|  _declarer.group(description.toString(), body,
       |      testOn: testOn, timeout: timeout, skip: skip, tags: tags);
       |
       |  // Force dart2js not to inline this function. We need it to be separate from
       |  // `main()` in JS stack traces in order to properly determine the line and
       |  // column where the test was defined. See sdk#26705.
       |  return;
       |  return;
       |}
       |
       |/// Registers a function to be run before tests.
       |///
       |/// This function will be called before each test is run. [callback] may be
       |/// asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, it applies only to tests in that
       |/// group. [callback] will be run after any set-up callbacks in parent groups or
       |/// at the top level.
       |///
       |/// Each callback at the top level or in a given group will be run in the order
       |/// they were declared.
      0|void setUp(callback()) => _declarer.setUp(callback);
       |
       |/// Registers a function to be run after tests.
       |///
       |/// This function will be called after each test is run. [callback] may be
       |/// asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, it applies only to tests in that
       |/// group. [callback] will be run before any tear-down callbacks in parent
       |/// groups or at the top level.
       |///
       |/// Each callback at the top level or in a given group will be run in the
       |/// reverse of the order they were declared.
       |///
       |/// See also [addTearDown], which adds tear-downs to a running test.
      0|void tearDown(callback()) => _declarer.tearDown(callback);
       |
       |/// Registers a function to be run after the current test.
       |///
       |/// This is called within a running test, and adds a tear-down only for the
       |/// current test. It allows testing libraries to add cleanup logic as soon as
       |/// there's something to clean up.
       |///
       |/// The [callback] is run before any callbacks registered with [tearDown]. Like
       |/// [tearDown], the most recently registered callback is run first.
       |void addTearDown(callback()) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("addTearDown() may only be called within a test.");
       |  }
       |
      0|  Invoker.current.addTearDown(callback);
       |}
       |
       |/// Registers a function to be run once before all tests.
       |///
       |/// [callback] may be asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, [callback] will run before all tests
       |/// in that group. It will be run after any [setUpAll] callbacks in parent
       |/// groups or at the top level. It won't be run if none of the tests in the
       |/// group are run.
       |///
       |/// **Note**: This function makes it very easy to accidentally introduce hidden
       |/// dependencies between tests that should be isolated. In general, you should
       |/// prefer [setUp], and only use [setUpAll] if the callback is prohibitively
       |/// slow.
      0|void setUpAll(callback()) => _declarer.setUpAll(callback);
       |
       |/// Registers a function to be run once after all tests.
       |///
       |/// If this is called within a test group, [callback] will run after all tests
       |/// in that group. It will be run before any [tearDownAll] callbacks in parent
       |/// groups or at the top level. It won't be run if none of the tests in the
       |/// group are run.
       |///
       |/// **Note**: This function makes it very easy to accidentally introduce hidden
       |/// dependencies between tests that should be isolated. In general, you should
       |/// prefer [tearDown], and only use [tearDOwnAll] if the callback is
       |/// prohibitively slow.
      0|void tearDownAll(callback()) => _declarer.tearDownAll(callback);
       |
       |/// Registers an exception that was caught for the current test.
       |void registerException(error, [StackTrace stackTrace]) {
       |  // This will usually forward directly to [Invoker.current.handleError], but
       |  // going through the zone API allows other zones to consistently see errors.
      0|  Zone.current.handleUncaughtError(error, stackTrace);
       |}
       |
       |/// Prints [message] if and when the current test fails.
       |///
       |/// This is intended for test infrastructure to provide debugging information
       |/// without cluttering the output for successful tests. Note that unlike
       |/// [print], each individual message passed to [printOnFailure] will be
       |/// separated by a blank line.
      0|void printOnFailure(String message) => Invoker.current.printOnFailure(message);
/Users/tobe/Source/Dart/pug/test/syntax/scan/common.dart
       |import 'package:compiler_tools/compiler_tools.dart';
       |import 'package:matcher/matcher.dart';
       |import 'package:pug/src/syntax/scanner.dart';
       |import 'package:pug/src/syntax/token_type.dart';
       |export 'package:pug/src/syntax/token_type.dart';
       |
       |List<Token<TokenType>> scan(String text) {
      2|  var scanner = new Scanner()..scan(text);
      2|  if (scanner.syntaxErrors.isNotEmpty)
      0|    throw scanner.syntaxErrors.first;
       |  else
      1|    return scanner.tokens;
       |}
       |
      1|Matcher equalsScanned(Iterable<TokenType> expected) => new _EqualsScanned(expected);
       |
       |class _EqualsScanned extends Matcher {
       |  final Iterable<TokenType> _expected;
       |  List<Token<TokenType>> _tokens;
       |
      1|  _EqualsScanned(this._expected);
       |
       |  @override
       |  Description describe(Description description) =>
      3|      description.add('matches token type sequence: $_expected');
       |
       |  @override
       |  Description describeMismatch(item, Description mismatchDescription,
       |      Map matchState, bool verbose) {
      3|    print('equalsScanned failed: ${matchState["reason"]}');
      1|    print('Tokens: ');
       |
      2|    for (var token in _tokens) {
      5|      print('  "${token.text.replaceAll('\n', '\\n ')}" => ${token.type}');
       |    }
       |
      1|    return super.describeMismatch(item, mismatchDescription, matchState, verbose);
       |  }
       |
       |  @override
       |  bool matches(String item, Map matchState) {
      2|    _tokens = scan(item);
      3|    return equals(_expected.toList())
      5|        .matches(_tokens.map<TokenType>((t) => t.type).toList(), matchState);
       |  }
       |}
/Users/tobe/Source/Dart/pug/lib/src/syntax/scanner.dart
       |import 'package:compiler_tools/compiler_tools.dart';
       |import 'package:string_scanner/string_scanner.dart';
       |import 'token_type.dart';
       |
       |final RegExp _WHITESPACE = new RegExp(r'( |\n|\r|\t)+');
       |
       |final Map<Pattern, TokenType> _PATTERNS = {
       |  '[': TokenType.LBRACKET,
       |  ']': TokenType.RBRACKET,
       |  '(': TokenType.LPAREN,
       |  ')': TokenType.RPAREN,
       |  ';': TokenType.SEMI,
       |  '&': TokenType.AMPERSAND,
       |  '|': TokenType.PIPE,
       |  '//': TokenType.COMMENT_START,
       |  '//-': TokenType.COMMENT_START_UNBUFFERED,
       |  '*': TokenType.ASTERISK,
       |  ':': TokenType.COLON,
       |  ',': TokenType.COMMA,
       |  '-': TokenType.DASH,
       |  '.': TokenType.DOT,
       |  '=': TokenType.EQUALS,
       |  '+': TokenType.PLUS,
       |  '/': TokenType.SLASH,
       |  '?': TokenType.QUESTION,
       |  '&&': TokenType.BOOL_AND,
       |  '==': TokenType.EQUALS,
       |  '!=': TokenType.BOOL_NOT_EQUALS,
       |  '||': TokenType.BOOL_OR,
       |  'append': TokenType.APPEND,
       |  'block': TokenType.BLOCK,
       |  'doctype': TokenType.DOCTYPE,
       |  'each': TokenType.EACH,
       |  'extends': TokenType.EXTENDS,
       |  'if': TokenType.IF,
       |  'in': TokenType.IN,
       |  'include': TokenType.INCLUDE,
       |  'else': TokenType.ELSE,
       |  'mixin': TokenType.MIXIN,
       |  'prepend': TokenType.PREPEND,
       |  'unless': TokenType.UNLESS,
       |  'while': TokenType.WHILE,
       |  'true': TokenType.BOOLEAN,
       |  'false': TokenType.BOOLEAN,
       |  new RegExp(r'-?[0-9]+(\.[0-9]+)?((E|e)-?[0-9]+)?'): TokenType.NUMBER,
       |  new RegExp(r"'(([^'\n\r])|(\\')|(\\(n|r)))*'"):
       |      TokenType.SINGLE_QUOTED_STRING,
       |  new RegExp(r'"(([^"\n\r])|(\\")|(\\(n|r)))*"'):
       |      TokenType.DOUBLE_QUOTED_STRING,
       |  new RegExp(r'`[^`]*`'): TokenType.TEMPLATE_STRING,
       |  new RegExp(r'\.-?[_a-zA-Z]+[_a-zA-Z0-9-]*'): TokenType.CLASS_NAME,
       |  new RegExp(r'#[^\s]+'): TokenType.ELEMENT_ID,
       |  new RegExp(r'[_a-zA-Z]+[_a-zA-Z0-9-]*'): TokenType.TAG_NAME,
       |  new RegExp(r'<[^\n]*(\n|$)'): TokenType.PLAIN_TEXT,
       |  '\n  ': TokenType.INDENT,
       |  _WHITESPACE: TokenType.WHITESPACE
       |};
       |
       |class Scanner {
       |  final List<SyntaxError> _syntaxErrors = [];
       |  final List<Token<TokenType>> _tokens = [];
       |
       |  List<SyntaxError> get syntaxErrors =>
      2|      new List<SyntaxError>.unmodifiable(_syntaxErrors);
       |
       |  List<Token<TokenType>> get tokens =>
      2|      new List<Token<TokenType>>.unmodifiable(_tokens);
       |
       |  void scan(String text, {sourceUrl}) {
      1|    var scanner = new SpanScanner(text, sourceUrl: sourceUrl);
       |    LineScannerState arbitraryStart;
       |
       |    void flushBuffer() {
       |      if (arbitraryStart != null) {
      0|        _tokens.add(new Token(TokenType.ARBITRARY_TEXT,
      0|            span: scanner.spanFrom(arbitraryStart)));
       |        arbitraryStart = null;
       |      }
       |    }
       |
      1|    while (!scanner.isDone) {
       |      bool matched = false;
       |
      3|      for (var pattern in _PATTERNS.keys) {
      1|        if (scanner.scan(pattern)) {
      1|          flushBuffer();
      6|          _tokens.add(new Token(_PATTERNS[pattern], span: scanner.lastSpan));
       |          matched = true;
       |          break;
       |        }
       |      }
       |
       |      if (!matched) {
      0|        if (arbitraryStart == null) arbitraryStart = scanner.state;
      0|        scanner.readChar();
       |      }
       |    }
       |
      1|    flushBuffer();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/core_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'description.dart';
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a matcher that matches the isEmpty property.
       |const Matcher isEmpty = const _Empty();
       |
       |class _Empty extends Matcher {
      0|  const _Empty();
       |
      0|  bool matches(item, Map matchState) => item.isEmpty;
       |
      0|  Description describe(Description description) => description.add('empty');
       |}
       |
       |/// Returns a matcher that matches the isNotEmpty property.
       |const Matcher isNotEmpty = const _NotEmpty();
       |
       |class _NotEmpty extends Matcher {
      0|  const _NotEmpty();
       |
      0|  bool matches(item, Map matchState) => item.isNotEmpty;
       |
      0|  Description describe(Description description) => description.add('non-empty');
       |}
       |
       |/// A matcher that matches any null value.
       |const Matcher isNull = const _IsNull();
       |
       |/// A matcher that matches any non-null value.
       |const Matcher isNotNull = const _IsNotNull();
       |
       |class _IsNull extends Matcher {
      0|  const _IsNull();
       |  bool matches(item, Map matchState) => item == null;
      0|  Description describe(Description description) => description.add('null');
       |}
       |
       |class _IsNotNull extends Matcher {
      0|  const _IsNotNull();
       |  bool matches(item, Map matchState) => item != null;
      0|  Description describe(Description description) => description.add('not null');
       |}
       |
       |/// A matcher that matches the Boolean value true.
       |const Matcher isTrue = const _IsTrue();
       |
       |/// A matcher that matches anything except the Boolean value true.
       |const Matcher isFalse = const _IsFalse();
       |
       |class _IsTrue extends Matcher {
      0|  const _IsTrue();
      0|  bool matches(item, Map matchState) => item == true;
      0|  Description describe(Description description) => description.add('true');
       |}
       |
       |class _IsFalse extends Matcher {
      0|  const _IsFalse();
      0|  bool matches(item, Map matchState) => item == false;
      0|  Description describe(Description description) => description.add('false');
       |}
       |
       |/// A matcher that matches the numeric value NaN.
       |const Matcher isNaN = const _IsNaN();
       |
       |/// A matcher that matches any non-NaN value.
       |const Matcher isNotNaN = const _IsNotNaN();
       |
       |class _IsNaN extends Matcher {
      0|  const _IsNaN();
      0|  bool matches(item, Map matchState) => double.NAN.compareTo(item) == 0;
      0|  Description describe(Description description) => description.add('NaN');
       |}
       |
       |class _IsNotNaN extends Matcher {
      0|  const _IsNotNaN();
      0|  bool matches(item, Map matchState) => double.NAN.compareTo(item) != 0;
      0|  Description describe(Description description) => description.add('not NaN');
       |}
       |
       |/// Returns a matches that matches if the value is the same instance
       |/// as [expected], using [identical].
      0|Matcher same(expected) => new _IsSameAs(expected);
       |
       |class _IsSameAs extends Matcher {
       |  final _expected;
      0|  const _IsSameAs(this._expected);
      0|  bool matches(item, Map matchState) => identical(item, _expected);
       |  // If all types were hashable we could show a hash here.
       |  Description describe(Description description) =>
      0|      description.add('same instance as ').addDescriptionOf(_expected);
       |}
       |
       |/// Returns a matcher that matches if the value is structurally equal to
       |/// [expected].
       |///
       |/// If [expected] is a [Matcher], then it matches using that. Otherwise it tests
       |/// for equality using `==` on the expected value.
       |///
       |/// For [Iterable]s and [Map]s, this will recursively match the elements. To
       |/// handle cyclic structures a recursion depth [limit] can be provided. The
       |/// default limit is 100. [Set]s will be compared order-independently.
      1|Matcher equals(expected, [int limit = 100]) => expected is String
      0|    ? new _StringEqualsMatcher(expected)
      1|    : new _DeepMatcher(expected, limit);
       |
       |class _DeepMatcher extends Matcher {
       |  final _expected;
       |  final int _limit;
       |  var count;
       |
      1|  _DeepMatcher(this._expected, [int limit = 1000]) : this._limit = limit;
       |
       |  // Returns a pair (reason, location)
       |  List _compareIterables(expected, actual, matcher, depth, location) {
      1|    if (actual is! Iterable) return ['is not Iterable', location];
       |
      1|    var expectedIterator = expected.iterator;
      1|    var actualIterator = actual.iterator;
      1|    for (var index = 0; ; index++) {
       |      // Advance in lockstep.
      1|      var expectedNext = expectedIterator.moveNext();
      1|      var actualNext = actualIterator.moveNext();
       |
       |      // If we reached the end of both, we succeeded.
       |      if (!expectedNext && !actualNext) return null;
       |
       |      // Fail if their lengths are different.
      1|      var newLocation = '${location}[${index}]';
      0|      if (!expectedNext) return ['longer than expected', newLocation];
      0|      if (!actualNext) return ['shorter than expected', newLocation];
       |
       |      // Match the elements.
      1|      var rp = matcher(
      2|          expectedIterator.current, actualIterator.current, newLocation, depth);
       |      if (rp != null) return rp;
       |    }
       |  }
       |
       |  List _compareSets(Set expected, actual, matcher, depth, location) {
      0|    if (actual is! Iterable) return ['is not Iterable', location];
      0|    actual = actual.toSet();
       |
      0|    for (var expectedElement in expected) {
      0|      if (actual.every((actualElement) =>
      0|          matcher(expectedElement, actualElement, location, depth) != null)) {
      0|        return ['does not contain $expectedElement', location];
       |      }
       |    }
       |
      0|    if (actual.length > expected.length) {
      0|      return ['larger than expected', location];
      0|    } else if (actual.length < expected.length) {
      0|      return ['smaller than expected', location];
       |    } else {
       |      return null;
       |    }
       |  }
       |
       |  List _recursiveMatch(expected, actual, String location, int depth) {
       |    // If the expected value is a matcher, try to match it.
      1|    if (expected is Matcher) {
      0|      var matchState = {};
      0|      if (expected.matches(actual, matchState)) return null;
       |
      0|      var description = new StringDescription();
      0|      expected.describe(description);
      0|      return ['does not match $description', location];
       |    } else {
       |      // Otherwise, test for equality.
       |      try {
      1|        if (expected == actual) return null;
       |      } catch (e) {
       |        // TODO(gram): Add a test for this case.
      0|        return ['== threw "$e"', location];
       |      }
       |    }
       |
      2|    if (depth > _limit) return ['recursion depth limit exceeded', location];
       |
       |    // If _limit is 1 we can only recurse one level into object.
      3|    if (depth == 0 || _limit > 1) {
      1|      if (expected is Set) {
      0|        return _compareSets(
      0|            expected, actual, _recursiveMatch, depth + 1, location);
      1|      } else if (expected is Iterable) {
      1|        return _compareIterables(
      2|            expected, actual, _recursiveMatch, depth + 1, location);
      1|      } else if (expected is Map) {
      0|        if (actual is! Map) return ['expected a map', location];
       |
      0|        var err = (expected.length == actual.length)
       |            ? ''
       |            : 'has different length and ';
      0|        for (var key in expected.keys) {
      0|          if (!actual.containsKey(key)) {
      0|            return ["${err}is missing map key '$key'", location];
       |          }
       |        }
       |
      0|        for (var key in actual.keys) {
      0|          if (!expected.containsKey(key)) {
      0|            return ["${err}has extra map key '$key'", location];
       |          }
       |        }
       |
      0|        for (var key in expected.keys) {
      0|          var rp = _recursiveMatch(
      0|              expected[key], actual[key], "${location}['${key}']", depth + 1);
       |          if (rp != null) return rp;
       |        }
       |
       |        return null;
       |      }
       |    }
       |
      1|    var description = new StringDescription();
       |
       |    // If we have recursed, show the expected value too; if not, expect() will
       |    // show it for us.
      1|    if (depth > 0) {
       |      description
      1|          .add('was ')
      1|          .addDescriptionOf(actual)
      1|          .add(' instead of ')
      1|          .addDescriptionOf(expected);
      2|      return [description.toString(), location];
       |    }
       |
       |    // We're not adding any value to the actual value.
      0|    return ["", location];
       |  }
       |
       |  String _match(expected, actual, Map matchState) {
      1|    var rp = _recursiveMatch(expected, actual, '', 0);
       |    if (rp == null) return null;
       |    var reason;
      3|    if (rp[0].length > 0) {
      3|      if (rp[1].length > 0) {
      3|        reason = "${rp[0]} at location ${rp[1]}";
       |      } else {
      0|        reason = rp[0];
       |      }
       |    } else {
       |      reason = '';
       |    }
       |    // Cache the failure reason in the matchState.
      2|    addStateInfo(matchState, {'reason': reason});
       |    return reason;
       |  }
       |
       |  bool matches(item, Map matchState) =>
      2|      _match(_expected, item, matchState) == null;
       |
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_expected);
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    var reason = matchState['reason'];
       |    // If we didn't get a good reason, that would normally be a
       |    // simple 'is <value>' message. We only add that if the mismatch
       |    // description is non empty (so we are supplementing the mismatch
       |    // description).
      0|    if (reason.length == 0 && mismatchDescription.length > 0) {
      0|      mismatchDescription.add('is ').addDescriptionOf(item);
       |    } else {
      0|      mismatchDescription.add(reason);
       |    }
       |    return mismatchDescription;
       |  }
       |}
       |
       |/// A special equality matcher for strings.
       |class _StringEqualsMatcher extends Matcher {
       |  final String _value;
       |
      0|  _StringEqualsMatcher(this._value);
       |
       |  bool get showActualValue => true;
       |
      0|  bool matches(item, Map matchState) => _value == item;
       |
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_value);
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is! String) {
      0|      return mismatchDescription.addDescriptionOf(item).add('is not a string');
       |    } else {
      0|      var buff = new StringBuffer();
      0|      buff.write('is different.');
      0|      var escapedItem = escape(item);
      0|      var escapedValue = escape(_value);
      0|      int minLength = escapedItem.length < escapedValue.length
      0|          ? escapedItem.length
      0|          : escapedValue.length;
       |      var start = 0;
      0|      for (; start < minLength; start++) {
      0|        if (escapedValue.codeUnitAt(start) != escapedItem.codeUnitAt(start)) {
       |          break;
       |        }
       |      }
      0|      if (start == minLength) {
      0|        if (escapedValue.length < escapedItem.length) {
      0|          buff.write(' Both strings start the same, but the given value also'
       |              ' has the following trailing characters: ');
      0|          _writeTrailing(buff, escapedItem, escapedValue.length);
       |        } else {
      0|          buff.write(' Both strings start the same, but the given value is'
       |              ' missing the following trailing characters: ');
      0|          _writeTrailing(buff, escapedValue, escapedItem.length);
       |        }
       |      } else {
      0|        buff.write('\nExpected: ');
      0|        _writeLeading(buff, escapedValue, start);
      0|        _writeTrailing(buff, escapedValue, start);
      0|        buff.write('\n  Actual: ');
      0|        _writeLeading(buff, escapedItem, start);
      0|        _writeTrailing(buff, escapedItem, start);
      0|        buff.write('\n          ');
      0|        for (int i = (start > 10 ? 14 : start); i > 0; i--) buff.write(' ');
      0|        buff.write('^\n Differ at offset $start');
       |      }
       |
      0|      return mismatchDescription.replace(buff.toString());
       |    }
       |  }
       |
       |  static void _writeLeading(StringBuffer buff, String s, int start) {
      0|    if (start > 10) {
      0|      buff.write('... ');
      0|      buff.write(s.substring(start - 10, start));
       |    } else {
      0|      buff.write(s.substring(0, start));
       |    }
       |  }
       |
       |  static void _writeTrailing(StringBuffer buff, String s, int start) {
      0|    if (start + 10 > s.length) {
      0|      buff.write(s.substring(start));
       |    } else {
      0|      buff.write(s.substring(start, start + 10));
      0|      buff.write(' ...');
       |    }
       |  }
       |}
       |
       |/// A matcher that matches any value.
       |const Matcher anything = const _IsAnything();
       |
       |class _IsAnything extends Matcher {
      0|  const _IsAnything();
       |  bool matches(item, Map matchState) => true;
      0|  Description describe(Description description) => description.add('anything');
       |}
       |
       |/// Returns a matcher that matches if an object is an instance
       |/// of [type] (or a subtype).
       |///
       |/// As types are not first class objects in Dart we can only
       |/// approximate this test by using a generic wrapper class.
       |///
       |/// For example, to test whether 'bar' is an instance of type
       |/// 'Foo', we would write:
       |///
       |///     expect(bar, new isInstanceOf<Foo>());
       |class isInstanceOf<T> extends Matcher {
      0|  const isInstanceOf();
       |
      0|  bool matches(obj, Map matchState) => obj is T;
       |
       |  Description describe(Description description) =>
      0|      description.add('an instance of $T');
       |}
       |
       |/// A matcher that matches a function call against no exception.
       |///
       |/// The function will be called once. Any exceptions will be silently swallowed.
       |/// The value passed to expect() should be a reference to the function.
       |/// Note that the function cannot take arguments; to handle this
       |/// a wrapper will have to be created.
       |const Matcher returnsNormally = const _ReturnsNormally();
       |
       |class _ReturnsNormally extends Matcher {
      0|  const _ReturnsNormally();
       |
       |  bool matches(f, Map matchState) {
       |    try {
      0|      f();
       |      return true;
       |    } catch (e, s) {
      0|      addStateInfo(matchState, {'exception': e, 'stack': s});
       |      return false;
       |    }
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add("return normally");
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    mismatchDescription.add('threw ').addDescriptionOf(matchState['exception']);
       |    if (verbose) {
      0|      mismatchDescription.add(' at ').add(matchState['stack'].toString());
       |    }
       |    return mismatchDescription;
       |  }
       |}
       |
       |/*
       | * Matchers for different exception types. Ideally we should just be able to
       | * use something like:
       | *
       | * final Matcher throwsException =
       | *     const _Throws(const isInstanceOf<Exception>());
       | *
       | * Unfortunately instanceOf is not working with dart2js.
       | *
       | * Alternatively, if static functions could be used in const expressions,
       | * we could use:
       | *
       | * bool _isException(x) => x is Exception;
       | * final Matcher isException = const _Predicate(_isException, "Exception");
       | * final Matcher throwsException = const _Throws(isException);
       | *
       | * But currently using static functions in const expressions is not supported.
       | * For now the only solution for all platforms seems to be separate classes
       | * for each exception type.
       | */
       |
       |abstract class TypeMatcher extends Matcher {
       |  final String _name;
      0|  const TypeMatcher(this._name);
      0|  Description describe(Description description) => description.add(_name);
       |}
       |
       |/// A matcher for Map types.
       |const Matcher isMap = const _IsMap();
       |
       |class _IsMap extends TypeMatcher {
      0|  const _IsMap() : super("Map");
      0|  bool matches(item, Map matchState) => item is Map;
       |}
       |
       |/// A matcher for List types.
       |const Matcher isList = const _IsList();
       |
       |class _IsList extends TypeMatcher {
      0|  const _IsList() : super("List");
      0|  bool matches(item, Map matchState) => item is List;
       |}
       |
       |/// Returns a matcher that matches if an object has a length property
       |/// that matches [matcher].
      0|Matcher hasLength(matcher) => new _HasLength(wrapMatcher(matcher));
       |
       |class _HasLength extends Matcher {
       |  final Matcher _matcher;
      0|  const _HasLength([Matcher matcher = null]) : this._matcher = matcher;
       |
       |  bool matches(item, Map matchState) {
       |    try {
       |      // This is harmless code that will throw if no length property
       |      // but subtle enough that an optimizer shouldn't strip it out.
      0|      if (item.length * item.length >= 0) {
      0|        return _matcher.matches(item.length, matchState);
       |      }
       |    } catch (e) {}
       |    return false;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add('an object with length of ').addDescriptionOf(_matcher);
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
       |    try {
       |      // We want to generate a different description if there is no length
       |      // property; we use the same trick as in matches().
      0|      if (item.length * item.length >= 0) {
       |        return mismatchDescription
      0|            .add('has length of ')
      0|            .addDescriptionOf(item.length);
       |      }
       |    } catch (e) {}
      0|    return mismatchDescription.add('has no length property');
       |  }
       |}
       |
       |/// Returns a matcher that matches if the match argument contains the expected
       |/// value.
       |///
       |/// For [String]s this means substring matching;
       |/// for [Map]s it means the map has the key, and for [Iterable]s
       |/// it means the iterable has a matching element. In the case of iterables,
       |/// [expected] can itself be a matcher.
      0|Matcher contains(expected) => new _Contains(expected);
       |
       |class _Contains extends Matcher {
       |  final _expected;
       |
      0|  const _Contains(this._expected);
       |
       |  bool matches(item, Map matchState) {
      0|    if (item is String) {
      0|      return item.indexOf(_expected) >= 0;
      0|    } else if (item is Iterable) {
      0|      if (_expected is Matcher) {
      0|        return item.any((e) => _expected.matches(e, matchState));
       |      } else {
      0|        return item.contains(_expected);
       |      }
      0|    } else if (item is Map) {
      0|      return item.containsKey(_expected);
       |    }
       |    return false;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add('contains ').addDescriptionOf(_expected);
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is String || item is Iterable || item is Map) {
      0|      return super.describeMismatch(
       |          item, mismatchDescription, matchState, verbose);
       |    } else {
      0|      return mismatchDescription.add('is not a string, map or iterable');
       |    }
       |  }
       |}
       |
       |/// Returns a matcher that matches if the match argument is in
       |/// the expected value. This is the converse of [contains].
      0|Matcher isIn(expected) => new _In(expected);
       |
       |class _In extends Matcher {
       |  final _expected;
       |
      0|  const _In(this._expected);
       |
       |  bool matches(item, Map matchState) {
      0|    if (_expected is String) {
      0|      return _expected.indexOf(item) >= 0;
      0|    } else if (_expected is Iterable) {
      0|      return _expected.any((e) => e == item);
      0|    } else if (_expected is Map) {
      0|      return _expected.containsKey(item);
       |    }
       |    return false;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add('is in ').addDescriptionOf(_expected);
       |}
       |
       |/// Returns a matcher that uses an arbitrary function that returns
       |/// true or false for the actual value.
       |///
       |/// For example:
       |///
       |///     expect(v, predicate((x) => ((x % 2) == 0), "is even"))
       |Matcher predicate(bool f(value), [String description = 'satisfies function']) =>
      0|    new _Predicate(f, description);
       |
       |typedef bool _PredicateFunction(value);
       |
       |class _Predicate extends Matcher {
       |  final _PredicateFunction _matcher;
       |  final String _description;
       |
      0|  const _Predicate(this._matcher, this._description);
       |
      0|  bool matches(item, Map matchState) => _matcher(item);
       |
       |  Description describe(Description description) =>
      0|      description.add(_description);
       |}
       |
       |/// A useful utility class for implementing other matchers through inheritance.
       |/// Derived classes should call the base constructor with a feature name and
       |/// description, and an instance matcher, and should implement the
       |/// [featureValueOf] abstract method.
       |///
       |/// The feature description will typically describe the item and the feature,
       |/// while the feature name will just name the feature. For example, we may
       |/// have a Widget class where each Widget has a price; we could make a
       |/// [CustomMatcher] that can make assertions about prices with:
       |///
       |///     class HasPrice extends CustomMatcher {
       |///       const HasPrice(matcher) :
       |///           super("Widget with price that is", "price", matcher);
       |///       featureValueOf(actual) => actual.price;
       |///     }
       |///
       |/// and then use this for example like:
       |///
       |///      expect(inventoryItem, new HasPrice(greaterThan(0)));
       |class CustomMatcher extends Matcher {
       |  final String _featureDescription;
       |  final String _featureName;
       |  final Matcher _matcher;
       |
       |  CustomMatcher(this._featureDescription, this._featureName, matcher)
      0|      : this._matcher = wrapMatcher(matcher);
       |
       |  /// Override this to extract the interesting feature.
       |  featureValueOf(actual) => actual;
       |
       |  bool matches(item, Map matchState) {
      0|    var f = featureValueOf(item);
      0|    if (_matcher.matches(f, matchState)) return true;
      0|    addStateInfo(matchState, {'feature': f});
       |    return false;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add(_featureDescription).add(' ').addDescriptionOf(_matcher);
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
       |    mismatchDescription
      0|        .add('has ')
      0|        .add(_featureName)
      0|        .add(' with value ')
      0|        .addDescriptionOf(matchState['feature']);
      0|    var innerDescription = new StringDescription();
      0|    _matcher.describeMismatch(
      0|        matchState['feature'], innerDescription, matchState['state'], verbose);
      0|    if (innerDescription.length > 0) {
      0|      mismatchDescription.add(' which ').add(innerDescription.toString());
       |    }
       |    return mismatchDescription;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/description.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |import 'pretty_print.dart';
       |
       |/// The default implementation of [Description]. This should rarely need
       |/// substitution, although conceivably it is a place where other languages
       |/// could be supported.
       |class StringDescription implements Description {
       |  final StringBuffer _out = new StringBuffer();
       |
       |  /// Initialize the description with initial contents [init].
      1|  StringDescription([String init = '']) {
      2|    _out.write(init);
       |  }
       |
      0|  int get length => _out.length;
       |
       |  /// Get the description as a string.
      2|  String toString() => _out.toString();
       |
       |  /// Append [text] to the description.
       |  Description add(String text) {
      2|    _out.write(text);
       |    return this;
       |  }
       |
       |  /// Change the value of the description.
       |  Description replace(String text) {
      0|    _out.clear();
      0|    return add(text);
       |  }
       |
       |  /// Appends a description of [value]. If it is an IMatcher use its
       |  /// describe method; if it is a string use its literal value after
       |  /// escaping any embedded control characters; otherwise use its
       |  /// toString() value and wrap it in angular "quotes".
       |  Description addDescriptionOf(value) {
      1|    if (value is Matcher) {
      1|      value.describe(this);
       |    } else {
      2|      add(prettyPrint(value, maxLineLength: 80, maxItems: 25));
       |    }
       |    return this;
       |  }
       |
       |  /// Append an [Iterable] [list] of objects to the description, using the
       |  /// specified [separator] and framing the list with [start]
       |  /// and [end].
       |  Description addAll(
       |      String start, String separator, String end, Iterable list) {
       |    var separate = false;
      0|    add(start);
      0|    for (var item in list) {
       |      if (separate) {
      0|        add(separator);
       |      }
      0|      addDescriptionOf(item);
       |      separate = true;
       |    }
      0|    add(end);
       |    return this;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/error_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'core_matchers.dart';
       |import 'interfaces.dart';
       |
       |/// A matcher for ArgumentErrors.
       |const Matcher isArgumentError = const _ArgumentError();
       |
       |class _ArgumentError extends TypeMatcher {
      0|  const _ArgumentError() : super("ArgumentError");
      0|  bool matches(item, Map matchState) => item is ArgumentError;
       |}
       |
       |/// A matcher for ConcurrentModificationError.
       |const Matcher isConcurrentModificationError =
       |    const _ConcurrentModificationError();
       |
       |class _ConcurrentModificationError extends TypeMatcher {
      0|  const _ConcurrentModificationError() : super("ConcurrentModificationError");
      0|  bool matches(item, Map matchState) => item is ConcurrentModificationError;
       |}
       |
       |/// A matcher for CyclicInitializationError.
       |const Matcher isCyclicInitializationError = const _CyclicInitializationError();
       |
       |class _CyclicInitializationError extends TypeMatcher {
      0|  const _CyclicInitializationError() : super("CyclicInitializationError");
      0|  bool matches(item, Map matchState) => item is CyclicInitializationError;
       |}
       |
       |/// A matcher for Exceptions.
       |const Matcher isException = const _Exception();
       |
       |class _Exception extends TypeMatcher {
      0|  const _Exception() : super("Exception");
      0|  bool matches(item, Map matchState) => item is Exception;
       |}
       |
       |/// A matcher for FormatExceptions.
       |const Matcher isFormatException = const _FormatException();
       |
       |class _FormatException extends TypeMatcher {
      0|  const _FormatException() : super("FormatException");
      0|  bool matches(item, Map matchState) => item is FormatException;
       |}
       |
       |/// A matcher for NoSuchMethodErrors.
       |const Matcher isNoSuchMethodError = const _NoSuchMethodError();
       |
       |class _NoSuchMethodError extends TypeMatcher {
      0|  const _NoSuchMethodError() : super("NoSuchMethodError");
      0|  bool matches(item, Map matchState) => item is NoSuchMethodError;
       |}
       |
       |/// A matcher for NullThrownError.
       |const Matcher isNullThrownError = const _NullThrownError();
       |
       |class _NullThrownError extends TypeMatcher {
      0|  const _NullThrownError() : super("NullThrownError");
      0|  bool matches(item, Map matchState) => item is NullThrownError;
       |}
       |
       |/// A matcher for RangeErrors.
       |const Matcher isRangeError = const _RangeError();
       |
       |class _RangeError extends TypeMatcher {
      0|  const _RangeError() : super("RangeError");
      0|  bool matches(item, Map matchState) => item is RangeError;
       |}
       |
       |/// A matcher for StateErrors.
       |const Matcher isStateError = const _StateError();
       |
       |class _StateError extends TypeMatcher {
      0|  const _StateError() : super("StateError");
      0|  bool matches(item, Map matchState) => item is StateError;
       |}
       |
       |/// A matcher for UnimplementedErrors.
       |const Matcher isUnimplementedError = const _UnimplementedError();
       |
       |class _UnimplementedError extends TypeMatcher {
      0|  const _UnimplementedError() : super("UnimplementedError");
      0|  bool matches(item, Map matchState) => item is UnimplementedError;
       |}
       |
       |/// A matcher for UnsupportedError.
       |const Matcher isUnsupportedError = const _UnsupportedError();
       |
       |class _UnsupportedError extends TypeMatcher {
      0|  const _UnsupportedError() : super("UnsupportedError");
      0|  bool matches(item, Map matchState) => item is UnsupportedError;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/interfaces.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// To decouple the reporting of errors, and allow for extensibility of
       |// matchers, we make use of some interfaces.
       |
       |/// Matchers build up their error messages by appending to
       |/// Description objects. This interface is implemented by
       |/// StringDescription. This interface is unlikely to need
       |/// other implementations, but could be useful to replace in
       |/// some cases - e.g. language conversion.
       |abstract class Description {
       |  int get length;
       |
       |  /// Change the value of the description.
       |  Description replace(String text);
       |
       |  /// This is used to add arbitrary text to the description.
       |  Description add(String text);
       |
       |  /// This is used to add a meaningful description of a value.
       |  Description addDescriptionOf(value);
       |
       |  /// This is used to add a description of an [Iterable] [list],
       |  /// with appropriate [start] and [end] markers and inter-element [separator].
       |  Description addAll(String start, String separator, String end, Iterable list);
       |}
       |
       |/// [expect] Matchers must implement/extend the Matcher class.
       |/// The base Matcher class has a generic implementation of [describeMismatch]
       |/// so this does not need to be provided unless a more clear description is
       |/// required. The other two methods ([matches] and [describe])
       |/// must always be provided as they are highly matcher-specific.
       |abstract class Matcher {
      1|  const Matcher();
       |
       |  /// This does the matching of the actual vs expected values.
       |  /// [item] is the actual value. [matchState] can be supplied
       |  /// and may be used to add details about the mismatch that are too
       |  /// costly to determine in [describeMismatch].
       |  bool matches(item, Map matchState);
       |
       |  /// This builds a textual description of the matcher.
       |  Description describe(Description description);
       |
       |  /// This builds a textual description of a specific mismatch. [item]
       |  /// is the value that was tested by [matches]; [matchState] is
       |  /// the [Map] that was passed to and supplemented by [matches]
       |  /// with additional information about the mismatch, and [mismatchDescription]
       |  /// is the [Description] that is being built to decribe the mismatch.
       |  /// A few matchers make use of the [verbose] flag to provide detailed
       |  /// information that is not typically included but can be of help in
       |  /// diagnosing failures, such as stack traces.
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) =>
       |      mismatchDescription;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/iterable_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'core_matchers.dart';
       |import 'description.dart';
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a matcher which matches [Iterable]s in which all elements
       |/// match the given [matcher].
      0|Matcher everyElement(matcher) => new _EveryElement(wrapMatcher(matcher));
       |
       |class _EveryElement extends _IterableMatcher {
       |  final Matcher _matcher;
       |
      0|  _EveryElement(Matcher this._matcher);
       |
       |  bool matches(item, Map matchState) {
      0|    if (item is! Iterable) {
       |      return false;
       |    }
       |    var i = 0;
      0|    for (var element in item) {
      0|      if (!_matcher.matches(element, matchState)) {
      0|        addStateInfo(matchState, {'index': i, 'element': element});
       |        return false;
       |      }
      0|      ++i;
       |    }
       |    return true;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add('every element(').addDescriptionOf(_matcher).add(')');
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (matchState['index'] != null) {
      0|      var index = matchState['index'];
      0|      var element = matchState['element'];
       |      mismatchDescription
      0|          .add('has value ')
      0|          .addDescriptionOf(element)
      0|          .add(' which ');
      0|      var subDescription = new StringDescription();
      0|      _matcher.describeMismatch(
      0|          element, subDescription, matchState['state'], verbose);
      0|      if (subDescription.length > 0) {
      0|        mismatchDescription.add(subDescription.toString());
       |      } else {
      0|        mismatchDescription.add("doesn't match ");
      0|        _matcher.describe(mismatchDescription);
       |      }
      0|      mismatchDescription.add(' at index $index');
       |      return mismatchDescription;
       |    }
      0|    return super.describeMismatch(
       |        item, mismatchDescription, matchState, verbose);
       |  }
       |}
       |
       |/// Returns a matcher which matches [Iterable]s in which at least one
       |/// element matches the given [matcher].
      0|Matcher anyElement(matcher) => new _AnyElement(wrapMatcher(matcher));
       |
       |class _AnyElement extends _IterableMatcher {
       |  final Matcher _matcher;
       |
      0|  _AnyElement(this._matcher);
       |
       |  bool matches(item, Map matchState) {
      0|    return item.any((e) => _matcher.matches(e, matchState));
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add('some element ').addDescriptionOf(_matcher);
       |}
       |
       |/// Returns a matcher which matches [Iterable]s that have the same
       |/// length and the same elements as [expected], in the same order.
       |///
       |/// This is equivalent to [equals] but does not recurse.
      0|Matcher orderedEquals(Iterable expected) => new _OrderedEquals(expected);
       |
       |class _OrderedEquals extends Matcher {
       |  final Iterable _expected;
       |  Matcher _matcher;
       |
      0|  _OrderedEquals(this._expected) {
      0|    _matcher = equals(_expected, 1);
       |  }
       |
       |  bool matches(item, Map matchState) =>
      0|      (item is Iterable) && _matcher.matches(item, matchState);
       |
       |  Description describe(Description description) =>
      0|      description.add('equals ').addDescriptionOf(_expected).add(' ordered');
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is! Iterable) {
      0|      return mismatchDescription.add('is not an Iterable');
       |    } else {
      0|      return _matcher.describeMismatch(
       |          item, mismatchDescription, matchState, verbose);
       |    }
       |  }
       |}
       |
       |/// Returns a matcher which matches [Iterable]s that have the same length and
       |/// the same elements as [expected], but not necessarily in the same order.
       |///
       |/// Note that this is O(n^2) so should only be used on small objects.
      0|Matcher unorderedEquals(Iterable expected) => new _UnorderedEquals(expected);
       |
       |class _UnorderedEquals extends _UnorderedMatches {
       |  final List _expectedValues;
       |
       |  _UnorderedEquals(Iterable expected)
      0|      : _expectedValues = expected.toList(),
      0|        super(expected.map(equals));
       |
       |  Description describe(Description description) => description
      0|      .add('equals ')
      0|      .addDescriptionOf(_expectedValues)
      0|      .add(' unordered');
       |}
       |
       |/// Iterable matchers match against [Iterable]s. We add this intermediate
       |/// class to give better mismatch error messages than the base Matcher class.
       |abstract class _IterableMatcher extends Matcher {
      0|  const _IterableMatcher();
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is! Iterable) {
      0|      return mismatchDescription.addDescriptionOf(item).add(' not an Iterable');
       |    } else {
      0|      return super.describeMismatch(
       |          item, mismatchDescription, matchState, verbose);
       |    }
       |  }
       |}
       |
       |/// Returns a matcher which matches [Iterable]s whose elements match the
       |/// matchers in [expected], but not necessarily in the same order.
       |///
       |///  Note that this is `O(n^2)` and so should only be used on small objects.
      0|Matcher unorderedMatches(Iterable expected) => new _UnorderedMatches(expected);
       |
       |class _UnorderedMatches extends Matcher {
       |  final List<Matcher> _expected;
       |
       |  _UnorderedMatches(Iterable expected)
      0|      : _expected = expected.map(wrapMatcher).toList();
       |
       |  String _test(item) {
      0|    if (item is! Iterable) return 'not iterable';
      0|    item = item.toList();
       |
       |    // Check the lengths are the same.
      0|    if (_expected.length > item.length) {
      0|      return 'has too few elements (${item.length} < ${_expected.length})';
      0|    } else if (_expected.length < item.length) {
      0|      return 'has too many elements (${item.length} > ${_expected.length})';
       |    }
       |
      0|    var matched = new List<bool>.filled(item.length, false);
       |    var expectedPosition = 0;
      0|    for (var expectedMatcher in _expected) {
       |      var actualPosition = 0;
       |      var gotMatch = false;
      0|      for (var actualElement in item) {
      0|        if (!matched[actualPosition]) {
      0|          if (expectedMatcher.matches(actualElement, {})) {
      0|            matched[actualPosition] = gotMatch = true;
       |            break;
       |          }
       |        }
      0|        ++actualPosition;
       |      }
       |
       |      if (!gotMatch) {
      0|        return new StringDescription()
      0|            .add('has no match for ')
      0|            .addDescriptionOf(expectedMatcher)
      0|            .add(' at index ${expectedPosition}')
      0|            .toString();
       |      }
       |
      0|      ++expectedPosition;
       |    }
       |    return null;
       |  }
       |
      0|  bool matches(item, Map mismatchState) => _test(item) == null;
       |
       |  Description describe(Description description) => description
      0|      .add('matches ')
      0|      .addAll('[', ', ', ']', _expected)
      0|      .add(' unordered');
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) =>
      0|      mismatchDescription.add(_test(item));
       |}
       |
       |/// A pairwise matcher for [Iterable]s.
       |///
       |/// The [comparator] function, taking an expected and an actual argument, and
       |/// returning whether they match, will be applied to each pair in order.
       |/// [description] should be a meaningful name for the comparator.
       |Matcher pairwiseCompare(
       |    Iterable expected, bool comparator(a, b), String description) =>
      0|        new _PairwiseCompare(expected, comparator, description);
       |
       |typedef bool _Comparator(a, b);
       |
       |class _PairwiseCompare extends _IterableMatcher {
       |  final Iterable _expected;
       |  final _Comparator _comparator;
       |  final String _description;
       |
      0|  _PairwiseCompare(this._expected, this._comparator, this._description);
       |
       |  bool matches(item, Map matchState) {
      0|    if (item is! Iterable) return false;
      0|    if (item.length != _expected.length) return false;
      0|    var iterator = item.iterator;
       |    var i = 0;
      0|    for (var e in _expected) {
      0|      iterator.moveNext();
      0|      if (!_comparator(e, iterator.current)) {
      0|        addStateInfo(matchState, {
       |          'index': i,
       |          'expected': e,
      0|          'actual': iterator.current
       |        });
       |        return false;
       |      }
      0|      i++;
       |    }
       |    return true;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add('pairwise $_description ').addDescriptionOf(_expected);
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is! Iterable) {
      0|      return mismatchDescription.add('is not an Iterable');
      0|    } else if (item.length != _expected.length) {
       |      return mismatchDescription
      0|          .add('has length ${item.length} instead of ${_expected.length}');
       |    } else {
       |      return mismatchDescription
      0|          .add('has ')
      0|          .addDescriptionOf(matchState["actual"])
      0|          .add(' which is not $_description ')
      0|          .addDescriptionOf(matchState["expected"])
      0|          .add(' at index ${matchState["index"]}');
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/map_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a matcher which matches maps containing the given [value].
      0|Matcher containsValue(value) => new _ContainsValue(value);
       |
       |class _ContainsValue extends Matcher {
       |  final _value;
       |
      0|  const _ContainsValue(this._value);
       |
      0|  bool matches(item, Map matchState) => item.containsValue(_value);
       |  Description describe(Description description) =>
      0|      description.add('contains value ').addDescriptionOf(_value);
       |}
       |
       |/// Returns a matcher which matches maps containing the key-value pair
       |/// with [key] => [value].
       |Matcher containsPair(key, value) =>
      0|    new _ContainsMapping(key, wrapMatcher(value));
       |
       |class _ContainsMapping extends Matcher {
       |  final _key;
       |  final Matcher _valueMatcher;
       |
      0|  const _ContainsMapping(this._key, Matcher this._valueMatcher);
       |
       |  bool matches(item, Map matchState) =>
      0|      item.containsKey(_key) && _valueMatcher.matches(item[_key], matchState);
       |
       |  Description describe(Description description) {
       |    return description
      0|        .add('contains pair ')
      0|        .addDescriptionOf(_key)
      0|        .add(' => ')
      0|        .addDescriptionOf(_valueMatcher);
       |  }
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (!item.containsKey(_key)) {
       |      return mismatchDescription
      0|          .add(" doesn't contain key ")
      0|          .addDescriptionOf(_key);
       |    } else {
       |      mismatchDescription
      0|          .add(' contains key ')
      0|          .addDescriptionOf(_key)
      0|          .add(' but with value ');
      0|      _valueMatcher.describeMismatch(
      0|          item[_key], mismatchDescription, matchState, verbose);
       |      return mismatchDescription;
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/numeric_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than the given [value].
       |Matcher greaterThan(value) =>
      0|    new _OrderingComparison(value, false, false, true, 'a value greater than');
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than or equal to the given [value].
      0|Matcher greaterThanOrEqualTo(value) => new _OrderingComparison(
       |    value, true, false, true, 'a value greater than or equal to');
       |
       |/// Returns a matcher which matches if the match argument is less
       |/// than the given [value].
       |Matcher lessThan(value) =>
      0|    new _OrderingComparison(value, false, true, false, 'a value less than');
       |
       |/// Returns a matcher which matches if the match argument is less
       |/// than or equal to the given [value].
      0|Matcher lessThanOrEqualTo(value) => new _OrderingComparison(
       |    value, true, true, false, 'a value less than or equal to');
       |
       |/// A matcher which matches if the match argument is zero.
       |const Matcher isZero =
       |    const _OrderingComparison(0, true, false, false, 'a value equal to');
       |
       |/// A matcher which matches if the match argument is non-zero.
       |const Matcher isNonZero =
       |    const _OrderingComparison(0, false, true, true, 'a value not equal to');
       |
       |/// A matcher which matches if the match argument is positive.
       |const Matcher isPositive =
       |    const _OrderingComparison(0, false, false, true, 'a positive value', false);
       |
       |/// A matcher which matches if the match argument is zero or negative.
       |const Matcher isNonPositive = const _OrderingComparison(
       |    0, true, true, false, 'a non-positive value', false);
       |
       |/// A matcher which matches if the match argument is negative.
       |const Matcher isNegative =
       |    const _OrderingComparison(0, false, true, false, 'a negative value', false);
       |
       |/// A matcher which matches if the match argument is zero or positive.
       |const Matcher isNonNegative = const _OrderingComparison(
       |    0, true, false, true, 'a non-negative value', false);
       |
       |bool _isNumeric(value) {
      0|  return value is num;
       |}
       |
       |// TODO(kevmoo) Note that matchers that use _OrderingComparison only use
       |// `==` and `<` operators to evaluate the match. Or change the matcher.
       |class _OrderingComparison extends Matcher {
       |  /// Expected value.
       |  final _value;
       |  /// What to return if actual == expected
       |  final bool _equalValue;
       |  /// What to return if actual < expected
       |  final bool _lessThanValue;
       |  /// What to return if actual > expected
       |  final bool _greaterThanValue;
       |  /// Textual name of the inequality
       |  final String _comparisonDescription;
       |  /// Whether to include the expected value in the description
       |  final bool _valueInDescription;
       |
       |  const _OrderingComparison(this._value, this._equalValue, this._lessThanValue,
       |      this._greaterThanValue, this._comparisonDescription,
       |      [bool valueInDescription = true])
      0|      : this._valueInDescription = valueInDescription;
       |
       |  bool matches(item, Map matchState) {
      0|    if (item == _value) {
      0|      return _equalValue;
      0|    } else if (item < _value) {
      0|      return _lessThanValue;
       |    } else {
      0|      return _greaterThanValue;
       |    }
       |  }
       |
       |  Description describe(Description description) {
      0|    if (_valueInDescription) {
       |      return description
      0|          .add(_comparisonDescription)
      0|          .add(' ')
      0|          .addDescriptionOf(_value);
       |    } else {
      0|      return description.add(_comparisonDescription);
       |    }
       |  }
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    mismatchDescription.add('is not ');
      0|    return describe(mismatchDescription);
       |  }
       |}
       |
       |/// Returns a matcher which matches if the match argument is within [delta]
       |/// of some [value].
       |///
       |/// In other words, this matches if the match argument is greater than
       |/// than or equal [value]-[delta] and less than or equal to [value]+[delta].
      0|Matcher closeTo(num value, num delta) => new _IsCloseTo(value, delta);
       |
       |class _IsCloseTo extends Matcher {
       |  final num _value, _delta;
       |
      0|  const _IsCloseTo(this._value, this._delta);
       |
       |  bool matches(item, Map matchState) {
      0|    if (!_isNumeric(item)) {
       |      return false;
       |    }
      0|    var diff = item - _value;
      0|    if (diff < 0) diff = -diff;
      0|    return (diff <= _delta);
       |  }
       |
       |  Description describe(Description description) => description
      0|      .add('a numeric value within ')
      0|      .addDescriptionOf(_delta)
      0|      .add(' of ')
      0|      .addDescriptionOf(_value);
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is! num) {
      0|      return mismatchDescription.add(' not numeric');
       |    } else {
      0|      var diff = item - _value;
      0|      if (diff < 0) diff = -diff;
      0|      return mismatchDescription.add(' differs by ').addDescriptionOf(diff);
       |    }
       |  }
       |}
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than or equal to [low] and less than or equal to [high].
       |Matcher inInclusiveRange(num low, num high) =>
      0|    new _InRange(low, high, true, true);
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than [low] and less than [high].
       |Matcher inExclusiveRange(num low, num high) =>
      0|    new _InRange(low, high, false, false);
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than [low] and less than or equal to [high].
       |Matcher inOpenClosedRange(num low, num high) =>
      0|    new _InRange(low, high, false, true);
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than or equal to a [low] and less than [high].
       |Matcher inClosedOpenRange(num low, num high) =>
      0|    new _InRange(low, high, true, false);
       |
       |class _InRange extends Matcher {
       |  final num _low, _high;
       |  final bool _lowMatchValue, _highMatchValue;
       |
       |  const _InRange(
      0|      this._low, this._high, this._lowMatchValue, this._highMatchValue);
       |
       |  bool matches(value, Map matchState) {
      0|    if (value is! num) {
       |      return false;
       |    }
      0|    if (value < _low || value > _high) {
       |      return false;
       |    }
      0|    if (value == _low) {
      0|      return _lowMatchValue;
       |    }
      0|    if (value == _high) {
      0|      return _highMatchValue;
       |    }
       |    return true;
       |  }
       |
      0|  Description describe(Description description) => description.add(
       |      "be in range from "
      0|      "$_low (${_lowMatchValue ? 'inclusive' : 'exclusive'}) to "
      0|      "$_high (${_highMatchValue ? 'inclusive' : 'exclusive'})");
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is! num) {
      0|      return mismatchDescription.addDescriptionOf(item).add(' not numeric');
       |    } else {
      0|      return super.describeMismatch(
       |          item, mismatchDescription, matchState, verbose);
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/operator_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// This returns a matcher that inverts [matcher] to its logical negation.
      0|Matcher isNot(matcher) => new _IsNot(wrapMatcher(matcher));
       |
       |class _IsNot extends Matcher {
       |  final Matcher _matcher;
       |
      0|  const _IsNot(this._matcher);
       |
      0|  bool matches(item, Map matchState) => !_matcher.matches(item, matchState);
       |
       |  Description describe(Description description) =>
      0|      description.add('not ').addDescriptionOf(_matcher);
       |}
       |
       |/// This returns a matcher that matches if all of the matchers passed as
       |/// arguments (up to 7) match.
       |///
       |/// Instead of passing the matchers separately they can be passed as a single
       |/// List argument. Any argument that is not a matcher is implicitly wrapped in a
       |/// Matcher to check for equality.
       |Matcher allOf(arg0, [arg1, arg2, arg3, arg4, arg5, arg6]) {
      0|  return new _AllOf(_wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
       |}
       |
       |class _AllOf extends Matcher {
       |  final List<Matcher> _matchers;
       |
      0|  const _AllOf(this._matchers);
       |
       |  bool matches(item, Map matchState) {
      0|    for (var matcher in _matchers) {
      0|      if (!matcher.matches(item, matchState)) {
      0|        addStateInfo(matchState, {'matcher': matcher});
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    var matcher = matchState['matcher'];
      0|    matcher.describeMismatch(
      0|        item, mismatchDescription, matchState['state'], verbose);
       |    return mismatchDescription;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.addAll('(', ' and ', ')', _matchers);
       |}
       |
       |/// Matches if any of the given matchers evaluate to true.
       |///
       |/// The arguments can be a set of matchers as separate parameters
       |/// (up to 7), or a List of matchers.
       |///
       |/// The matchers are evaluated from left to right using short-circuit
       |/// evaluation, so evaluation stops as soon as a matcher returns true.
       |///
       |/// Any argument that is not a matcher is implicitly wrapped in a
       |/// Matcher to check for equality.
       |Matcher anyOf(arg0, [arg1, arg2, arg3, arg4, arg5, arg6]) {
      0|  return new _AnyOf(_wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
       |}
       |
       |class _AnyOf extends Matcher {
       |  final List<Matcher> _matchers;
       |
      0|  const _AnyOf(this._matchers);
       |
       |  bool matches(item, Map matchState) {
      0|    for (var matcher in _matchers) {
      0|      if (matcher.matches(item, matchState)) {
       |        return true;
       |      }
       |    }
       |    return false;
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.addAll('(', ' or ', ')', _matchers);
       |}
       |
       |List<Matcher> _wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
       |  Iterable args;
      0|  if (arg0 is List) {
       |    if (arg1 != null ||
       |        arg2 != null ||
       |        arg3 != null ||
       |        arg4 != null ||
       |        arg5 != null ||
       |        arg6 != null) {
      0|      throw new ArgumentError('If arg0 is a List, all other arguments must be'
       |          ' null.');
       |    }
       |
       |    args = arg0;
       |  } else {
      0|    args = [arg0, arg1, arg2, arg3, arg4, arg5, arg6].where((e) => e != null);
       |  }
       |
      0|  return args.map((e) => wrapMatcher(e)).toList();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/string_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |
       |/// Returns a matcher which matches if the match argument is a string and
       |/// is equal to [value] when compared case-insensitively.
      0|Matcher equalsIgnoringCase(String value) => new _IsEqualIgnoringCase(value);
       |
       |class _IsEqualIgnoringCase extends _StringMatcher {
       |  final String _value;
       |  final String _matchValue;
       |
       |  _IsEqualIgnoringCase(String value)
       |      : _value = value,
      0|        _matchValue = value.toLowerCase();
       |
       |  bool matches(item, Map matchState) =>
      0|      item is String && _matchValue == item.toLowerCase();
       |
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_value).add(' ignoring case');
       |}
       |
       |/// Returns a matcher which matches if the match argument is a string and
       |/// is equal to [value], ignoring whitespace.
       |///
       |/// In this matcher, "ignoring whitespace" means comparing with all runs of
       |/// whitespace collapsed to single space characters and leading and trailing
       |/// whitespace removed.
       |///
       |/// For example, the following will all match successfully:
       |///
       |///     expect("hello   world", equalsIgnoringWhitespace("hello world"));
       |///     expect("  hello world", equalsIgnoringWhitespace("hello world"));
       |///     expect("hello world  ", equalsIgnoringWhitespace("hello world"));
       |///
       |/// The following will not match:
       |///
       |///     expect("helloworld", equalsIgnoringWhitespace("hello world"));
       |///     expect("he llo world", equalsIgnoringWhitespace("hello world"));
       |Matcher equalsIgnoringWhitespace(String value) =>
      0|    new _IsEqualIgnoringWhitespace(value);
       |
       |class _IsEqualIgnoringWhitespace extends _StringMatcher {
       |  final String _value;
       |  final String _matchValue;
       |
       |  _IsEqualIgnoringWhitespace(String value)
       |      : _value = value,
      0|        _matchValue = collapseWhitespace(value);
       |
       |  bool matches(item, Map matchState) =>
      0|      item is String && _matchValue == collapseWhitespace(item);
       |
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_matchValue).add(' ignoring whitespace');
       |
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is String) {
       |      return mismatchDescription
      0|          .add('is ')
      0|          .addDescriptionOf(collapseWhitespace(item))
      0|          .add(' with whitespace compressed');
       |    } else {
      0|      return super.describeMismatch(
       |          item, mismatchDescription, matchState, verbose);
       |    }
       |  }
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// starts with [prefixString].
      0|Matcher startsWith(String prefixString) => new _StringStartsWith(prefixString);
       |
       |class _StringStartsWith extends _StringMatcher {
       |  final String _prefix;
       |
      0|  const _StringStartsWith(this._prefix);
       |
       |  bool matches(item, Map matchState) =>
      0|      item is String && item.startsWith(_prefix);
       |
       |  Description describe(Description description) =>
      0|      description.add('a string starting with ').addDescriptionOf(_prefix);
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// ends with [suffixString].
      0|Matcher endsWith(String suffixString) => new _StringEndsWith(suffixString);
       |
       |class _StringEndsWith extends _StringMatcher {
       |  final String _suffix;
       |
      0|  const _StringEndsWith(this._suffix);
       |
       |  bool matches(item, Map matchState) =>
      0|      item is String && item.endsWith(_suffix);
       |
       |  Description describe(Description description) =>
      0|      description.add('a string ending with ').addDescriptionOf(_suffix);
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// contains a given list of [substrings] in relative order.
       |///
       |/// For example, `stringContainsInOrder(["a", "e", "i", "o", "u"])` will match
       |/// "abcdefghijklmnopqrstuvwxyz".
       |
       |Matcher stringContainsInOrder(List<String> substrings) =>
      0|    new _StringContainsInOrder(substrings);
       |
       |class _StringContainsInOrder extends _StringMatcher {
       |  final List<String> _substrings;
       |
      0|  const _StringContainsInOrder(this._substrings);
       |
       |  bool matches(item, Map matchState) {
      0|    if (!(item is String)) {
       |      return false;
       |    }
       |    var from_index = 0;
      0|    for (var s in _substrings) {
      0|      from_index = item.indexOf(s, from_index);
      0|      if (from_index < 0) return false;
       |    }
       |    return true;
       |  }
       |
      0|  Description describe(Description description) => description.addAll(
      0|      'a string containing ', ', ', ' in order', _substrings);
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// matches the regular expression given by [re].
       |///
       |/// [re] can be a [RegExp] instance or a [String]; in the latter case it will be
       |/// used to create a RegExp instance.
      0|Matcher matches(re) => new _MatchesRegExp(re);
       |
       |class _MatchesRegExp extends _StringMatcher {
       |  RegExp _regexp;
       |
      0|  _MatchesRegExp(re) {
      0|    if (re is String) {
      0|      _regexp = new RegExp(re);
      0|    } else if (re is RegExp) {
      0|      _regexp = re;
       |    } else {
      0|      throw new ArgumentError('matches requires a regexp or string');
       |    }
       |  }
       |
       |  bool matches(item, Map matchState) =>
      0|      item is String ? _regexp.hasMatch(item) : false;
       |
       |  Description describe(Description description) =>
      0|      description.add("match '${_regexp.pattern}'");
       |}
       |
       |// String matchers match against a string. We add this intermediate
       |// class to give better mismatch error messages than the base Matcher class.
       |abstract class _StringMatcher extends Matcher {
      0|  const _StringMatcher();
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (!(item is String)) {
      0|      return mismatchDescription.addDescriptionOf(item).add(' not a string');
       |    } else {
      0|      return super.describeMismatch(
       |          item, mismatchDescription, matchState, verbose);
       |    }
       |  }
       |}
       |
       |/// Utility function to collapse whitespace runs to single spaces
       |/// and strip leading/trailing whitespace.
       |String collapseWhitespace(String string) {
      0|  var result = new StringBuffer();
       |  var skipSpace = true;
      0|  for (var i = 0; i < string.length; i++) {
      0|    var character = string[i];
      0|    if (_isWhitespace(character)) {
       |      if (!skipSpace) {
      0|        result.write(' ');
       |        skipSpace = true;
       |      }
       |    } else {
      0|      result.write(character);
       |      skipSpace = false;
       |    }
       |  }
      0|  return result.toString().trim();
       |}
       |
       |bool _isWhitespace(String ch) =>
      0|    ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/util.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'core_matchers.dart';
       |import 'interfaces.dart';
       |
       |typedef bool _Predicate(value);
       |
       |/// A [Map] between whitespace characters and their escape sequences.
       |const _escapeMap = const {
       |  '\n': r'\n',
       |  '\r': r'\r',
       |  '\f': r'\f',
       |  '\b': r'\b',
       |  '\t': r'\t',
       |  '\v': r'\v',
       |  '\x7F': r'\x7F', // delete
       |};
       |
       |/// A [RegExp] that matches whitespace characters that should be escaped.
       |final _escapeRegExp = new RegExp(
       |    "[\\x00-\\x07\\x0E-\\x1F${_escapeMap.keys.map(_getHexLiteral).join()}]");
       |
       |/// Useful utility for nesting match states.
       |void addStateInfo(Map matchState, Map values) {
      1|  var innerState = new Map.from(matchState);
      1|  matchState.clear();
      1|  matchState['state'] = innerState;
      1|  matchState.addAll(values);
       |}
       |
       |/// Takes an argument and returns an equivalent [Matcher].
       |///
       |/// If the argument is already a matcher this does nothing,
       |/// else if the argument is a function, it generates a predicate
       |/// function matcher, else it generates an equals matcher.
       |Matcher wrapMatcher(x) {
      1|  if (x is Matcher) {
       |    return x;
      0|  } else if (x is _Predicate) {
      0|    return predicate(x);
       |  } else {
      0|    return equals(x);
       |  }
       |}
       |
       |/// Returns [str] with all whitespace characters represented as their escape
       |/// sequences.
       |///
       |/// Backslash characters are escaped as `\\`
       |String escape(String str) {
      1|  str = str.replaceAll('\\', r'\\');
      2|  return str.replaceAllMapped(_escapeRegExp, (match) {
      0|    var mapped = _escapeMap[match[0]];
       |    if (mapped != null) return mapped;
      0|    return _getHexLiteral(match[0]);
       |  });
       |}
       |
       |/// Given single-character string, return the hex-escaped equivalent.
       |String _getHexLiteral(String input) {
      2|  int rune = input.runes.single;
      4|  return r'\x' + rune.toRadixString(16).toUpperCase().padLeft(2, '0');
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.0+2/lib/src/pretty_print.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'description.dart';
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a pretty-printed representation of [object].
       |///
       |/// If [maxLineLength] is passed, this will attempt to ensure that each line is
       |/// no longer than [maxLineLength] characters long. This isn't guaranteed, since
       |/// individual objects may have string representations that are too long, but
       |/// most lines will be less than [maxLineLength] long.
       |///
       |/// If [maxItems] is passed, [Iterable]s and [Map]s will only print their first
       |/// [maxItems] members or key/value pairs, respectively.
       |String prettyPrint(object, {int maxLineLength, int maxItems}) {
       |  String _prettyPrint(object, int indent, Set seen, bool top) {
       |    // If the object is a matcher, use its description.
      1|    if (object is Matcher) {
      0|      var description = new StringDescription();
      0|      object.describe(description);
      0|      return "<$description>";
       |    }
       |
       |    // Avoid looping infinitely on recursively-nested data structures.
      1|    if (seen.contains(object)) return "(recursive)";
      3|    seen = seen.union(new Set.from([object]));
      0|    String pp(child) => _prettyPrint(child, indent + 2, seen, false);
       |
      1|    if (object is Iterable) {
       |      // Print the type name for non-List iterables.
      0|      var type = object is List ? "" : _typeName(object) + ":";
       |
       |      // Truncate the list of strings if it's longer than [maxItems].
      0|      var strings = object.map(pp).toList();
      0|      if (maxItems != null && strings.length > maxItems) {
      0|        strings.replaceRange(maxItems - 1, strings.length, ['...']);
       |      }
       |
       |      // If the printed string is short and doesn't contain a newline, print it
       |      // as a single line.
      0|      var singleLine = "$type[${strings.join(', ')}]";
       |      if ((maxLineLength == null ||
      0|              singleLine.length + indent <= maxLineLength) &&
      0|          !singleLine.contains("\n")) {
       |        return singleLine;
       |      }
       |
       |      // Otherwise, print each member on its own line.
      0|      return "$type[\n" + strings.map((string) {
      0|        return _indent(indent + 2) + string;
      0|      }).join(",\n") + "\n" + _indent(indent) + "]";
      1|    } else if (object is Map) {
       |      // Convert the contents of the map to string representations.
      0|      var strings = object.keys.map((key) {
      0|        return '${pp(key)}: ${pp(object[key])}';
      0|      }).toList();
       |
       |      // Truncate the list of strings if it's longer than [maxItems].
      0|      if (maxItems != null && strings.length > maxItems) {
      0|        strings.replaceRange(maxItems - 1, strings.length, ['...']);
       |      }
       |
       |      // If the printed string is short and doesn't contain a newline, print it
       |      // as a single line.
      0|      var singleLine = "{${strings.join(", ")}}";
       |      if ((maxLineLength == null ||
      0|              singleLine.length + indent <= maxLineLength) &&
      0|          !singleLine.contains("\n")) {
       |        return singleLine;
       |      }
       |
       |      // Otherwise, print each key/value pair on its own line.
      0|      return "{\n" + strings.map((string) {
      0|        return _indent(indent + 2) + string;
      0|      }).join(",\n") + "\n" + _indent(indent) + "}";
      1|    } else if (object is String) {
       |      // Escape strings and print each line on its own line.
      1|      var lines = object.split("\n");
      1|      return "'" +
      6|          lines.map(_escapeString).join("\\n'\n${_indent(indent + 2)}'") +
       |          "'";
       |    } else {
      4|      var value = object.toString().replaceAll("\n", _indent(indent) + "\n");
      1|      var defaultToString = value.startsWith("Instance of ");
       |
       |      // If this is the top-level call to [prettyPrint], wrap the value on angle
       |      // brackets to set it apart visually.
      1|      if (top) value = "<$value>";
       |
       |      // Print the type of objects with custom [toString] methods. Primitive
       |      // objects and objects that don't implement a custom [toString] don't need
       |      // to have their types printed.
      1|      if (object is num ||
      1|          object is bool ||
      1|          object is Function ||
       |          object == null ||
       |          defaultToString) {
       |        return value;
       |      } else {
      2|        return "${_typeName(object)}:$value";
       |      }
       |    }
       |  }
       |
      2|  return _prettyPrint(object, 0, new Set(), true);
       |}
       |
      2|String _indent(int length) => new List.filled(length, ' ').join('');
       |
       |/// Returns the name of the type of [x], or "Unknown" if the type name can't be
       |/// determined.
       |String _typeName(x) {
       |  // dart2js blows up on some objects (e.g. window.navigator).
       |  // So we play safe here.
       |  try {
       |    if (x == null) return "null";
      2|    var type = x.runtimeType.toString();
       |    // TODO(nweiz): if the object's type is private, find a public superclass to
       |    // display once there's a portable API to do that.
      1|    return type.startsWith("_") ? "?" : type;
       |  } catch (e) {
       |    return "?";
       |  }
       |}
       |
       |/// Returns [source] with any control characters replaced by their escape
       |/// sequences.
       |///
       |/// This doesn't add quotes to the string, but it does escape single quote
       |/// characters so that single quotes can be applied externally.
      2|String _escapeString(String source) => escape(source).replaceAll("'", r"\'");
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/path.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A comprehensive, cross-platform path manipulation library.
       |///
       |/// ## Installing ##
       |///
       |/// Use [pub][] to install this package. Add the following to your
       |/// `pubspec.yaml` file.
       |///
       |///     dependencies:
       |///       path: any
       |///
       |/// Then run `pub install`.
       |///
       |/// For more information, see the [path package on pub.dartlang.org][pkg].
       |///
       |/// [pub]: http://pub.dartlang.org
       |/// [pkg]: http://pub.dartlang.org/packages/path
       |///
       |/// ## Usage ##
       |///
       |/// The path library was designed to be imported with a prefix, though you don't
       |/// have to if you don't want to:
       |///
       |///     import 'package:path/path.dart' as path;
       |///
       |/// The most common way to use the library is through the top-level functions.
       |/// These manipulate path strings based on your current working directory and
       |/// the path style (POSIX, Windows, or URLs) of the host platform. For example:
       |///
       |///     path.join("directory", "file.txt");
       |///
       |/// This calls the top-level [join] function to join "directory" and "file.txt"
       |/// using the current platform's directory separator.
       |///
       |/// If you want to work with paths for a specific platform regardless of the
       |/// underlying platform that the program is running on, you can create a
       |/// [Context] and give it an explicit [Style]:
       |///
       |///     var context = new path.Context(style: Style.windows);
       |///     context.join("directory", "file.txt");
       |///
       |/// This will join "directory" and "file.txt" using the Windows path separator,
       |/// even when the program is run on a POSIX machine.
       |import 'src/context.dart';
       |import 'src/style.dart';
       |
       |export 'src/context.dart' hide createInternal;
       |export 'src/path_exception.dart';
       |export 'src/style.dart';
       |
       |/// A default context for manipulating POSIX paths.
       |final Context posix = new Context(style: Style.posix);
       |
       |/// A default context for manipulating Windows paths.
       |final Context windows = new Context(style: Style.windows);
       |
       |/// A default context for manipulating URLs.
       |///
       |/// URL path equality is undefined for paths that differ only in their
       |/// percent-encoding or only in the case of their host segment.
       |final Context url = new Context(style: Style.url);
       |
       |/// The system path context.
       |///
       |/// This differs from a context created with [new Context] in that its
       |/// [Context.current] is always the current working directory, rather than being
       |/// set once when the context is created.
       |final Context context = createInternal();
       |
       |/// Returns the [Style] of the current context.
       |///
       |/// This is the style that all top-level path functions will use.
      2|Style get style => context.style;
       |
       |/// Gets the path to the current working directory.
       |///
       |/// In the browser, this means the current URL, without the last file segment.
       |String get current {
      1|  var uri = Uri.base;
       |
       |  // Converting the base URI to a file path is pretty slow, and the base URI
       |  // rarely changes in practice, so we cache the result here.
      1|  if (uri == _currentUriBase) return _current;
       |  _currentUriBase = uri;
       |
      3|  if (Style.platform == Style.url) {
      0|    _current = uri.resolve('.').toString();
       |    return _current;
       |  } else {
      1|    var path = uri.toFilePath();
       |    // Remove trailing '/' or '\'.
      2|    var lastIndex = path.length - 1;
       |    assert(path[lastIndex] == '/' || path[lastIndex] == '\\');
      1|    _current = path.substring(0, lastIndex);
       |    return _current;
       |  }
       |}
       |
       |/// The last value returned by [Uri.base].
       |///
       |/// This is used to cache the current working directory.
       |Uri _currentUriBase;
       |
       |/// The last known value of the current working directory.
       |///
       |/// This is cached because [current] is called frequently but rarely actually
       |/// changes.
       |String _current;
       |
       |/// Gets the path separator for the current platform. This is `\` on Windows
       |/// and `/` on other platforms (including the browser).
      0|String get separator => context.separator;
       |
       |/// Creates a new path by appending the given path parts to [current].
       |/// Equivalent to [join()] with [current] as the first argument. Example:
       |///
       |///     path.absolute('path', 'to/foo'); // -> '/your/current/dir/path/to/foo'
       |String absolute(String part1, [String part2, String part3, String part4,
       |    String part5, String part6, String part7]) =>
      0|        context.absolute(part1, part2, part3, part4, part5, part6, part7);
       |
       |/// Gets the part of [path] after the last separator.
       |///
       |///     path.basename('path/to/foo.dart'); // -> 'foo.dart'
       |///     path.basename('path/to');          // -> 'to'
       |///
       |/// Trailing separators are ignored.
       |///
       |///     path.basename('path/to/'); // -> 'to'
      0|String basename(String path) => context.basename(path);
       |
       |/// Gets the part of [path] after the last separator, and without any trailing
       |/// file extension.
       |///
       |///     path.basenameWithoutExtension('path/to/foo.dart'); // -> 'foo'
       |///
       |/// Trailing separators are ignored.
       |///
       |///     path.basenameWithoutExtension('path/to/foo.dart/'); // -> 'foo'
       |String basenameWithoutExtension(String path) =>
      0|    context.basenameWithoutExtension(path);
       |
       |/// Gets the part of [path] before the last separator.
       |///
       |///     path.dirname('path/to/foo.dart'); // -> 'path/to'
       |///     path.dirname('path/to');          // -> 'path'
       |///
       |/// Trailing separators are ignored.
       |///
       |///     path.dirname('path/to/'); // -> 'path'
       |///
       |/// If an absolute path contains no directories, only a root, then the root
       |/// is returned.
       |///
       |///     path.dirname('/');  // -> '/' (posix)
       |///     path.dirname('c:\');  // -> 'c:\' (windows)
       |///
       |/// If a relative path has no directories, then '.' is returned.
       |///
       |///     path.dirname('foo');  // -> '.'
       |///     path.dirname('');  // -> '.'
      0|String dirname(String path) => context.dirname(path);
       |
       |/// Gets the file extension of [path]: the portion of [basename] from the last
       |/// `.` to the end (including the `.` itself).
       |///
       |///     path.extension('path/to/foo.dart');    // -> '.dart'
       |///     path.extension('path/to/foo');         // -> ''
       |///     path.extension('path.to/foo');         // -> ''
       |///     path.extension('path/to/foo.dart.js'); // -> '.js'
       |///
       |/// If the file name starts with a `.`, then that is not considered the
       |/// extension:
       |///
       |///     path.extension('~/.bashrc');    // -> ''
       |///     path.extension('~/.notes.txt'); // -> '.txt'
      0|String extension(String path) => context.extension(path);
       |
       |// TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
       |/// Returns the root of [path], if it's absolute, or the empty string if it's
       |/// relative.
       |///
       |///     // Unix
       |///     path.rootPrefix('path/to/foo'); // -> ''
       |///     path.rootPrefix('/path/to/foo'); // -> '/'
       |///
       |///     // Windows
       |///     path.rootPrefix(r'path\to\foo'); // -> ''
       |///     path.rootPrefix(r'C:\path\to\foo'); // -> r'C:\'
       |///
       |///     // URL
       |///     path.rootPrefix('path/to/foo'); // -> ''
       |///     path.rootPrefix('http://dartlang.org/path/to/foo');
       |///       // -> 'http://dartlang.org'
      0|String rootPrefix(String path) => context.rootPrefix(path);
       |
       |/// Returns `true` if [path] is an absolute path and `false` if it is a
       |/// relative path.
       |///
       |/// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |/// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |/// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
       |/// optional hostname (e.g. `http://dartlang.org`, `file://`) or with a `/`.
       |///
       |/// URLs that start with `/` are known as "root-relative", since they're
       |/// relative to the root of the current URL. Since root-relative paths are still
       |/// absolute in every other sense, [isAbsolute] will return true for them. They
       |/// can be detected using [isRootRelative].
      0|bool isAbsolute(String path) => context.isAbsolute(path);
       |
       |/// Returns `true` if [path] is a relative path and `false` if it is absolute.
       |/// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |/// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |/// `:/` or `:\`.
      0|bool isRelative(String path) => context.isRelative(path);
       |
       |/// Returns `true` if [path] is a root-relative path and `false` if it's not.
       |///
       |/// URLs that start with `/` are known as "root-relative", since they're
       |/// relative to the root of the current URL. Since root-relative paths are still
       |/// absolute in every other sense, [isAbsolute] will return true for them. They
       |/// can be detected using [isRootRelative].
       |///
       |/// No POSIX and Windows paths are root-relative.
      0|bool isRootRelative(String path) => context.isRootRelative(path);
       |
       |/// Joins the given path parts into a single path using the current platform's
       |/// [separator]. Example:
       |///
       |///     path.join('path', 'to', 'foo'); // -> 'path/to/foo'
       |///
       |/// If any part ends in a path separator, then a redundant separator will not
       |/// be added:
       |///
       |///     path.join('path/', 'to', 'foo'); // -> 'path/to/foo
       |///
       |/// If a part is an absolute path, then anything before that will be ignored:
       |///
       |///     path.join('path', '/to', 'foo'); // -> '/to/foo'
       |String join(String part1, [String part2, String part3, String part4,
       |    String part5, String part6, String part7, String part8]) =>
      0|        context.join(part1, part2, part3, part4, part5, part6, part7, part8);
       |
       |/// Joins the given path parts into a single path using the current platform's
       |/// [separator]. Example:
       |///
       |///     path.joinAll(['path', 'to', 'foo']); // -> 'path/to/foo'
       |///
       |/// If any part ends in a path separator, then a redundant separator will not
       |/// be added:
       |///
       |///     path.joinAll(['path/', 'to', 'foo']); // -> 'path/to/foo
       |///
       |/// If a part is an absolute path, then anything before that will be ignored:
       |///
       |///     path.joinAll(['path', '/to', 'foo']); // -> '/to/foo'
       |///
       |/// For a fixed number of parts, [join] is usually terser.
      0|String joinAll(Iterable<String> parts) => context.joinAll(parts);
       |
       |// TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
       |/// Splits [path] into its components using the current platform's [separator].
       |///
       |///     path.split('path/to/foo'); // -> ['path', 'to', 'foo']
       |///
       |/// The path will *not* be normalized before splitting.
       |///
       |///     path.split('path/../foo'); // -> ['path', '..', 'foo']
       |///
       |/// If [path] is absolute, the root directory will be the first element in the
       |/// array. Example:
       |///
       |///     // Unix
       |///     path.split('/path/to/foo'); // -> ['/', 'path', 'to', 'foo']
       |///
       |///     // Windows
       |///     path.split(r'C:\path\to\foo'); // -> [r'C:\', 'path', 'to', 'foo']
       |///
       |///     // Browser
       |///     path.split('http://dartlang.org/path/to/foo');
       |///       // -> ['http://dartlang.org', 'path', 'to', 'foo']
      0|List<String> split(String path) => context.split(path);
       |
       |/// Canonicalizes [path].
       |///
       |/// This is guaranteed to return the same path for two different input paths
       |/// if and only if both input paths point to the same location. Unlike
       |/// [normalize], it returns absolute paths when possible and canonicalizes
       |/// ASCII case on Windows.
       |///
       |/// Note that this does not resolve symlinks.
       |///
       |/// If you want a map that uses path keys, it's probably more efficient to
       |/// pass [equals] and [hash] to [new HashMap] than it is to canonicalize every
       |/// key.
      0|String canonicalize(String path) => context.canonicalize(path);
       |
       |/// Normalizes [path], simplifying it by handling `..`, and `.`, and
       |/// removing redundant path separators whenever possible.
       |///
       |/// Note that this is *not* guaranteed to return the same result for two
       |/// equivalent input paths. For that, see [canonicalize]. Or, if you're using
       |/// paths as map keys, pass [equals] and [hash] to [new HashMap].
       |///
       |///     path.normalize('path/./to/..//file.text'); // -> 'path/file.txt'
      0|String normalize(String path) => context.normalize(path);
       |
       |/// Attempts to convert [path] to an equivalent relative path from the current
       |/// directory.
       |///
       |///     // Given current directory is /root/path:
       |///     path.relative('/root/path/a/b.dart'); // -> 'a/b.dart'
       |///     path.relative('/root/other.dart'); // -> '../other.dart'
       |///
       |/// If the [from] argument is passed, [path] is made relative to that instead.
       |///
       |///     path.relative('/root/path/a/b.dart',
       |///         from: '/root/path'); // -> 'a/b.dart'
       |///     path.relative('/root/other.dart',
       |///         from: '/root/path'); // -> '../other.dart'
       |///
       |/// If [path] and/or [from] are relative paths, they are assumed to be relative
       |/// to the current directory.
       |///
       |/// Since there is no relative path from one drive letter to another on Windows,
       |/// or from one hostname to another for URLs, this will return an absolute path
       |/// in those cases.
       |///
       |///     // Windows
       |///     path.relative(r'D:\other', from: r'C:\home'); // -> 'D:\other'
       |///
       |///     // URL
       |///     path.relative('http://dartlang.org', from: 'http://pub.dartlang.org');
       |///       // -> 'http://dartlang.org'
       |String relative(String path, {String from}) =>
      0|    context.relative(path, from: from);
       |
       |/// Returns `true` if [child] is a path beneath `parent`, and `false` otherwise.
       |///
       |///     path.isWithin('/root/path', '/root/path/a'); // -> true
       |///     path.isWithin('/root/path', '/root/other'); // -> false
       |///     path.isWithin('/root/path', '/root/path') // -> false
      0|bool isWithin(String parent, String child) => context.isWithin(parent, child);
       |
       |/// Returns `true` if [path1] points to the same location as [path2], and
       |/// `false` otherwise.
       |///
       |/// The [hash] function returns a hash code that matches these equality
       |/// semantics.
      0|bool equals(String path1, String path2) => context.equals(path1, path2);
       |
       |/// Returns a hash code for [path] such that, if [equals] returns `true` for two
       |/// paths, their hash codes are the same.
       |///
       |/// Note that the same path may have different hash codes on different platforms
       |/// or with different [current] directories.
      0|int hash(String path) => context.hash(path);
       |
       |/// Removes a trailing extension from the last part of [path].
       |///
       |///     withoutExtension('path/to/foo.dart'); // -> 'path/to/foo'
      0|String withoutExtension(String path) => context.withoutExtension(path);
       |
       |/// Returns the path represented by [uri], which may be a [String] or a [Uri].
       |///
       |/// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
       |/// style, this will just convert [uri] to a string.
       |///
       |///     // POSIX
       |///     context.fromUri('file:///path/to/foo')
       |///       // -> '/path/to/foo'
       |///
       |///     // Windows
       |///     context.fromUri('file:///C:/path/to/foo')
       |///       // -> r'C:\path\to\foo'
       |///
       |///     // URL
       |///     context.fromUri('http://dartlang.org/path/to/foo')
       |///       // -> 'http://dartlang.org/path/to/foo'
       |///
       |/// If [uri] is relative, a relative path will be returned.
       |///
       |///     path.fromUri('path/to/foo'); // -> 'path/to/foo'
      0|String fromUri(uri) => context.fromUri(uri);
       |
       |/// Returns the URI that represents [path].
       |///
       |/// For POSIX and Windows styles, this will return a `file:` URI. For the URL
       |/// style, this will just convert [path] to a [Uri].
       |///
       |///     // POSIX
       |///     path.toUri('/path/to/foo')
       |///       // -> Uri.parse('file:///path/to/foo')
       |///
       |///     // Windows
       |///     path.toUri(r'C:\path\to\foo')
       |///       // -> Uri.parse('file:///C:/path/to/foo')
       |///
       |///     // URL
       |///     path.toUri('http://dartlang.org/path/to/foo')
       |///       // -> Uri.parse('http://dartlang.org/path/to/foo')
       |///
       |/// If [path] is relative, a relative URI will be returned.
       |///
       |///     path.toUri('path/to/foo')
       |///       // -> Uri.parse('path/to/foo')
      0|Uri toUri(String path) => context.toUri(path);
       |
       |/// Returns a terse, human-readable representation of [uri].
       |///
       |/// [uri] can be a [String] or a [Uri]. If it can be made relative to the
       |/// current working directory, that's done. Otherwise, it's returned as-is. This
       |/// gracefully handles non-`file:` URIs for [Style.posix] and [Style.windows].
       |///
       |/// The returned value is meant for human consumption, and may be either URI-
       |/// or path-formatted.
       |///
       |///     // POSIX at "/root/path"
       |///     path.prettyUri('file:///root/path/a/b.dart'); // -> 'a/b.dart'
       |///     path.prettyUri('http://dartlang.org/'); // -> 'http://dartlang.org'
       |///
       |///     // Windows at "C:\root\path"
       |///     path.prettyUri('file:///C:/root/path/a/b.dart'); // -> r'a\b.dart'
       |///     path.prettyUri('http://dartlang.org/'); // -> 'http://dartlang.org'
       |///
       |///     // URL at "http://dartlang.org/root/path"
       |///     path.prettyUri('http://dartlang.org/root/path/a/b.dart');
       |///         // -> r'a/b.dart'
       |///     path.prettyUri('file:///root/path'); // -> 'file:///root/path'
      2|String prettyUri(uri) => context.prettyUri(uri);
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/declarer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../frontend/timeout.dart';
       |import '../utils.dart';
       |import 'group.dart';
       |import 'group_entry.dart';
       |import 'invoker.dart';
       |import 'metadata.dart';
       |import 'test.dart';
       |
       |/// A class that manages the state of tests as they're declared.
       |///
       |/// A nested tree of Declarers tracks the current group, set-up, and tear-down
       |/// functions. Each Declarer in the tree corresponds to a group. This tree is
       |/// tracked by a zone-scoped "current" Declarer; the current declarer can be set
       |/// for a block using [Declarer.declare], and it can be accessed using
       |/// [Declarer.current].
       |class Declarer {
       |  /// The parent declarer, or `null` if this corresponds to the root group.
       |  final Declarer _parent;
       |
       |  /// The name of the current test group, including the name of any parent
       |  /// groups.
       |  ///
       |  /// This is `null` if this is the root group.
       |  final String _name;
       |
       |  /// The metadata for this group, including the metadata of any parent groups
       |  /// and of the test suite.
       |  final Metadata _metadata;
       |
       |  /// The stack trace for this group.
       |  final Trace _trace;
       |
       |  /// Whether to collect stack traces for [GroupEntry]s.
       |  final bool _collectTraces;
       |
       |  /// The set-up functions to run for each test in this group.
       |  final _setUps = new List<AsyncFunction>();
       |
       |  /// The tear-down functions to run for each test in this group.
       |  final _tearDowns = new List<AsyncFunction>();
       |
       |  /// The set-up functions to run once for this group.
       |  final _setUpAlls = new List<AsyncFunction>();
       |
       |  /// The trace for the first call to [setUpAll].
       |  ///
       |  /// All [setUpAll]s are run in a single logical test, so they can only have
       |  /// one trace. The first trace is most often correct, since the first
       |  /// [setUpAll] is always run and the rest are only run if that one succeeds.
       |  Trace _setUpAllTrace;
       |
       |  /// The tear-down functions to run once for this group.
       |  final _tearDownAlls = new List<AsyncFunction>();
       |
       |  /// The trace for the first call to [tearDownAll].
       |  ///
       |  /// All [tearDownAll]s are run in a single logical test, so they can only have
       |  /// one trace. The first trace matches [_setUpAllTrace].
       |  Trace _tearDownAllTrace;
       |
       |  /// The children of this group, either tests or sub-groups.
       |  final _entries = new List<GroupEntry>();
       |
       |  /// Whether [build] has been called for this declarer.
       |  bool _built = false;
       |
       |  /// The current zone-scoped declarer.
      2|  static Declarer get current => Zone.current[#test.declarer];
       |
       |  /// Creates a new declarer for the root group.
       |  ///
       |  /// This is the implicit group that exists outside of any calls to `group()`.
       |  /// If [metadata] is passed, it's used as the metadata for the implicit root
       |  /// group.
       |  ///
       |  /// If [collectTraces] is `true`, this will set [GroupEntry.trace] for all
       |  /// entries built by the declarer. Note that this can be noticeably slow when
       |  /// thousands of tests are being declared (see #457).
       |  Declarer({Metadata metadata, bool collectTraces: false})
      2|      : this._(null, null, metadata ?? new Metadata(), collectTraces, null);
       |
       |  Declarer._(this._parent, this._name, this._metadata, this._collectTraces,
      1|      this._trace);
       |
       |  /// Runs [body] with this declarer as [Declarer.current].
       |  ///
       |  /// Returns the return value of [body].
      2|  declare(body()) => runZoned(body, zoneValues: {#test.declarer: this});
       |
       |  /// Defines a test case with the given name and body.
       |  void test(String name, body(),
       |      {String testOn,
       |      Timeout timeout,
       |      skip,
       |      Map<String, dynamic> onPlatform,
       |      tags}) {
      1|    _checkNotBuilt("test");
       |
      3|    var metadata = _metadata.merge(new Metadata.parse(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        onPlatform: onPlatform,
       |        tags: tags));
       |
      4|    _entries.add(new LocalTest(_prefix(name), metadata, () async {
      1|      var parents = <Declarer>[];
      1|      for (var declarer = this; declarer != null; declarer = declarer._parent) {
      1|        parents.add(declarer);
       |      }
       |
       |      // Register all tear-down functions in all declarers. Iterate through
       |      // parents outside-in so that the Invoker gets the functions in the order
       |      // they were declared in source.
      3|      for (var declarer in parents.reversed) {
      2|        for (var tearDown in declarer._tearDowns) {
      0|          Invoker.current.addTearDown(tearDown);
       |        }
       |      }
       |
      3|      await Invoker.current.waitForOutstandingCallbacks(() async {
      2|        await _runSetUps();
      2|        await body();
      1|      });
      2|    }, trace: _collectTraces ? new Trace.current(2) : null));
       |  }
       |
       |  /// Creates a group of tests.
       |  void group(String name, void body(),
       |      {String testOn,
       |      Timeout timeout,
       |      skip,
       |      Map<String, dynamic> onPlatform,
       |      tags}) {
      1|    _checkNotBuilt("group");
       |
      3|    var metadata = _metadata.merge(new Metadata.parse(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        onPlatform: onPlatform,
       |        tags: tags));
      1|    var trace = _collectTraces ? new Trace.current(2) : null;
       |
       |    var declarer =
      3|        new Declarer._(this, _prefix(name), metadata, _collectTraces, trace);
      1|    declarer.declare(() {
       |      // Cast to dynamic to avoid the analyzer complaining about us using the
       |      // result of a void method.
      1|      var result = (body as dynamic)();
      1|      if (result is! Future) return;
      0|      throw new ArgumentError("Groups may not be async.");
       |    });
      3|    _entries.add(declarer.build());
       |  }
       |
       |  /// Returns [name] prefixed with this declarer's group name.
      3|  String _prefix(String name) => _name == null ? name : "$_name $name";
       |
       |  /// Registers a function to be run before each test in this group.
       |  void setUp(callback()) {
      0|    _checkNotBuilt("setUp");
      0|    _setUps.add(callback);
       |  }
       |
       |  /// Registers a function to be run after each test in this group.
       |  void tearDown(callback()) {
      0|    _checkNotBuilt("tearDown");
      0|    _tearDowns.add(callback);
       |  }
       |
       |  /// Registers a function to be run once before all tests.
       |  void setUpAll(callback()) {
      0|    _checkNotBuilt("setUpAll");
      0|    if (_collectTraces) _setUpAllTrace ??= new Trace.current(2);
      0|    _setUpAlls.add(callback);
       |  }
       |
       |  /// Registers a function to be run once after all tests.
       |  void tearDownAll(callback()) {
      0|    _checkNotBuilt("tearDownAll");
      0|    if (_collectTraces) _tearDownAllTrace ??= new Trace.current(2);
      0|    _tearDownAlls.add(callback);
       |  }
       |
       |  /// Finalizes and returns the group being declared.
       |  Group build() {
      1|    _checkNotBuilt("build");
       |
      1|    _built = true;
      4|    return new Group(_name, _entries.toList(),
      1|        metadata: _metadata,
      1|        trace: _trace,
      1|        setUpAll: _setUpAll,
      1|        tearDownAll: _tearDownAll);
       |  }
       |
       |  /// Throws a [StateError] if [build] has been called.
       |  ///
       |  /// [name] should be the name of the method being called.
       |  void _checkNotBuilt(String name) {
      1|    if (!_built) return;
      0|    throw new StateError("Can't call $name() once tests have begun running.");
       |  }
       |
       |  /// Run the set-up functions for this and any parent groups.
       |  ///
       |  /// If no set-up functions are declared, this returns a [Future] that
       |  /// completes immediately.
       |  Future _runSetUps() async {
      4|    if (_parent != null) await _parent._runSetUps();
      3|    await Future.forEach(_setUps, (setUp) => setUp());
      1|  }
       |
       |  /// Returns a [Test] that runs the callbacks in [_setUpAll].
       |  Test get _setUpAll {
      2|    if (_setUpAlls.isEmpty) return null;
       |
      0|    return new LocalTest(_prefix("(setUpAll)"), _metadata, () {
      0|      return Future.forEach(_setUpAlls, (setUp) => setUp());
      0|    }, trace: _setUpAllTrace);
       |  }
       |
       |  /// Returns a [Test] that runs the callbacks in [_tearDownAll].
       |  Test get _tearDownAll {
      2|    if (_tearDownAlls.isEmpty) return null;
       |
      0|    return new LocalTest(_prefix("(tearDownAll)"), _metadata, () {
      0|      return Invoker.current.unclosable(() {
      0|        return Future.forEach(_tearDownAlls.reversed, errorsDontStopTest);
       |      });
      0|    }, trace: _tearDownAllTrace);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/invoker.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../frontend/expect.dart';
       |import '../runner/load_suite.dart';
       |import '../utils.dart';
       |import 'closed_exception.dart';
       |import 'group.dart';
       |import 'live_test.dart';
       |import 'live_test_controller.dart';
       |import 'message.dart';
       |import 'metadata.dart';
       |import 'operating_system.dart';
       |import 'outstanding_callback_counter.dart';
       |import 'state.dart';
       |import 'suite.dart';
       |import 'test.dart';
       |import 'test_platform.dart';
       |
       |/// A test in this isolate.
       |class LocalTest extends Test {
       |  final String name;
       |  final Metadata metadata;
       |  final Trace trace;
       |
       |  /// The test body.
       |  final AsyncFunction _body;
       |
      1|  LocalTest(this.name, this.metadata, body(), {this.trace}) : _body = body;
       |
       |  /// Loads a single runnable instance of this test.
       |  LiveTest load(Suite suite, {Iterable<Group> groups}) {
      1|    var invoker = new Invoker._(suite, this, groups: groups);
      1|    return invoker.liveTest;
       |  }
       |
       |  Test forPlatform(TestPlatform platform, {OperatingSystem os}) {
      3|    if (!metadata.testOn.evaluate(platform, os: os)) return null;
      5|    return new LocalTest(name, metadata.forPlatform(platform, os: os), _body,
      1|        trace: trace);
       |  }
       |}
       |
       |/// The class responsible for managing the lifecycle of a single local test.
       |///
       |/// The current invoker is accessible within the zone scope of the running test
       |/// using [Invoker.current]. It's used to track asynchronous callbacks and
       |/// report asynchronous errors.
       |class Invoker {
       |  /// The live test being driven by the invoker.
       |  ///
       |  /// This provides a view into the state of the test being executed.
      2|  LiveTest get liveTest => _controller.liveTest;
       |  LiveTestController _controller;
       |
       |  /// Whether the test can be closed in the current zone.
      3|  bool get _closable => Zone.current[_closableKey];
       |
       |  /// An opaque object used as a key in the zone value map to identify
       |  /// [_closable].
       |  ///
       |  /// This is an instance variable to ensure that multiple invokers don't step
       |  /// on one anothers' toes.
       |  final _closableKey = new Object();
       |
       |  /// Whether the test has been closed.
       |  ///
       |  /// Once the test is closed, [expect] and [expectAsync] will throw
       |  /// [ClosedException]s whenever accessed to help the test stop executing as
       |  /// soon as possible.
      3|  bool get closed => _closable && _onCloseCompleter.isCompleted;
       |
       |  /// A future that completes once the test has been closed.
      0|  Future get onClose => _closable
      0|      ? _onCloseCompleter.future
       |      // If we're in an unclosable block, return a future that will never
       |      // complete.
      0|      : new Completer().future;
       |  final _onCloseCompleter = new Completer();
       |
       |  /// The test being run.
      3|  LocalTest get _test => liveTest.test as LocalTest;
       |
       |  /// The outstanding callback counter for the current zone.
       |  OutstandingCallbackCounter get _outstandingCallbacks {
      3|    var counter = Zone.current[_counterKey];
       |    if (counter != null) return counter;
      0|    throw new StateError("Can't add or remove outstanding callbacks outside "
       |        "of a test body.");
       |  }
       |
       |  /// All the zones created by [waitForOutstandingCallbacks], in the order they
       |  /// were created.
       |  ///
       |  /// This is used to throw timeout errors in the most recent zone.
       |  final _outstandingCallbackZones = <Zone>[];
       |
       |  /// An opaque object used as a key in the zone value map to identify
       |  /// [_outstandingCallbacks].
       |  ///
       |  /// This is an instance variable to ensure that multiple invokers don't step
       |  /// on one anothers' toes.
       |  final _counterKey = new Object();
       |
       |  /// The current invoker, or `null` if none is defined.
       |  ///
       |  /// An invoker is only set within the zone scope of a running test.
       |  static Invoker get current {
       |    // TODO(nweiz): Use a private symbol when dart2js supports it (issue 17526).
      2|    return Zone.current[#test.invoker];
       |  }
       |
       |  /// The zone that the top level of [_test.body] is running in.
       |  ///
       |  /// Tracking this ensures that [_timeoutTimer] isn't created in a
       |  /// timer-mocking zone created by the test.
       |  Zone _invokerZone;
       |
       |  /// The timer for tracking timeouts.
       |  ///
       |  /// This will be `null` until the test starts running.
       |  Timer _timeoutTimer;
       |
       |  /// The tear-down functions to run when this test finishes.
       |  final _tearDowns = <AsyncFunction>[];
       |
       |  /// Messages to print if and when this test fails.
       |  final _printsOnFailure = <String>[];
       |
      1|  Invoker._(Suite suite, LocalTest test, {Iterable<Group> groups}) {
      2|    _controller = new LiveTestController(
      3|        suite, test, _onRun, _onCloseCompleter.complete,
       |        groups: groups);
       |  }
       |
       |  /// Runs [callback] after this test completes.
       |  ///
       |  /// The [callback] may return a [Future]. Like all tear-downs, callbacks are
       |  /// run in the reverse of the order they're declared.
       |  void addTearDown(callback()) {
      0|    if (closed) throw new ClosedException();
      0|    _tearDowns.add(callback);
       |  }
       |
       |  /// Tells the invoker that there's a callback running that it should wait for
       |  /// before considering the test successful.
       |  ///
       |  /// Each call to [addOutstandingCallback] should be followed by a call to
       |  /// [removeOutstandingCallback] once the callbak is no longer running. Note
       |  /// that only successful tests wait for outstanding callbacks; as soon as a
       |  /// test experiences an error, any further calls to [addOutstandingCallback]
       |  /// or [removeOutstandingCallback] will do nothing.
       |  ///
       |  /// Throws a [ClosedException] if this test has been closed.
       |  void addOutstandingCallback() {
      0|    if (closed) throw new ClosedException();
      0|    _outstandingCallbacks.addOutstandingCallback();
       |  }
       |
       |  /// Tells the invoker that a callback declared with [addOutstandingCallback]
       |  /// is no longer running.
       |  void removeOutstandingCallback() {
      1|    heartbeat();
      2|    _outstandingCallbacks.removeOutstandingCallback();
       |  }
       |
       |  /// Removes all outstanding callbacks, for example when an error occurs.
       |  ///
       |  /// Future calls to [addOutstandingCallback] and [removeOutstandingCallback]
       |  /// will be ignored.
       |  void removeAllOutstandingCallbacks() =>
      2|      _outstandingCallbacks.removeAllOutstandingCallbacks();
       |
       |  /// Runs [fn] and returns once all (registered) outstanding callbacks it
       |  /// transitively invokes have completed.
       |  ///
       |  /// If [fn] itself returns a future, this will automatically wait until that
       |  /// future completes as well. Note that outstanding callbacks registered
       |  /// within [fn] will *not* be registered as outstanding callback outside of
       |  /// [fn].
       |  ///
       |  /// If [fn] produces an unhandled error, this marks the current test as
       |  /// failed, removes all outstanding callbacks registered within [fn], and
       |  /// completes the returned future. It does not remove any outstanding
       |  /// callbacks registered outside of [fn].
       |  ///
       |  /// If the test times out, the *most recent* call to
       |  /// [waitForOutstandingCallbacks] will treat that error as occurring within
       |  /// [fn]—that is, it will complete immediately.
       |  Future waitForOutstandingCallbacks(fn()) {
      1|    heartbeat();
       |
       |    var zone;
      1|    var counter = new OutstandingCallbackCounter();
      1|    runZoned(() {
      1|      runZoned(() async {
      1|        zone = Zone.current;
      2|        _outstandingCallbackZones.add(zone);
      2|        await fn();
      1|        counter.removeOutstandingCallback();
      2|      }, onError: _handleError);
      2|    }, zoneValues: {_counterKey: counter});
       |
      2|    return counter.noOutstandingCallbacks.whenComplete(() {
      2|      _outstandingCallbackZones.remove(zone);
       |    });
       |  }
       |
       |  /// Runs [fn] in a zone where [closed] is always `false`.
       |  ///
       |  /// This is useful for running code that should be able to register callbacks
       |  /// and interact with the test framework normally even when the invoker is
       |  /// closed, for example cleanup code.
       |  unclosable(fn()) {
      1|    heartbeat();
       |
      3|    return runZoned(fn, zoneValues: {_closableKey: false});
       |  }
       |
       |  /// Notifies the invoker that progress is being made.
       |  ///
       |  /// Each heartbeat resets the timeout timer. This helps ensure that
       |  /// long-running tests that still make progress don't time out.
       |  void heartbeat() {
      2|    if (liveTest.isComplete) return;
      3|    if (_timeoutTimer != null) _timeoutTimer.cancel();
       |
       |    var timeout =
      6|        liveTest.test.metadata.timeout.apply(new Duration(seconds: 30));
       |    if (timeout == null) return;
      3|    _timeoutTimer = _invokerZone.createTimer(timeout, () {
      0|      _outstandingCallbackZones.last.run(() {
      0|        if (liveTest.isComplete) return;
      0|        _handleError(new TimeoutException(
      0|            "Test timed out after ${niceDuration(timeout)}.", timeout));
       |      });
       |    });
       |  }
       |
       |  /// Marks the current test as skipped.
       |  ///
       |  /// If passed, [message] is emitted as a skip message.
       |  ///
       |  /// Note that this *does not* mark the test as complete. That is, it sets
       |  /// the result to [Result.skipped], but doesn't change the state.
       |  void skip([String message]) {
      0|    if (liveTest.state.shouldBeDone) {
       |      // Set the state explicitly so we don't get an extra error about the test
       |      // failing after being complete.
      0|      _controller.setState(const State(Status.complete, Result.error));
       |      throw "This test was marked as skipped after it had already completed. "
       |          "Make sure to use\n"
       |          "[expectAsync] or the [completes] matcher when testing async code.";
       |    }
       |
      0|    if (message != null) _controller.message(new Message.skip(message));
       |    // TODO: error if the test is already complete.
      0|    _controller.setState(const State(Status.pending, Result.skipped));
       |  }
       |
       |  /// Prints [message] if and when this test fails.
       |  void printOnFailure(String message) {
      0|    message = message.trim();
      0|    if (liveTest.state.result.isFailing) {
      0|      print("\n$message");
       |    } else {
      0|      _printsOnFailure.add(message);
       |    }
       |  }
       |
       |  /// Notifies the invoker of an asynchronous error.
       |  void _handleError(error, [StackTrace stackTrace]) {
      0|    if (stackTrace == null) stackTrace = new Chain.current();
       |
       |    // Store these here because they'll change when we set the state below.
      3|    var shouldBeDone = liveTest.state.shouldBeDone;
       |
      1|    if (error is! TestFailure) {
      0|      _controller.setState(const State(Status.complete, Result.error));
      4|    } else if (liveTest.state.result != Result.error) {
      2|      _controller.setState(const State(Status.complete, Result.failure));
       |    }
       |
      2|    _controller.addError(error, stackTrace);
      1|    removeAllOutstandingCallbacks();
       |
      4|    if (!liveTest.test.metadata.chainStackTraces) {
      0|      _printsOnFailure.add("Consider enabling the flag chain-stack-traces to "
       |          "recieve more detailed exceptions.\n"
       |          "For example, 'pub run test --chain-stack-traces'.");
       |    }
       |
      2|    if (_printsOnFailure.isNotEmpty) {
      0|      print(_printsOnFailure.join("\n\n"));
      0|      _printsOnFailure.clear();
       |    }
       |
       |    // If a test was supposed to be done but then had an error, that indicates
       |    // that it was poorly-written and could be flaky.
       |    if (!shouldBeDone) return;
       |
       |    // However, users don't think of load tests as "tests", so the error isn't
       |    // helpful for them.
       |    //
       |    // TODO(nweiz): Find a way of avoiding this error that doesn't require
       |    // Invoker to refer to a class from the runner.
      0|    if (liveTest.suite is LoadSuite) return;
       |
      0|    _handleError(
       |        "This test failed after it had already completed. Make sure to use "
       |        "[expectAsync]\n"
       |        "or the [completes] matcher when testing async code.",
       |        stackTrace);
       |  }
       |
       |  /// The method that's run when the test is started.
       |  void _onRun() {
      2|    _controller.setState(const State(Status.running, Result.success));
       |
      1|    var outstandingCallbacksForBody = new OutstandingCallbackCounter();
       |
      1|    Chain.capture(() {
      1|      runZonedWithValues(() async {
      2|        _invokerZone = Zone.current;
      3|        _outstandingCallbackZones.add(Zone.current);
       |
       |        // Run the test asynchronously so that the "running" state change has
       |        // a chance to hit its event handler(s) before the test produces an
       |        // error. If an error is emitted before the first state change is
       |        // handled, we can end up with [onError] callbacks firing before the
       |        // corresponding [onStateChkange], which violates the timing
       |        // guarantees.
       |        //
       |        // Using [new Future] also avoids starving the DOM or other
       |        // microtask-level events.
      1|        new Future(() async {
      3|          await _test._body();
      2|          await unclosable(
      3|              () => Future.forEach(_tearDowns.reversed, errorsDontStopTest));
      1|          removeOutstandingCallback();
      1|        });
       |
      3|        await _outstandingCallbacks.noOutstandingCallbacks;
      3|        if (_timeoutTimer != null) _timeoutTimer.cancel();
       |
      6|        _controller.setState(new State(Status.complete, liveTest.state.result));
       |
      3|        _controller.completer.complete();
      1|      },
      1|          zoneValues: {
       |            #test.invoker: this,
       |            // Use the invoker as a key so that multiple invokers can have different
       |            // outstanding callback counters at once.
      1|            _counterKey: outstandingCallbacksForBody,
      1|            _closableKey: true
       |          },
      1|          zoneSpecification: new ZoneSpecification(
       |              print: (self, parent, zone, line) =>
      3|                  _controller.message(new Message.print(line))),
      1|          onError: _handleError);
      4|    }, when: liveTest.test.metadata.chainStackTraces);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/test_platform.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |// TODO(nweiz): support pluggable platforms.
       |/// An enum of all platforms on which tests can run.
       |class TestPlatform {
       |  // When adding new platforms, be sure to update the baseline and derived
       |  // variable tests in test/backend/platform_selector/evaluate_test.
       |
       |  /// The command-line Dart VM.
       |  static const TestPlatform vm =
       |      const TestPlatform._("VM", "vm", isDartVM: true);
       |
       |  /// Dartium.
       |  static const TestPlatform dartium = const TestPlatform._("Dartium", "dartium",
       |      isBrowser: true, isBlink: true, isDartVM: true);
       |
       |  /// Dartium content shell.
       |  static const TestPlatform contentShell = const TestPlatform._(
       |      "Dartium Content Shell", "content-shell",
       |      isBrowser: true, isBlink: true, isDartVM: true, isHeadless: true);
       |
       |  /// Google Chrome.
       |  static const TestPlatform chrome = const TestPlatform._("Chrome", "chrome",
       |      isBrowser: true, isJS: true, isBlink: true);
       |
       |  /// PhantomJS.
       |  static const TestPlatform phantomJS = const TestPlatform._(
       |      "PhantomJS", "phantomjs",
       |      isBrowser: true, isJS: true, isBlink: true, isHeadless: true);
       |
       |  /// Mozilla Firefox.
       |  static const TestPlatform firefox =
       |      const TestPlatform._("Firefox", "firefox", isBrowser: true, isJS: true);
       |
       |  /// Apple Safari.
       |  static const TestPlatform safari =
       |      const TestPlatform._("Safari", "safari", isBrowser: true, isJS: true);
       |
       |  /// Microsoft Internet Explorer.
       |  static const TestPlatform internetExplorer = const TestPlatform._(
       |      "Internet Explorer", "ie",
       |      isBrowser: true, isJS: true);
       |
       |  /// A list of all instances of [TestPlatform].
       |  static final UnmodifiableListView<TestPlatform> all =
       |      new UnmodifiableListView<TestPlatform>(_allPlatforms);
       |
       |  /// Finds a platform by its identifier string.
       |  ///
       |  /// If no platform is found, returns `null`.
       |  static TestPlatform find(String identifier) =>
      0|      all.firstWhere((platform) => platform.identifier == identifier,
       |          orElse: () => null);
       |
       |  /// The human-friendly name of the platform.
       |  final String name;
       |
       |  /// The identifier used to look up the platform.
       |  final String identifier;
       |
       |  /// Whether this platform runs the Dart VM in any capacity.
       |  final bool isDartVM;
       |
       |  /// Whether this platform is a browser.
       |  final bool isBrowser;
       |
       |  /// Whether this platform runs Dart compiled to JavaScript.
       |  final bool isJS;
       |
       |  /// Whether this platform uses the Blink rendering engine.
       |  final bool isBlink;
       |
       |  /// Whether this platform has no visible window.
       |  final bool isHeadless;
       |
       |  const TestPlatform._(this.name, this.identifier,
       |      {this.isDartVM: false,
       |      this.isBrowser: false,
       |      this.isJS: false,
       |      this.isBlink: false,
      1|      this.isHeadless: false});
       |
      0|  String toString() => name;
       |}
       |
       |final List<TestPlatform> _allPlatforms = [
       |  TestPlatform.vm,
       |  TestPlatform.dartium,
       |  TestPlatform.contentShell,
       |  TestPlatform.chrome,
       |  TestPlatform.phantomJS,
       |  TestPlatform.firefox,
       |  TestPlatform.safari,
       |  TestPlatform.internetExplorer
       |];
       |
       |/// **Do not call this function without express permission from the test package
       |/// authors**.
       |///
       |/// This constructs and globally registers a new TestPlatform with the provided
       |/// details.
       |TestPlatform registerTestPlatform(String name, String identifier,
       |    {bool isDartVM: false,
       |    bool isBrowser: false,
       |    bool isJS: false,
       |    bool isBlink: false,
       |    bool isHeadless: false}) {
      0|  var platform = new TestPlatform._(name, identifier,
       |      isDartVM: isDartVM,
       |      isBrowser: isBrowser,
       |      isJS: isJS,
       |      isBlink: isBlink,
       |      isHeadless: isHeadless);
      0|  _allPlatforms.add(platform);
       |  return platform;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/timeout.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:string_scanner/string_scanner.dart';
       |
       |/// A regular expression that matches text until a letter or whitespace.
       |///
       |/// This is intended to scan through a number without actually encoding the full
       |/// Dart number grammar. It doesn't stop on "e" because that can be a component
       |/// of numbers.
       |final _untilUnit = new RegExp(r"[^a-df-z\s]+", caseSensitive: false);
       |
       |/// A regular expression that matches a time unit.
       |final _unit = new RegExp(r"([um]s|[dhms])", caseSensitive: false);
       |
       |/// A regular expression that matches a section of whitespace.
       |final _whitespace = new RegExp(r"\s+");
       |
       |/// A class representing a modification to the default timeout for a test.
       |///
       |/// By default, a test will time out after 30 seconds. With [new Timeout], that
       |/// can be overridden entirely; with [new Timeout.factor], it can be scaled
       |/// relative to the default.
       |class Timeout {
       |  /// A constant indicating that a test should never time out.
       |  static const none = const Timeout._none();
       |
       |  /// The timeout duration.
       |  ///
       |  /// If set, this overrides the default duration entirely. It's `null` for
       |  /// timeouts with a non-null [scaleFactor] and for [Timeout.none].
       |  final Duration duration;
       |
       |  /// The timeout factor.
       |  ///
       |  /// The default timeout will be multiplied by this to get the new timeout.
       |  /// Thus a factor of 2 means that the test will take twice as long to time
       |  /// out, and a factor of 0.5 means that it will time out twice as quickly.
       |  ///
       |  /// This is `null` for timeouts with a non-null [duration] and for
       |  /// [Timeout.none].
       |  final num scaleFactor;
       |
       |  /// Declares an absolute timeout that overrides the default.
      0|  const Timeout(this.duration) : scaleFactor = null;
       |
       |  /// Declares a relative timeout that scales the default.
      1|  const Timeout.factor(this.scaleFactor) : duration = null;
       |
       |  const Timeout._none()
       |      : scaleFactor = null,
      1|        duration = null;
       |
       |  /// Parse the timeout from a user-provided string.
       |  ///
       |  /// This supports the following formats:
       |  ///
       |  /// * `Number "x"`, which produces a relative timeout with the given scale
       |  ///   factor.
       |  ///
       |  /// * `(Number ("d" | "h" | "m" | "s" | "ms" | "us") (" ")?)+`, which produces
       |  ///   an absolute timeout with the duration given by the sum of the given
       |  ///   units.
       |  ///
       |  /// * `"none"`, which produces [Timeout.none].
       |  ///
       |  /// Throws a [FormatException] if [timeout] is not in a valid format
       |  factory Timeout.parse(String timeout) {
      0|    var scanner = new StringScanner(timeout);
       |
       |    // First check for the string "none".
      0|    if (scanner.scan("none")) {
      0|      scanner.expectDone();
       |      return Timeout.none;
       |    }
       |
       |    // Scan a number. This will be either a time unit or a scale factor.
      0|    scanner.expect(_untilUnit, name: "number");
      0|    var number = double.parse(scanner.lastMatch[0]);
       |
       |    // A number followed by "x" is a scale factor.
      0|    if (scanner.scan("x") || scanner.scan("X")) {
      0|      scanner.expectDone();
      0|      return new Timeout.factor(number);
       |    }
       |
       |    // Parse time units until none are left. The condition is in the middle of
       |    // the loop because we've already parsed the first number.
       |    var microseconds = 0.0;
       |    while (true) {
      0|      scanner.expect(_unit, name: "unit");
      0|      microseconds += _microsecondsFor(number, scanner.lastMatch[0]);
       |
      0|      scanner.scan(_whitespace);
       |
       |      // Scan the next number, if it's avaialble.
      0|      if (!scanner.scan(_untilUnit)) break;
      0|      number = double.parse(scanner.lastMatch[0]);
       |    }
       |
      0|    scanner.expectDone();
      0|    return new Timeout(new Duration(microseconds: microseconds.round()));
       |  }
       |
       |  /// Returns the number of microseconds in [number] [unit]s.
       |  static double _microsecondsFor(double number, String unit) {
       |    switch (unit) {
      0|      case "d":
      0|        return number * 24 * 60 * 60 * 1000000;
      0|      case "h":
      0|        return number * 60 * 60 * 1000000;
      0|      case "m":
      0|        return number * 60 * 1000000;
      0|      case "s":
      0|        return number * 1000000;
      0|      case "ms":
      0|        return number * 1000;
      0|      case "us":
       |        return number;
       |      default:
      0|        throw new ArgumentError("Unknown unit $unit.");
       |    }
       |  }
       |
       |  /// Returns a new [Timeout] that merges [this] with [other].
       |  ///
       |  /// [Timeout.none] takes precedence over everything. If timeout is
       |  /// [Timeout.none] and [other] declares a [duration], that takes precedence.
       |  /// Otherwise, this timeout's [duration] or [factor] are multiplied by
       |  /// [other]'s [factor].
       |  Timeout merge(Timeout other) {
      2|    if (this == none || other == none) return none;
      1|    if (other.duration != null) return new Timeout(other.duration);
      1|    if (duration != null) return new Timeout(duration * other.scaleFactor);
      4|    return new Timeout.factor(scaleFactor * other.scaleFactor);
       |  }
       |
       |  /// Returns a new [Duration] from applying [this] to [base].
       |  ///
       |  /// If this is [none], returns `null`.
       |  Duration apply(Duration base) {
      1|    if (this == none) return null;
      3|    return duration == null ? base * scaleFactor : duration;
       |  }
       |
      0|  int get hashCode => duration.hashCode ^ 5 * scaleFactor.hashCode;
       |
       |  bool operator ==(other) =>
      1|      other is Timeout &&
      3|      other.duration == duration &&
      3|      other.scaleFactor == scaleFactor;
       |
       |  String toString() {
      0|    if (duration != null) return duration.toString();
      0|    if (scaleFactor != null) return "${scaleFactor}x";
       |    return "none";
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/configuration/suite.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:boolean_selector/boolean_selector.dart';
       |import 'package:collection/collection.dart';
       |
       |import '../../backend/metadata.dart';
       |import '../../backend/operating_system.dart';
       |import '../../backend/platform_selector.dart';
       |import '../../backend/test_platform.dart';
       |import '../../frontend/timeout.dart';
       |
       |/// Suite-level configuration.
       |///
       |/// This tracks configuration that can differ from suite to suite.
       |class SuiteConfiguration {
       |  /// Empty configuration with only default values.
       |  ///
       |  /// Using this is slightly more efficient than manually constructing a new
       |  /// configuration with no arguments.
       |  static final empty = new SuiteConfiguration._();
       |
       |  /// Whether JavaScript stack traces should be left as-is or converted to
       |  /// Dart-like traces.
      0|  bool get jsTrace => _jsTrace ?? false;
       |  final bool _jsTrace;
       |
       |  /// Whether skipped tests should be run.
      1|  bool get runSkipped => _runSkipped ?? false;
       |  final bool _runSkipped;
       |
       |  /// The path to a mirror of this package containing HTML that points to
       |  /// precompiled JS.
       |  ///
       |  /// This is used by the internal Google test runner so that test compilation
       |  /// can more effectively make use of Google's build tools.
       |  final String precompiledPath;
       |
       |  /// Additional arguments to pass to dart2js.
       |  ///
       |  /// Note that this if multiple suites run the same JavaScript on different
       |  /// platforms, and they have different [dart2jsArgs], only one (undefined)
       |  /// suite's arguments will be used.
       |  final List<String> dart2jsArgs;
       |
       |  /// The patterns to match against test names to decide which to run, or `null`
       |  /// if all tests should be run.
       |  ///
       |  /// All patterns must match in order for a test to be run.
       |  final Set<Pattern> patterns;
       |
       |  /// The set of platforms on which to run tests.
      0|  List<TestPlatform> get platforms => _platforms ?? const [TestPlatform.vm];
       |  final List<TestPlatform> _platforms;
       |
       |  /// Only run tests whose tags match this selector.
       |  ///
       |  /// When [merge]d, this is intersected with the other configuration's included
       |  /// tags.
       |  final BooleanSelector includeTags;
       |
       |  /// Do not run tests whose tags match this selector.
       |  ///
       |  /// When [merge]d, this is unioned with the other configuration's
       |  /// excluded tags.
       |  final BooleanSelector excludeTags;
       |
       |  /// Configuration for particular tags.
       |  ///
       |  /// The keys are tag selectors, and the values are configurations for tests
       |  /// whose tags match those selectors.
       |  final Map<BooleanSelector, SuiteConfiguration> tags;
       |
       |  /// Configuration for particular platforms.
       |  ///
       |  /// The keys are platform selectors, and the values are configurations for
       |  /// those platforms. These configuration should only contain test-level
       |  /// configuration fields, but that isn't enforced.
       |  final Map<PlatformSelector, SuiteConfiguration> onPlatform;
       |
       |  /// The global test metadata derived from this configuration.
       |  Metadata get metadata {
      0|    if (tags.isEmpty && onPlatform.isEmpty) return _metadata;
      0|    return _metadata.change(
      0|        forTag: mapMap(tags, value: (_, config) => config.metadata),
      0|        onPlatform: mapMap(onPlatform, value: (_, config) => config.metadata));
       |  }
       |
       |  final Metadata _metadata;
       |
       |  /// The set of tags that have been declared in any way in this configuration.
       |  Set<String> get knownTags {
      0|    if (_knownTags != null) return _knownTags;
       |
      0|    var known = includeTags.variables.toSet()
      0|      ..addAll(excludeTags.variables)
      0|      ..addAll(_metadata.tags);
       |
      0|    for (var selector in tags.keys) {
      0|      known.addAll(selector.variables);
       |    }
       |
      0|    for (var configuration in _children) {
      0|      known.addAll(configuration.knownTags);
       |    }
       |
      0|    _knownTags = new UnmodifiableSetView(known);
      0|    return _knownTags;
       |  }
       |
       |  Set<String> _knownTags;
       |
       |  /// All child configurations of [this] that may be selected under various
       |  /// circumstances.
       |  Iterable<SuiteConfiguration> get _children sync* {
      0|    yield* tags.values;
      0|    yield* onPlatform.values;
       |  }
       |
       |  factory SuiteConfiguration(
       |      {bool jsTrace,
       |      bool runSkipped,
       |      Iterable<String> dart2jsArgs,
       |      String precompiledPath,
       |      Iterable<Pattern> patterns,
       |      Iterable<TestPlatform> platforms,
       |      BooleanSelector includeTags,
       |      BooleanSelector excludeTags,
       |      Map<BooleanSelector, SuiteConfiguration> tags,
       |      Map<PlatformSelector, SuiteConfiguration> onPlatform,
       |
       |      // Test-level configuration
       |      Timeout timeout,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      bool skip,
       |      String skipReason,
       |      PlatformSelector testOn,
       |      Iterable<String> addTags}) {
      0|    var config = new SuiteConfiguration._(
       |        jsTrace: jsTrace,
       |        runSkipped: runSkipped,
       |        dart2jsArgs: dart2jsArgs,
       |        precompiledPath: precompiledPath,
       |        patterns: patterns,
       |        platforms: platforms,
       |        includeTags: includeTags,
       |        excludeTags: excludeTags,
       |        tags: tags,
       |        onPlatform: onPlatform,
      0|        metadata: new Metadata(
       |            timeout: timeout,
       |            verboseTrace: verboseTrace,
       |            chainStackTraces: chainStackTraces,
       |            skip: skip,
       |            skipReason: skipReason,
       |            testOn: testOn,
       |            tags: addTags));
      0|    return config._resolveTags();
       |  }
       |
       |  /// Creates new SuiteConfiguration.
       |  ///
       |  /// Unlike [new SuiteConfiguration], this assumes [tags] is already
       |  /// resolved.
       |  SuiteConfiguration._(
       |      {bool jsTrace,
       |      bool runSkipped,
       |      Iterable<String> dart2jsArgs,
       |      this.precompiledPath,
       |      Iterable<Pattern> patterns,
       |      Iterable<TestPlatform> platforms,
       |      BooleanSelector includeTags,
       |      BooleanSelector excludeTags,
       |      Map<BooleanSelector, SuiteConfiguration> tags,
       |      Map<PlatformSelector, SuiteConfiguration> onPlatform,
       |      Metadata metadata})
       |      : _jsTrace = jsTrace,
       |        _runSkipped = runSkipped,
      1|        dart2jsArgs = _list(dart2jsArgs) ?? const [],
      2|        patterns = new UnmodifiableSetView(patterns?.toSet() ?? new Set()),
      1|        _platforms = _list(platforms),
       |        includeTags = includeTags ?? BooleanSelector.all,
       |        excludeTags = excludeTags ?? BooleanSelector.none,
      1|        tags = _map(tags),
      1|        onPlatform = _map(onPlatform),
      2|        _metadata = metadata ?? Metadata.empty;
       |
       |  /// Creates a new [SuiteConfiguration] that takes its configuration from
       |  /// [metadata].
       |  factory SuiteConfiguration.fromMetadata(Metadata metadata) =>
      0|      new SuiteConfiguration._(
      0|          tags: mapMap(metadata.forTag,
      0|              value: (_, child) => new SuiteConfiguration.fromMetadata(child)),
      0|          onPlatform: mapMap(metadata.onPlatform,
      0|              value: (_, child) => new SuiteConfiguration.fromMetadata(child)),
      0|          metadata: metadata.change(forTag: {}, onPlatform: {}));
       |
       |  /// Returns an unmodifiable copy of [input].
       |  ///
       |  /// If [input] is `null` or empty, this returns `null`.
       |  static List/*<T>*/ _list/*<T>*/(Iterable/*<T>*/ input) {
       |    if (input == null) return null;
      0|    var list = new List/*<T>*/ .unmodifiable(input);
      0|    if (list.isEmpty) return null;
       |    return list;
       |  }
       |
       |  /// Returns an unmodifiable copy of [input] or an empty unmodifiable map.
       |  static Map/*<K, V>*/ _map/*<K, V>*/(Map/*<K, V>*/ input) {
      0|    if (input == null || input.isEmpty) return const {};
      0|    return new Map.unmodifiable(input);
       |  }
       |
       |  /// Merges this with [other].
       |  ///
       |  /// For most fields, if both configurations have values set, [other]'s value
       |  /// takes precedence. However, certain fields are merged together instead.
       |  /// This is indicated in those fields' documentation.
       |  SuiteConfiguration merge(SuiteConfiguration other) {
      0|    if (this == SuiteConfiguration.empty) return other;
      0|    if (other == SuiteConfiguration.empty) return this;
       |
      0|    var config = new SuiteConfiguration._(
      0|        jsTrace: other._jsTrace ?? _jsTrace,
      0|        runSkipped: other._runSkipped ?? _runSkipped,
      0|        dart2jsArgs: dart2jsArgs.toList()..addAll(other.dart2jsArgs),
      0|        precompiledPath: other.precompiledPath ?? precompiledPath,
      0|        patterns: patterns.union(other.patterns),
      0|        platforms: other._platforms ?? _platforms,
      0|        includeTags: includeTags.intersection(other.includeTags),
      0|        excludeTags: excludeTags.union(other.excludeTags),
      0|        tags: _mergeConfigMaps(tags, other.tags),
      0|        onPlatform: _mergeConfigMaps(onPlatform, other.onPlatform),
      0|        metadata: metadata.merge(other.metadata));
      0|    return config._resolveTags();
       |  }
       |
       |  /// Returns a copy of this configuration with the given fields updated.
       |  ///
       |  /// Note that unlike [merge], this has no merging behavior—the old value is
       |  /// always replaced by the new one.
       |  SuiteConfiguration change(
       |      {bool jsTrace,
       |      bool runSkipped,
       |      Iterable<String> dart2jsArgs,
       |      String precompiledPath,
       |      Iterable<Pattern> patterns,
       |      Iterable<TestPlatform> platforms,
       |      BooleanSelector includeTags,
       |      BooleanSelector excludeTags,
       |      Map<BooleanSelector, SuiteConfiguration> tags,
       |      Map<PlatformSelector, SuiteConfiguration> onPlatform,
       |
       |      // Test-level configuration
       |      Timeout timeout,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      bool skip,
       |      String skipReason,
       |      PlatformSelector testOn,
       |      Iterable<String> addTags}) {
      0|    var config = new SuiteConfiguration._(
      0|        jsTrace: jsTrace ?? _jsTrace,
      0|        runSkipped: runSkipped ?? _runSkipped,
      0|        dart2jsArgs: dart2jsArgs?.toList() ?? this.dart2jsArgs,
      0|        precompiledPath: precompiledPath ?? this.precompiledPath,
      0|        patterns: patterns ?? this.patterns,
      0|        platforms: platforms ?? _platforms,
      0|        includeTags: includeTags ?? this.includeTags,
      0|        excludeTags: excludeTags ?? this.excludeTags,
      0|        tags: tags ?? this.tags,
      0|        onPlatform: onPlatform ?? this.onPlatform,
      0|        metadata: _metadata.change(
       |            timeout: timeout,
       |            verboseTrace: verboseTrace,
       |            chainStackTraces: chainStackTraces,
       |            skip: skip,
       |            skipReason: skipReason,
       |            testOn: testOn,
       |            tags: addTags));
      0|    return config._resolveTags();
       |  }
       |
       |  /// Returns a copy of [this] with all platform-specific configuration from
       |  /// [onPlatform] resolved.
       |  SuiteConfiguration forPlatform(TestPlatform platform, {OperatingSystem os}) {
      0|    if (onPlatform.isEmpty) return this;
       |
       |    var config = this;
      0|    onPlatform.forEach((platformSelector, platformConfig) {
      0|      if (!platformSelector.evaluate(platform, os: os)) return;
      0|      config = config.merge(platformConfig);
       |    });
      0|    return config.change(onPlatform: {});
       |  }
       |
       |  /// Merges two maps whose values are [SuiteConfiguration]s.
       |  ///
       |  /// Any overlapping keys in the maps have their configurations merged in the
       |  /// returned map.
       |  Map<Object, SuiteConfiguration> _mergeConfigMaps(
       |          Map<Object, SuiteConfiguration> map1,
       |          Map<Object, SuiteConfiguration> map2) =>
      0|      mergeMaps(map1, map2,
      0|          value: (config1, config2) => config1.merge(config2));
       |
       |  SuiteConfiguration _resolveTags() {
       |    // If there's no tag-specific configuration, or if none of it applies, just
       |    // return the configuration as-is.
      0|    if (_metadata.tags.isEmpty || tags.isEmpty) return this;
       |
       |    // Otherwise, resolve the tag-specific components.
      0|    var newTags = new Map<BooleanSelector, SuiteConfiguration>.from(tags);
      0|    var merged = tags.keys.fold(empty, (merged, selector) {
      0|      if (!selector.evaluate(_metadata.tags)) return merged;
      0|      return merged.merge(newTags.remove(selector));
       |    });
       |
      0|    if (merged == empty) return this;
      0|    return this.change(tags: newTags).merge(merged);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/engine.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import 'package:async/async.dart' hide Result;
       |import 'package:collection/collection.dart';
       |import 'package:pool/pool.dart';
       |
       |import '../backend/group.dart';
       |import '../backend/invoker.dart';
       |import '../backend/live_test.dart';
       |import '../backend/live_test_controller.dart';
       |import '../backend/message.dart';
       |import '../backend/state.dart';
       |import '../backend/test.dart';
       |import '../util/iterable_set.dart';
       |import 'live_suite.dart';
       |import 'live_suite_controller.dart';
       |import 'load_suite.dart';
       |import 'runner_suite.dart';
       |
       |/// An [Engine] manages a run that encompasses multiple test suites.
       |///
       |/// Test suites are provided by passing them into [suiteSink]. Once all suites
       |/// have been provided, the user should close [suiteSink] to indicate this.
       |/// [run] won't terminate until [suiteSink] is closed. Suites will be run in the
       |/// order they're provided to [suiteSink]. Tests within those suites will
       |/// likewise be run in the order they're declared.
       |///
       |/// The current status of every test is visible via [liveTests]. [onTestStarted]
       |/// can also be used to be notified when a test is about to be run.
       |///
       |/// The engine has some special logic for [LoadSuite]s and the tests they
       |/// contain, referred to as "load tests". Load tests exist to provide visibility
       |/// into the process of loading test files, but as long as that process is
       |/// proceeding normally users usually don't care about it, so the engine only
       |/// surfaces running load tests (that is, includes them in [liveTests] and other
       |/// collections) under specific circumstances.
       |///
       |/// If only load tests are running, exactly one load test will be in [active]
       |/// and [liveTests]. If this test passes, it will be removed from both [active]
       |/// and [liveTests] and *will not* be added to [passed]. If at any point a load
       |/// test fails, it will be added to [failed] and [liveTests].
       |///
       |/// The test suite loaded by a load suite will be automatically be run by the
       |/// engine; it doesn't need to be added to [suiteSink] manually.
       |///
       |/// Load tests will always be emitted through [onTestStarted] so users can watch
       |/// their event streams once they start running.
       |class Engine {
       |  /// Whether [run] has been called yet.
       |  var _runCalled = false;
       |
       |  /// Whether [close] has been called.
       |  var _closed = false;
       |
       |  /// Whether [close] was called before all the tests finished running.
       |  ///
       |  /// This is `null` if close hasn't been called and the tests are still
       |  /// running, `true` if close was called before the tests finished running, and
       |  /// `false` if the tests finished running before close was called.
       |  var _closedBeforeDone;
       |
       |  /// A pool that limits the number of test suites running concurrently.
       |  final Pool _runPool;
       |
       |  /// A pool that limits the number of test suites loaded concurrently.
       |  ///
       |  /// Once this reaches its limit, loading any additional test suites will cause
       |  /// previous suites to be unloaded in the order they completed.
       |  final Pool _loadPool;
       |
       |  /// A completer that will complete when [this] is unpaused.
       |  ///
       |  /// If [this] isn't paused, [_pauseCompleter] is `null`.
       |  Completer _pauseCompleter;
       |
       |  /// A future that completes once [this] is unpaused.
       |  ///
       |  /// If [this] isn't paused, this completes immediately.
       |  Future get _onUnpaused =>
      2|      _pauseCompleter == null ? new Future.value() : _pauseCompleter.future;
       |
       |  /// Whether all tests passed or were skipped.
       |  ///
       |  /// This fires once all tests have completed and [suiteSink] has been closed.
       |  /// This will be `null` if [close] was called before all the tests finished
       |  /// running.
       |  Future<bool> get success async {
      1|    await Future
      6|        .wait(<Future>[_group.future, _loadPool.done], eagerError: true);
      1|    if (_closedBeforeDone) return null;
      6|    return liveTests.every((liveTest) => liveTest.state.result.isPassing);
       |  }
       |
       |  /// A group of futures for each test suite.
       |  final _group = new FutureGroup();
       |
       |  /// All of the engine's stream subscriptions.
       |  final _subscriptions = new Set<StreamSubscription>();
       |
       |  /// A sink used to pass [RunnerSuite]s in to the engine to run.
       |  ///
       |  /// Suites may be added as quickly as they're available; the Engine will only
       |  /// run as many as necessary at a time based on its concurrency settings.
       |  ///
       |  /// Suites added to the sink will be closed by the engine based on its
       |  /// internal logic.
      3|  Sink<RunnerSuite> get suiteSink => new DelegatingSink(_suiteController.sink);
       |  final _suiteController = new StreamController<RunnerSuite>();
       |
       |  /// All the [RunnerSuite]s added to [suiteSink] so far.
       |  ///
       |  /// Note that if a [LoadSuite] is added, this will only contain that suite,
       |  /// not the suite it loads.
      0|  Set<RunnerSuite> get addedSuites => new UnmodifiableSetView(_addedSuites);
       |  final _addedSuites = new Set<RunnerSuite>();
       |
       |  /// A broadcast stream that emits each [RunnerSuite] as it's added to the
       |  /// engine via [suiteSink].
       |  ///
       |  /// Note that if a [LoadSuite] is added, this will only return that suite, not
       |  /// the suite it loads.
       |  ///
       |  /// This is guaranteed to fire after the suite is added to [addedSuites].
      0|  Stream<RunnerSuite> get onSuiteAdded => _onSuiteAddedController.stream;
       |  final _onSuiteAddedController = new StreamController<RunnerSuite>.broadcast();
       |
       |  /// All the currently-known suites that have run or are running.
       |  ///
       |  /// These are [LiveSuite]s, representing the in-progress state of each suite
       |  /// as its component tests are being run.
       |  ///
       |  /// Note that unlike [addedSuites], for suites that are loaded using
       |  /// [LoadSuite]s, both the [LoadSuite] and the suite it loads will eventually
       |  /// be in this set.
      0|  Set<LiveSuite> get liveSuites => new UnmodifiableSetView(_liveSuites);
       |  final _liveSuites = new Set<LiveSuite>();
       |
       |  /// A broadcast stream that emits each [LiveSuite] as it's loaded.
       |  ///
       |  /// Note that unlike [onSuiteAdded], for suites that are loaded using
       |  /// [LoadSuite]s, both the [LoadSuite] and the suite it loads will eventually
       |  /// be emitted by this stream.
      0|  Stream<LiveSuite> get onSuiteStarted => _onSuiteStartedController.stream;
       |  final _onSuiteStartedController = new StreamController<LiveSuite>.broadcast();
       |
       |  /// All the currently-known tests that have run or are running.
       |  ///
       |  /// These are [LiveTest]s, representing the in-progress state of each test.
       |  /// Tests that have not yet begun running are marked [Status.pending]; tests
       |  /// that have finished are marked [Status.complete].
       |  ///
       |  /// This is guaranteed to contain the same tests as the union of [passed],
       |  /// [skipped], [failed], and [active].
       |  ///
       |  /// [LiveTest.run] must not be called on these tests.
       |  Set<LiveTest> get liveTests =>
      7|      new UnionSet.from([passed, skipped, failed, new IterableSet(active)],
       |          disjoint: true);
       |
       |  /// A stream that emits each [LiveTest] as it's about to start running.
       |  ///
       |  /// This is guaranteed to fire before [LiveTest.onStateChange] first fires.
      2|  Stream<LiveTest> get onTestStarted => _onTestStartedGroup.stream;
       |  final _onTestStartedGroup = new StreamGroup<LiveTest>.broadcast();
       |
       |  /// The set of tests that have completed and been marked as passing.
      2|  Set<LiveTest> get passed => _passedGroup.set;
       |  final _passedGroup = new UnionSetController<LiveTest>(disjoint: true);
       |
       |  /// The set of tests that have completed and been marked as skipped.
      2|  Set<LiveTest> get skipped => _skippedGroup.set;
       |  final _skippedGroup = new UnionSetController<LiveTest>(disjoint: true);
       |
       |  /// The set of tests that have completed and been marked as failing or error.
      2|  Set<LiveTest> get failed => _failedGroup.set;
       |  final _failedGroup = new UnionSetController<LiveTest>(disjoint: true);
       |
       |  /// The tests that are still running, in the order they begain running.
      2|  List<LiveTest> get active => new UnmodifiableListView(_active);
       |  final _active = new QueueList<LiveTest>();
       |
       |  /// The set of tests that have been marked for restarting.
       |  ///
       |  /// This is always a subset of [active]. Once a test in here has finished
       |  /// running, it's run again.
       |  final _restarted = new Set<LiveTest>();
       |
       |  /// The tests from [LoadSuite]s that are still running, in the order they
       |  /// began running.
       |  ///
       |  /// This is separate from [active] because load tests aren't always surfaced.
       |  final _activeLoadTests = new List<LiveTest>();
       |
       |  /// Whether this engine is idle—that is, not currently executing a test.
      0|  bool get isIdle => _group.isIdle;
       |
       |  /// A broadcast stream that fires an event whenever [isIdle] switches from
       |  /// `false` to `true`.
      0|  Stream get onIdle => _group.onIdle;
       |
       |  // TODO(nweiz): Use interface libraries to take a Configuration even when
       |  // dart:io is unavailable.
       |  /// Creates an [Engine] that will run all tests provided via [suiteSink].
       |  ///
       |  /// [concurrency] controls how many suites are run at once, and defaults to 1.
       |  /// [maxSuites] controls how many suites are *loaded* at once, and defaults to
       |  /// four times [concurrency].
       |  Engine({int concurrency, int maxSuites})
      1|      : _runPool = new Pool(concurrency ?? 1),
      3|        _loadPool = new Pool(maxSuites ?? (concurrency ?? 1) * 2) {
      3|    _group.future.then((_) {
      2|      _onTestStartedGroup.close();
      2|      _onSuiteStartedController.close();
      2|      if (_closedBeforeDone == null) _closedBeforeDone = false;
      1|    }).catchError((_) {
       |      // Don't top-level errors. They'll be thrown via [success] anyway.
       |    });
       |  }
       |
       |  /// Creates an [Engine] that will run all tests in [suites].
       |  ///
       |  /// An engine constructed this way will automatically close its [suiteSink],
       |  /// meaning that no further suites may be provided.
       |  ///
       |  /// [concurrency] controls how many suites are run at once. If [runSkipped] is
       |  /// `true`, skipped tests will be run as though they weren't skipped.
       |  factory Engine.withSuites(List<RunnerSuite> suites, {int concurrency}) {
      0|    var engine = new Engine(concurrency: concurrency);
      0|    for (var suite in suites) engine.suiteSink.add(suite);
      0|    engine.suiteSink.close();
       |    return engine;
       |  }
       |
       |  /// Runs all tests in all suites defined by this engine.
       |  ///
       |  /// This returns `true` if all tests succeed, and `false` otherwise. It will
       |  /// only return once all tests have finished running and [suiteSink] has been
       |  /// closed.
       |  Future<bool> run() {
      1|    if (_runCalled) {
      0|      throw new StateError("Engine.run() may not be called more than once.");
       |    }
      1|    _runCalled = true;
       |
       |    StreamSubscription subscription;
      3|    subscription = _suiteController.stream.listen((suite) {
      2|      _addedSuites.add(suite);
      2|      _onSuiteAddedController.add(suite);
       |
      3|      _group.add(new Future.sync(() async {
      3|        var loadResource = await _loadPool.request();
       |
       |        var controller;
      1|        if (suite is LoadSuite) {
      0|          await _onUnpaused;
      0|          controller = await _addLoadSuite(suite);
       |          if (controller == null) {
      0|            loadResource.release();
      0|            return;
       |          }
       |        } else {
      1|          controller = new LiveSuiteController(suite);
       |        }
       |
      2|        _addLiveSuite(controller.liveSuite);
       |
      3|        await _runPool.withResource(() async {
      1|          if (_closed) return;
      6|          await _runGroup(controller, controller.liveSuite.suite.group, []);
      1|          controller.noMoreLiveTests();
      2|          loadResource.allowRelease(() => controller.close());
      1|        });
      1|      }));
       |    }, onDone: () {
      2|      _subscriptions.remove(subscription);
      2|      _onSuiteAddedController.close();
      2|      _group.close();
      2|      _loadPool.close();
       |    });
      2|    _subscriptions.add(subscription);
       |
      1|    return success;
       |  }
       |
       |  /// Runs all the entries in [group] in sequence.
       |  ///
       |  /// [suiteController] is the controller fo the suite that contains [group].
       |  /// [parents] is a list of groups that contain [group]. It may be modified,
       |  /// but it's guaranteed to be in its original state once this function has
       |  /// finished.
       |  Future _runGroup(LiveSuiteController suiteController, Group group,
       |      List<Group> parents) async {
      1|    parents.add(group);
       |    try {
      3|      var suiteConfig = suiteController.liveSuite.suite.config;
      3|      var skipGroup = !suiteConfig.runSkipped && group.metadata.skip;
       |      var setUpAllSucceeded = true;
      1|      if (!skipGroup && group.setUpAll != null) {
      0|        var liveTest = group.setUpAll
      0|            .load(suiteController.liveSuite.suite, groups: parents);
      0|        await _runLiveTest(suiteController, liveTest, countSuccess: false);
      0|        setUpAllSucceeded = liveTest.state.result.isPassing;
       |      }
       |
      1|      if (!_closed && setUpAllSucceeded) {
      3|        for (var entry in group.entries) {
      1|          if (_closed) return;
       |
      1|          if (entry is Group) {
      2|            await _runGroup(suiteController, entry, parents);
      3|          } else if (!suiteConfig.runSkipped && entry.metadata.skip) {
      0|            await _runSkippedTest(suiteController, entry, parents);
       |          } else {
      1|            var test = entry as Test;
      2|            await _runLiveTest(suiteController,
      3|                test.load(suiteController.liveSuite.suite, groups: parents));
       |          }
       |        }
       |      }
       |
       |      // Even if we're closed or setUpAll failed, we want to run all the
       |      // teardowns to ensure that any state is properly cleaned up.
      1|      if (!skipGroup && group.tearDownAll != null) {
      0|        var liveTest = group.tearDownAll
      0|            .load(suiteController.liveSuite.suite, groups: parents);
      0|        await _runLiveTest(suiteController, liveTest, countSuccess: false);
      0|        if (_closed) await liveTest.close();
       |      }
       |    } finally {
      1|      parents.remove(group);
       |    }
      1|  }
       |
       |  /// Runs [liveTest] using [suiteController].
       |  ///
       |  /// If [countSuccess] is `true` (the default), the test is put into [passed]
       |  /// if it succeeds. Otherwise, it's removed from [liveTests] entirely.
       |  Future _runLiveTest(LiveSuiteController suiteController, LiveTest liveTest,
       |      {bool countSuccess: true}) async {
      2|    await _onUnpaused;
      2|    _active.add(liveTest);
       |
       |    // If there were no active non-load tests, the current active test would
       |    // have been a load test. In that case, remove it, since now we have a
       |    // non-load test to add.
      4|    if (_active.first.suite is LoadSuite) _active.removeFirst();
       |
       |    StreamSubscription subscription;
      2|    subscription = liveTest.onStateChange.listen((state) {
      2|      if (state.status != Status.complete) return;
      2|      _active.remove(liveTest);
       |
       |      // If we're out of non-load tests, surface a load test.
      4|      if (_active.isEmpty && _activeLoadTests.isNotEmpty) {
      0|        _active.add(_activeLoadTests.first);
       |      }
       |    }, onDone: () {
      0|      _subscriptions.remove(subscription);
       |    });
      2|    _subscriptions.add(subscription);
       |
      1|    suiteController.reportLiveTest(liveTest, countSuccess: countSuccess);
       |
       |    // Schedule a microtask to ensure that [onTestStarted] fires before the
       |    // first [LiveTest.onStateChange] event.
      3|    await new Future.microtask(liveTest.run);
       |
       |    // Once the test finishes, use [new Future] to do a coarse-grained event
       |    // loop pump to avoid starving non-microtask events.
      2|    await new Future(() {});
       |
      3|    if (!_restarted.contains(liveTest)) return;
      0|    await _runLiveTest(suiteController, liveTest.copy(),
       |        countSuccess: countSuccess);
      0|    _restarted.remove(liveTest);
      0|  }
       |
       |  /// Runs a dummy [LiveTest] for a test marked as "skip".
       |  ///
       |  /// [suiteController] is the controller for the suite that contains [test].
       |  /// [parents] is a list of groups that contain [test].
       |  Future _runSkippedTest(LiveSuiteController suiteController, Test test,
       |      List<Group> parents) async {
      0|    await _onUnpaused;
       |    var skipped =
      0|        new LocalTest(test.name, test.metadata, () {}, trace: test.trace);
       |
       |    var controller;
       |    controller =
      0|        new LiveTestController(suiteController.liveSuite.suite, skipped, () {
      0|      controller.setState(const State(Status.running, Result.success));
      0|      controller.setState(const State(Status.running, Result.skipped));
       |
      0|      if (skipped.metadata.skipReason != null) {
       |        controller
      0|            .message(new Message.skip("Skip: ${skipped.metadata.skipReason}"));
       |      }
       |
      0|      controller.setState(const State(Status.complete, Result.skipped));
      0|      controller.completer.complete();
       |    }, () {}, groups: parents);
       |
      0|    return await _runLiveTest(suiteController, controller.liveTest);
       |  }
       |
       |  /// Closes [liveTest] and tells the engine to re-run it once it's done
       |  /// running.
       |  ///
       |  /// Returns the same future as [LiveTest.close].
       |  Future restartTest(LiveTest liveTest) async {
      0|    if (_activeLoadTests.contains(liveTest)) {
      0|      throw new ArgumentError("Can't restart a load test.");
       |    }
       |
      0|    if (!_active.contains(liveTest)) {
      0|      throw new StateError("Can't restart inactive test "
      0|          "\"${liveTest.test.name}\".");
       |    }
       |
      0|    _restarted.add(liveTest);
      0|    _active.remove(liveTest);
      0|    await liveTest.close();
      0|  }
       |
       |  /// Runs [suite] and returns the [LiveSuiteController] for the suite it loads.
       |  ///
       |  /// Returns `null` if the suite fails to load.
       |  Future<LiveSuiteController> _addLoadSuite(LoadSuite suite) async {
      0|    var controller = new LiveSuiteController(suite);
      0|    _addLiveSuite(controller.liveSuite);
       |
      0|    var liveTest = await suite.test.load(suite);
      0|    _activeLoadTests.add(liveTest);
       |
       |    // Only surface the load test if there are no other tests currently running.
      0|    if (_active.isEmpty) _active.add(liveTest);
       |
       |    StreamSubscription subscription;
      0|    subscription = liveTest.onStateChange.listen((state) {
      0|      if (state.status != Status.complete) return;
      0|      _activeLoadTests.remove(liveTest);
       |
       |      // Only one load test will be active at any given time, and it will always
       |      // be the only active test. Remove it and, if possible, surface another
       |      // load test.
      0|      if (_active.isNotEmpty && _active.first.suite == suite) {
      0|        _active.remove(liveTest);
      0|        if (_activeLoadTests.isNotEmpty) _active.add(_activeLoadTests.last);
       |      }
       |    }, onDone: () {
      0|      _subscriptions.remove(subscription);
       |    });
      0|    _subscriptions.add(subscription);
       |
      0|    controller.reportLiveTest(liveTest, countSuccess: false);
      0|    controller.noMoreLiveTests();
       |
       |    // Schedule a microtask to ensure that [onTestStarted] fires before the
       |    // first [LiveTest.onStateChange] event.
      0|    new Future.microtask(liveTest.run);
       |
      0|    var innerSuite = await suite.suite;
      0|    if (innerSuite == null) return null;
       |
      0|    var innerController = new LiveSuiteController(innerSuite);
      0|    innerController.liveSuite.onClose.then((_) {
       |      // When the main suite is closed, close the load suite and its test as
       |      // well. This doesn't release any resources, but it does close streams
       |      // which indicates that the load test won't experience an error in the
       |      // future.
      0|      liveTest.close();
      0|      controller.close();
       |    });
       |
      0|    return innerController;
       |  }
       |
       |  /// Add [liveSuite] and the information it exposes to the engine's
       |  /// informational streams and collections.
       |  void _addLiveSuite(LiveSuite liveSuite) {
      2|    _liveSuites.add(liveSuite);
      2|    _onSuiteStartedController.add(liveSuite);
       |
      3|    _onTestStartedGroup.add(liveSuite.onTestStarted);
      3|    _passedGroup.add(liveSuite.passed);
      3|    _skippedGroup.add(liveSuite.skipped);
      3|    _failedGroup.add(liveSuite.failed);
       |  }
       |
       |  /// Pauses the engine.
       |  ///
       |  /// This pauses all streams and keeps any new suites from being loaded or
       |  /// tests from being run until [resume] is called.
       |  ///
       |  /// This does nothing if the engine is already paused. Pauses are *not*
       |  /// cumulative.
       |  void pause() {
      0|    if (_pauseCompleter != null) return;
      0|    _pauseCompleter = new Completer();
      0|    for (var subscription in _subscriptions) {
      0|      subscription.pause();
       |    }
       |  }
       |
       |  void resume() {
      0|    if (_pauseCompleter == null) return;
      0|    _pauseCompleter.complete();
      0|    _pauseCompleter = null;
      0|    for (var subscription in _subscriptions) {
      0|      subscription.resume();
       |    }
       |  }
       |
       |  /// Signals that the caller is done paying attention to test results and the
       |  /// engine should release any resources it has allocated.
       |  ///
       |  /// Any actively-running tests are also closed. VM tests are allowed to finish
       |  /// running so that any modifications they've made to the filesystem can be
       |  /// cleaned up.
       |  ///
       |  /// **Note that closing the engine is not the same as closing [suiteSink].**
       |  /// Closing [suiteSink] indicates that no more input will be provided, closing
       |  /// the engine indicates that no more output should be emitted.
       |  Future close() async {
      0|    _closed = true;
      0|    if (_closedBeforeDone != null) _closedBeforeDone = true;
      0|    _onSuiteAddedController.close();
      0|    _suiteController.close();
       |
       |    // Close the running tests first so that we're sure to wait for them to
       |    // finish before we close their suites and cause them to become unloaded.
      0|    var allLiveTests = liveTests.toSet()..addAll(_activeLoadTests);
      0|    var futures = allLiveTests.map((liveTest) => liveTest.close()).toList();
       |
       |    // Closing the load pool will close the test suites as soon as their tests
       |    // are done. For browser suites this is effectively immediate since their
       |    // tests shut down as soon as they're closed, but for VM suites we may need
       |    // to wait for tearDowns or tearDownAlls to run.
      0|    futures.add(_loadPool.close());
      0|    await Future.wait(futures, eagerError: true);
      0|  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/plugin/environment.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../environment.dart';
       |
       |/// The default environment for platform plugins.
       |class PluginEnvironment implements Environment {
       |  final supportsDebugging = false;
      0|  Stream get onRestart => new StreamController.broadcast().stream;
       |
      1|  const PluginEnvironment();
       |
       |  Uri get observatoryUrl => null;
       |
       |  Uri get remoteDebuggerUrl => null;
       |
      0|  CancelableOperation displayPause() => throw new UnsupportedError(
       |      "PluginEnvironment.displayPause is not supported.");
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/reporter/expanded.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:isolate';
       |
       |import '../../backend/live_test.dart';
       |import '../../backend/message.dart';
       |import '../../backend/state.dart';
       |import '../../utils.dart';
       |import '../engine.dart';
       |import '../load_exception.dart';
       |import '../load_suite.dart';
       |import '../reporter.dart';
       |
       |/// The maximum console line length.
       |///
       |/// Lines longer than this will be cropped.
       |const _lineLength = 100;
       |
       |/// A reporter that prints each test on its own line.
       |///
       |/// This is currently used in place of [CompactReporter] by `lib/test.dart`,
       |/// which can't transitively import `dart:io` but still needs access to a runner
       |/// so that test files can be run directly. This means that until issue 6943 is
       |/// fixed, this must not import `dart:io`.
       |class ExpandedReporter implements Reporter {
       |  /// Whether the reporter should emit terminal color escapes.
       |  final bool _color;
       |
       |  /// The terminal escape for green text, or the empty string if this is Windows
       |  /// or not outputting to a terminal.
       |  final String _green;
       |
       |  /// The terminal escape for red text, or the empty string if this is Windows
       |  /// or not outputting to a terminal.
       |  final String _red;
       |
       |  /// The terminal escape for yellow text, or the empty string if this is
       |  /// Windows or not outputting to a terminal.
       |  final String _yellow;
       |
       |  /// The terminal escape for gray text, or the empty string if this is
       |  /// Windows or not outputting to a terminal.
       |  final String _gray;
       |
       |  /// The terminal escape for bold text, or the empty string if this is
       |  /// Windows or not outputting to a terminal.
       |  final String _bold;
       |
       |  /// The terminal escape for removing test coloring, or the empty string if
       |  /// this is Windows or not outputting to a terminal.
       |  final String _noColor;
       |
       |  /// The engine used to run the tests.
       |  final Engine _engine;
       |
       |  /// Whether the path to each test's suite should be printed.
       |  final bool _printPath;
       |
       |  /// Whether the platform each test is running on should be printed.
       |  final bool _printPlatform;
       |
       |  /// A stopwatch that tracks the duration of the full run.
       |  final _stopwatch = new Stopwatch();
       |
       |  /// Whether we've started [_stopwatch].
       |  ///
       |  /// We can't just use `_stopwatch.isRunning` because the stopwatch is stopped
       |  /// when the reporter is paused.
       |  var _stopwatchStarted = false;
       |
       |  /// The size of `_engine.passed` last time a progress notification was
       |  /// printed.
       |  int _lastProgressPassed;
       |
       |  /// The size of `_engine.skipped` last time a progress notification was
       |  /// printed.
       |  int _lastProgressSkipped;
       |
       |  /// The size of `_engine.failed` last time a progress notification was
       |  /// printed.
       |  int _lastProgressFailed;
       |
       |  /// The message printed for the last progress notification.
       |  String _lastProgressMessage;
       |
       |  /// The suffix added to the last progress notification.
       |  String _lastProgressSuffix;
       |
       |  /// Whether the reporter is paused.
       |  var _paused = false;
       |
       |  /// The set of all subscriptions to various streams.
       |  final _subscriptions = new Set<StreamSubscription>();
       |
       |  // TODO(nweiz): Get configuration from [Configuration.current] once we have
       |  // cross-platform imports.
       |  /// Watches the tests run by [engine] and prints their results to the
       |  /// terminal.
       |  ///
       |  /// If [color] is `true`, this will use terminal colors; if it's `false`, it
       |  /// won't. If [printPath] is `true`, this will print the path name as part of
       |  /// the test description. Likewise, if [printPlatform] is `true`, this will
       |  /// print the platform as part of the test description.
       |  static ExpandedReporter watch(Engine engine,
       |      {bool color: true, bool printPath: true, bool printPlatform: true}) {
      1|    return new ExpandedReporter._(engine,
       |        color: color, printPath: printPath, printPlatform: printPlatform);
       |  }
       |
       |  ExpandedReporter._(this._engine,
       |      {bool color: true, bool printPath: true, bool printPlatform: true})
       |      : _printPath = printPath,
       |        _printPlatform = printPlatform,
       |        _color = color,
       |        _green = color ? '\u001b[32m' : '',
       |        _red = color ? '\u001b[31m' : '',
       |        _yellow = color ? '\u001b[33m' : '',
       |        _gray = color ? '\u001b[1;30m' : '',
       |        _bold = color ? '\u001b[1m' : '',
      1|        _noColor = color ? '\u001b[0m' : '' {
      6|    _subscriptions.add(_engine.onTestStarted.listen(_onTestStarted));
       |
       |    /// Convert the future to a stream so that the subscription can be paused or
       |    /// canceled.
      7|    _subscriptions.add(_engine.success.asStream().listen(_onDone));
       |  }
       |
       |  void pause() {
      0|    if (_paused) return;
      0|    _paused = true;
       |
      0|    _stopwatch.stop();
       |
      0|    for (var subscription in _subscriptions) {
      0|      subscription.pause();
       |    }
       |  }
       |
       |  void resume() {
      0|    if (!_paused) return;
      0|    if (_stopwatchStarted) _stopwatch.start();
       |
      0|    for (var subscription in _subscriptions) {
      0|      subscription.resume();
       |    }
       |  }
       |
       |  void cancel() {
      0|    for (var subscription in _subscriptions) {
      0|      subscription.cancel();
       |    }
      0|    _subscriptions.clear();
       |  }
       |
       |  /// A callback called when the engine begins running [liveTest].
       |  void _onTestStarted(LiveTest liveTest) {
      2|    if (liveTest.suite is! LoadSuite) {
      4|      if (!_stopwatch.isRunning) _stopwatch.start();
       |
       |      // If this is the first non-load test to start, print a progress line so
       |      // the user knows what's running.
      6|      if (_engine.active.length == 1) _progressLine(_description(liveTest));
       |
       |      // The engine surfaces load tests when there are no other tests running,
       |      // but because the expanded reporter's output is always visible, we don't
       |      // emit information about them unless they fail.
      3|      _subscriptions.add(liveTest.onStateChange
      2|          .listen((state) => _onStateChange(liveTest, state)));
      0|    } else if (_engine.active.length == 1 &&
      0|        _engine.active.first == liveTest &&
      0|        liveTest.test.name.startsWith("compiling ")) {
       |      // Print a progress line for load tests that come from compiling JS, since
       |      // that takes a long time.
      0|      _progressLine(_description(liveTest));
       |    }
       |
      3|    _subscriptions.add(liveTest.onError
      4|        .listen((error) => _onError(liveTest, error.error, error.stackTrace)));
       |
      4|    _subscriptions.add(liveTest.onMessage.listen((message) {
      2|      _progressLine(_description(liveTest));
      1|      var text = message.text;
      2|      if (message.type == MessageType.skip) text = '  $_yellow$text$_noColor';
      1|      print(text);
       |    }));
       |  }
       |
       |  /// A callback called when [liveTest]'s state becomes [state].
       |  void _onStateChange(LiveTest liveTest, State state) {
      2|    if (state.status != Status.complete) return;
       |
       |    // If any tests are running, display the name of the oldest active
       |    // test.
      3|    if (_engine.active.isNotEmpty) {
      0|      _progressLine(_description(_engine.active.first));
       |    }
       |  }
       |
       |  /// A callback called when [liveTest] throws [error].
       |  void _onError(LiveTest liveTest, error, StackTrace stackTrace) {
      3|    if (liveTest.state.status != Status.complete) return;
       |
      6|    _progressLine(_description(liveTest), suffix: " $_bold$_red[E]$_noColor");
       |
      1|    if (error is! LoadException) {
      3|      print(indent(error.toString()));
       |      var chain =
      4|          terseChain(stackTrace, verbose: liveTest.test.metadata.verboseTrace);
      3|      print(indent(chain.toString()));
       |      return;
       |    }
       |
      0|    print(indent(error.toString(color: _color)));
       |
       |    // Only print stack traces for load errors that come from the user's code.
      0|    if (error.innerError is! IsolateSpawnException &&
      0|        error.innerError is! FormatException &&
      0|        error.innerError is! String) {
      0|      print(indent(terseChain(stackTrace).toString()));
       |    }
       |  }
       |
       |  /// A callback called when the engine is finished running tests.
       |  ///
       |  /// [success] will be `true` if all tests passed, `false` if some tests
       |  /// failed, and `null` if the engine was closed prematurely.
       |  void _onDone(bool success) {
       |    // A null success value indicates that the engine was closed before the
       |    // tests finished running, probably because of a signal from the user, in
       |    // which case we shouldn't print summary information.
       |    if (success == null) return;
       |
      3|    if (_engine.liveTests.isEmpty) {
      0|      print("No tests ran.");
       |    } else if (!success) {
      2|      _progressLine('Some tests failed.', color: _red);
      0|    } else if (_engine.passed.isEmpty) {
      0|      _progressLine("All tests skipped.");
       |    } else {
      0|      _progressLine("All tests passed!");
       |    }
       |  }
       |
       |  /// Prints a line representing the current state of the tests.
       |  ///
       |  /// [message] goes after the progress report, and may be truncated to fit the
       |  /// entire line within [_lineLength]. If [color] is passed, it's used as the
       |  /// color for [message]. If [suffix] is passed, it's added to the end of
       |  /// [message].
       |  void _progressLine(String message, {String color, String suffix}) {
       |    // Print nothing if nothing has changed since the last progress line.
      5|    if (_engine.passed.length == _lastProgressPassed &&
      5|        _engine.skipped.length == _lastProgressSkipped &&
      5|        _engine.failed.length == _lastProgressFailed &&
      2|        message == _lastProgressMessage &&
       |        // Don't re-print just because a suffix was removed.
      0|        (suffix == null || suffix == _lastProgressSuffix)) {
       |      return;
       |    }
       |
      4|    _lastProgressPassed = _engine.passed.length;
      4|    _lastProgressSkipped = _engine.skipped.length;
      4|    _lastProgressFailed = _engine.failed.length;
      1|    _lastProgressMessage = message;
      1|    _lastProgressSuffix = suffix;
       |
      1|    if (suffix != null) message += suffix;
       |    if (color == null) color = '';
      2|    var duration = _stopwatch.elapsed;
      1|    var buffer = new StringBuffer();
       |
       |    // \r moves back to the beginning of the current line.
      3|    buffer.write('${_timeString(duration)} ');
      2|    buffer.write(_green);
      1|    buffer.write('+');
      4|    buffer.write(_engine.passed.length);
      2|    buffer.write(_noColor);
       |
      3|    if (_engine.skipped.isNotEmpty) {
      0|      buffer.write(_yellow);
      0|      buffer.write(' ~');
      0|      buffer.write(_engine.skipped.length);
      0|      buffer.write(_noColor);
       |    }
       |
      3|    if (_engine.failed.isNotEmpty) {
      2|      buffer.write(_red);
      1|      buffer.write(' -');
      4|      buffer.write(_engine.failed.length);
      2|      buffer.write(_noColor);
       |    }
       |
      1|    buffer.write(': ');
      1|    buffer.write(color);
      1|    buffer.write(message);
      2|    buffer.write(_noColor);
       |
      2|    print(buffer.toString());
       |  }
       |
       |  /// Returns a representation of [duration] as `MM:SS`.
       |  String _timeString(Duration duration) {
      3|    return "${duration.inMinutes.toString().padLeft(2, '0')}:"
      5|        "${(duration.inSeconds % 60).toString().padLeft(2, '0')}";
       |  }
       |
       |  /// Returns a description of [liveTest].
       |  ///
       |  /// This differs from the test's own description in that it may also include
       |  /// the suite's name.
       |  String _description(LiveTest liveTest) {
      2|    var name = liveTest.test.name;
       |
      1|    if (_printPath &&
      0|        liveTest.suite is! LoadSuite &&
      0|        liveTest.suite.path != null) {
      0|      name = "${liveTest.suite.path}: $name";
       |    }
       |
      1|    if (_printPlatform && liveTest.suite.platform != null) {
      0|      name = "[${liveTest.suite.platform.name}] $name";
       |    }
       |
      2|    if (liveTest.suite is LoadSuite) name = "$_bold$_gray$name$_noColor";
       |
       |    return name;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/runner_suite.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../backend/group.dart';
       |import '../backend/operating_system.dart';
       |import '../backend/suite.dart';
       |import '../backend/test.dart';
       |import '../backend/test_platform.dart';
       |import '../utils.dart';
       |import 'configuration/suite.dart';
       |import 'environment.dart';
       |
       |/// A suite produced and consumed by the test runner that has runner-specific
       |/// logic and lifecycle management.
       |///
       |/// This is separated from [Suite] because the backend library (which will
       |/// eventually become its own package) is primarily for test code itself to use,
       |/// for which the [RunnerSuite] APIs don't make sense.
       |///
       |/// A [RunnerSuite] can be produced and controlled using a
       |/// [RunnerSuiteController].
       |class RunnerSuite extends Suite {
       |  final RunnerSuiteController _controller;
       |
       |  /// The environment in which this suite runs.
      0|  Environment get environment => _controller._environment;
       |
       |  /// The configuration for this suite.
      2|  SuiteConfiguration get config => _controller._config;
       |
       |  /// Whether the suite is paused for debugging.
       |  ///
       |  /// When using a dev inspector, this may also mean that the entire browser is
       |  /// paused.
      0|  bool get isDebugging => _controller._isDebugging;
       |
       |  /// A broadcast stream that emits an event whenever the suite is paused for
       |  /// debugging or resumed afterwards.
       |  ///
       |  /// The event is `true` when debugging starts and `false` when it ends.
      0|  Stream<bool> get onDebugging => _controller._onDebuggingController.stream;
       |
       |  /// A shortcut constructor for creating a [RunnerSuite] that never goes into
       |  /// debugging mode.
       |  factory RunnerSuite(
       |      Environment environment, SuiteConfiguration config, Group group,
       |      {String path,
       |      TestPlatform platform,
       |      OperatingSystem os,
       |      AsyncFunction onClose}) {
      1|    var controller = new RunnerSuiteController(environment, config, group,
       |        path: path, platform: platform, os: os, onClose: onClose);
      1|    return controller.suite;
       |  }
       |
       |  RunnerSuite._(this._controller, Group group, String path,
       |      TestPlatform platform, OperatingSystem os)
      1|      : super(group, path: path, platform: platform, os: os);
       |
       |  RunnerSuite filter(bool callback(Test test)) {
      0|    var filtered = group.filter(callback);
      0|    filtered ??= new Group.root([], metadata: metadata);
      0|    return new RunnerSuite._(_controller, filtered, path, platform, os);
       |  }
       |
       |  /// Closes the suite and releases any resources associated with it.
      2|  Future close() => _controller._close();
       |}
       |
       |/// A class that exposes and controls a [RunnerSuite].
       |class RunnerSuiteController {
       |  /// The suite controlled by this controller.
      1|  RunnerSuite get suite => _suite;
       |  RunnerSuite _suite;
       |
       |  /// The backing value for [suite.environment].
       |  final Environment _environment;
       |
       |  /// The configuration for this suite.
       |  final SuiteConfiguration _config;
       |
       |  /// The function to call when the suite is closed.
       |  final AsyncFunction _onClose;
       |
       |  /// The backing value for [suite.isDebugging].
       |  bool _isDebugging = false;
       |
       |  /// The controller for [suite.onDebugging].
       |  final _onDebuggingController = new StreamController<bool>.broadcast();
       |
       |  RunnerSuiteController(this._environment, this._config, Group group,
       |      {String path,
       |      TestPlatform platform,
       |      OperatingSystem os,
       |      AsyncFunction onClose})
      1|      : _onClose = onClose {
      2|    _suite = new RunnerSuite._(this, group, path, platform, os);
       |  }
       |
       |  /// Sets whether the suite is paused for debugging.
       |  ///
       |  /// If this is different than [suite.isDebugging], this will automatically
       |  /// send out an event along [suite.onDebugging].
       |  void setDebugging(bool debugging) {
      0|    if (debugging == _isDebugging) return;
      0|    _isDebugging = debugging;
      0|    _onDebuggingController.add(debugging);
       |  }
       |
       |  /// The backing function for [suite.close].
      2|  Future _close() => _closeMemo.runOnce(() async {
      2|        _onDebuggingController.close();
      1|        if (_onClose != null) await _onClose();
      1|      });
       |  final _closeMemo = new AsyncMemoizer();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/utils.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:convert';
       |import 'dart:math' as math;
       |import 'dart:typed_data';
       |
       |import 'package:async/async.dart' hide StreamQueue;
       |import 'package:matcher/matcher.dart';
       |import 'package:path/path.dart' as p;
       |import 'package:stack_trace/stack_trace.dart';
       |import 'package:term_glyph/term_glyph.dart' as glyph;
       |
       |import 'backend/invoker.dart';
       |import 'backend/operating_system.dart';
       |import 'util/stream_queue.dart';
       |
       |/// The maximum console line length.
       |const _lineLength = 100;
       |
       |/// A typedef for a possibly-asynchronous function.
       |///
       |/// The return type should only ever by [Future] or void.
       |typedef AsyncFunction();
       |
       |/// A typedef for a zero-argument callback function.
       |typedef void Callback();
       |
       |/// A transformer that decodes bytes using UTF-8 and splits them on newlines.
       |final lineSplitter = new StreamTransformer<List<int>, String>(
       |    (stream, cancelOnError) => stream
       |        .transform(UTF8.decoder)
       |        .transform(const LineSplitter())
       |        .listen(null, cancelOnError: cancelOnError));
       |
       |/// A regular expression to match the exception prefix that some exceptions'
       |/// [Object.toString] values contain.
       |final _exceptionPrefix = new RegExp(r'^([A-Z][a-zA-Z]*)?(Exception|Error): ');
       |
       |/// A regular expression matching a single vowel.
       |final _vowel = new RegExp('[aeiou]');
       |
       |/// Directories that are specific to OS X.
       |///
       |/// This is used to try to distinguish OS X and Linux in [currentOSGuess].
       |final _macOSDirectories = new Set<String>.from(
       |    ["/Applications", "/Library", "/Network", "/System", "/Users"]);
       |
       |/// Returns the best guess for the current operating system without using
       |/// `dart:io`.
       |///
       |/// This is useful for running test files directly and skipping tests as
       |/// appropriate. The only OS-specific information we have is the current path,
       |/// which we try to use to figure out the OS.
       |final OperatingSystem currentOSGuess = (() {
      3|  if (p.style == p.Style.url) return OperatingSystem.none;
      3|  if (p.style == p.Style.windows) return OperatingSystem.windows;
      4|  if (_macOSDirectories.any(p.current.startsWith)) return OperatingSystem.macOS;
       |  return OperatingSystem.linux;
       |})();
       |
       |/// A regular expression matching a hyphenated identifier.
       |///
       |/// This is like a standard Dart identifier, except that it can also contain
       |/// hyphens.
       |final hyphenatedIdentifier = new RegExp(r"[a-zA-Z_-][a-zA-Z0-9_-]*");
       |
       |/// Like [hyphenatedIdentifier], but anchored so that it must match the entire
       |/// string.
       |final anchoredHyphenatedIdentifier =
       |    new RegExp("^${hyphenatedIdentifier.pattern}\$");
       |
       |/// A pair of values.
       |class Pair<E, F> {
       |  E first;
       |  F last;
       |
      0|  Pair(this.first, this.last);
       |
      0|  String toString() => '($first, $last)';
       |
       |  bool operator ==(other) {
      0|    if (other is! Pair) return false;
      0|    return other.first == first && other.last == last;
       |  }
       |
      0|  int get hashCode => first.hashCode ^ last.hashCode;
       |}
       |
       |/// Get a string description of an exception.
       |///
       |/// Many exceptions include the exception class name at the beginning of their
       |/// [toString], so we remove that if it exists.
       |String getErrorMessage(error) =>
      0|    error.toString().replaceFirst(_exceptionPrefix, '');
       |
       |/// Indent each line in [string] by [size] spaces.
       |///
       |/// If [first] is passed, it's used in place of the first line's indentation and
       |/// [size] defaults to `first.length`. Otherwise, [size] defaults to 2.
       |String indent(String string, {int size, String first}) {
      1|  size ??= first == null ? 2 : first.length;
      2|  return prefixLines(string, " " * size, first: first);
       |}
       |
       |/// Returns a sentence fragment listing the elements of [iter].
       |///
       |/// This converts each element of [iter] to a string and separates them with
       |/// commas and/or [conjunction] where appropriate. The [conjunction] defaults to
       |/// "and".
       |String toSentence(Iterable iter, {String conjunction}) {
      0|  if (iter.length == 1) return iter.first.toString();
       |
      0|  var result = iter.take(iter.length - 1).join(", ");
      0|  if (iter.length > 2) result += ",";
      0|  return "$result ${conjunction ?? 'and'} ${iter.last}";
       |}
       |
       |/// Returns [name] if [number] is 1, or the plural of [name] otherwise.
       |///
       |/// By default, this just adds "s" to the end of [name] to get the plural. If
       |/// [plural] is passed, that's used instead.
       |String pluralize(String name, int number, {String plural}) {
      0|  if (number == 1) return name;
       |  if (plural != null) return plural;
      0|  return '${name}s';
       |}
       |
       |/// Returns [noun] with an indefinite article ("a" or "an") added, based on
       |/// whether its first letter is a vowel.
      0|String a(String noun) => noun.startsWith(_vowel) ? "an $noun" : "a $noun";
       |
       |/// Wraps [text] so that it fits within [lineLength], which defaults to 100
       |/// characters.
       |///
       |/// This preserves existing newlines and doesn't consider terminal color escapes
       |/// part of a word's length.
       |String wordWrap(String text, {int lineLength}) {
       |  if (lineLength == null) lineLength = _lineLength;
      0|  return text.split("\n").map((originalLine) {
      0|    var buffer = new StringBuffer();
       |    var lengthSoFar = 0;
      0|    for (var word in originalLine.split(" ")) {
      0|      var wordLength = withoutColors(word).length;
      0|      if (wordLength > lineLength) {
      0|        if (lengthSoFar != 0) buffer.writeln();
      0|        buffer.writeln(word);
      0|      } else if (lengthSoFar == 0) {
      0|        buffer.write(word);
       |        lengthSoFar = wordLength;
      0|      } else if (lengthSoFar + 1 + wordLength > lineLength) {
      0|        buffer.writeln();
      0|        buffer.write(word);
       |        lengthSoFar = wordLength;
       |      } else {
      0|        buffer.write(" $word");
      0|        lengthSoFar += 1 + wordLength;
       |      }
       |    }
      0|    return buffer.toString();
      0|  }).join("\n");
       |}
       |
       |/// A regular expression matching terminal color codes.
       |final _colorCode = new RegExp('\u001b\\[[0-9;]+m');
       |
       |/// Returns [str] without any color codes.
      0|String withoutColors(String str) => str.replaceAll(_colorCode, '');
       |
       |/// Returns [stackTrace] converted to a [Chain] with all irrelevant frames
       |/// folded together.
       |///
       |/// If [verbose] is `true`, returns the chain for [stackTrace] unmodified.
       |Chain terseChain(StackTrace stackTrace, {bool verbose: false}) {
      0|  if (verbose) return new Chain.forTrace(stackTrace);
      2|  return new Chain.forTrace(stackTrace).foldFrames(
      4|      (frame) => frame.package == 'test' || frame.package == 'stream_channel',
       |      terse: true);
       |}
       |
       |/// Converts [stackTrace] to a [Chain] following the test's configuration.
       |Chain testChain(StackTrace stackTrace) {
       |  // TODO(nweiz): Follow more configuration when #527 is fixed.
      0|  return terseChain(stackTrace,
      0|      verbose: Invoker.current.liveTest.test.metadata.verboseTrace);
       |}
       |
       |/// Flattens nested [Iterable]s inside an [Iterable] into a single [List]
       |/// containing only non-[Iterable] elements.
       |List flatten(Iterable nested) {
      0|  var result = [];
       |  helper(iter) {
      0|    for (var element in iter) {
      0|      if (element is Iterable) {
      0|        helper(element);
       |      } else {
      0|        result.add(element);
       |      }
       |    }
       |  }
       |
      0|  helper(nested);
       |  return result;
       |}
       |
       |/// Like [runZoned], but [zoneValues] are set for the callbacks in
       |/// [zoneSpecification] and [onError].
       |runZonedWithValues(body(),
       |    {Map zoneValues, ZoneSpecification zoneSpecification, Function onError}) {
      1|  return runZoned(() {
      1|    return runZoned(body,
       |        zoneSpecification: zoneSpecification, onError: onError);
       |  }, zoneValues: zoneValues);
       |}
       |
       |/// Truncates [text] to fit within [maxLength].
       |///
       |/// This will try to truncate along word boundaries and preserve words both at
       |/// the beginning and the end of [text].
       |String truncate(String text, int maxLength) {
       |  // Return the full message if it fits.
      0|  if (text.length <= maxLength) return text;
       |
       |  // If we can fit the first and last three words, do so.
      0|  var words = text.split(' ');
      0|  if (words.length > 1) {
      0|    var i = words.length;
      0|    var length = words.first.length + 4;
       |    do {
      0|      i--;
      0|      length += 1 + words[i].length;
      0|    } while (length <= maxLength && i > 0);
      0|    if (length > maxLength || i == 0) i++;
      0|    if (i < words.length - 4) {
       |      // Require at least 3 words at the end.
      0|      var buffer = new StringBuffer();
      0|      buffer.write(words.first);
      0|      buffer.write(' ...');
      0|      for (; i < words.length; i++) {
      0|        buffer.write(' ');
      0|        buffer.write(words[i]);
       |      }
      0|      return buffer.toString();
       |    }
       |  }
       |
       |  // Otherwise truncate to return the trailing text, but attempt to start at
       |  // the beginning of a word.
      0|  var result = text.substring(text.length - maxLength + 4);
      0|  var firstSpace = result.indexOf(' ');
      0|  if (firstSpace > 0) {
      0|    result = result.substring(firstSpace);
       |  }
      0|  return '...$result';
       |}
       |
       |/// Returns a human-friendly representation of [duration].
       |String niceDuration(Duration duration) {
      0|  var minutes = duration.inMinutes;
      0|  var seconds = duration.inSeconds % 60;
      0|  var decaseconds = (duration.inMilliseconds % 1000) ~/ 100;
       |
      0|  var buffer = new StringBuffer();
      0|  if (minutes != 0) buffer.write("$minutes minutes");
       |
      0|  if (minutes == 0 || seconds != 0) {
      0|    if (minutes != 0) buffer.write(", ");
      0|    buffer.write(seconds);
      0|    if (decaseconds != 0) buffer.write(".$decaseconds");
      0|    buffer.write(" seconds");
       |  }
       |
      0|  return buffer.toString();
       |}
       |
       |/// Returns the first value [stream] emits, or `null` if [stream] closes before
       |/// emitting a value.
       |Future maybeFirst(Stream stream) {
      0|  var completer = new Completer();
       |
       |  var subscription;
      0|  subscription = stream.listen((data) {
      0|    completer.complete(data);
      0|    subscription.cancel();
       |  }, onError: (error, stackTrace) {
      0|    completer.completeError(error, stackTrace);
      0|    subscription.cancel();
       |  }, onDone: () {
      0|    completer.complete();
       |  });
       |
      0|  return completer.future;
       |}
       |
       |/// Returns a [CancelableOperation] that returns the next value of [queue]
       |/// unless it's canceled.
       |///
       |/// If the operation is canceled, [queue] is not moved forward at all. Note that
       |/// it's not safe to call further methods on [queue] until this operation has
       |/// either completed or been canceled.
       |CancelableOperation cancelableNext(StreamQueue queue) {
      0|  var fork = queue.fork();
       |  var canceled = false;
      0|  var completer = new CancelableCompleter(onCancel: () {
       |    canceled = true;
      0|    return fork.cancel(immediate: true);
       |  });
       |
      0|  completer.complete(fork.next.then((_) {
      0|    fork.cancel();
      0|    return canceled ? null : queue.next;
       |  }));
       |
      0|  return completer.operation;
       |}
       |
       |/// Returns a single-subscription stream that emits the results of [operations]
       |/// in the order they complete.
       |///
       |/// If the subscription is canceled, any pending operations are canceled as
       |/// well.
       |Stream/*<T>*/ inCompletionOrder/*<T>*/(
       |    Iterable<CancelableOperation/*<T>*/ > operations) {
      0|  var operationSet = operations.toSet();
      0|  var controller = new StreamController/*<T>*/(
       |      sync: true,
       |      onCancel: () {
      0|        return Future.wait(operationSet.map((operation) => operation.cancel()));
       |      });
       |
      0|  for (var operation in operationSet) {
      0|    operation.value
      0|        .then((value) => controller.add(value))
      0|        .catchError(controller.addError)
      0|        .whenComplete(() {
      0|      operationSet.remove(operation);
      0|      if (operationSet.isEmpty) controller.close();
       |    });
       |  }
       |
      0|  return controller.stream;
       |}
       |
       |/// Returns a stream that emits [error] and [stackTrace], then closes.
       |///
       |/// This is useful for adding errors to streams defined via `async*`.
       |Stream errorStream(error, StackTrace stackTrace) {
      0|  var controller = new StreamController();
      0|  controller.addError(error, stackTrace);
      0|  controller.close();
      0|  return controller.stream;
       |}
       |
       |/// Runs [fn] and discards its return value.
       |///
       |/// This is useful for making a block of code async without forcing the
       |/// containing method to return a future.
       |void invoke(fn()) {
      0|  fn();
       |}
       |
       |/// Runs [body] with special error-handling behavior.
       |///
       |/// Errors emitted [body] will still cause the current test to fail, but they
       |/// won't cause it to *stop*. In particular, they won't remove any outstanding
       |/// callbacks registered outside of [body].
       |///
       |/// This may only be called within a test.
       |Future errorsDontStopTest(body()) {
      0|  var completer = new Completer();
       |
      0|  Invoker.current.addOutstandingCallback();
      0|  Invoker.current.waitForOutstandingCallbacks(() {
      0|    new Future.sync(body).whenComplete(completer.complete);
      0|  }).then((_) => Invoker.current.removeOutstandingCallback());
       |
      0|  return completer.future;
       |}
       |
       |/// Returns a random base64 string containing [bytes] bytes of data.
       |///
       |/// [seed] is passed to [math.Random].
       |String randomBase64(int bytes, {int seed}) {
      0|  var random = new math.Random(seed);
      0|  var data = new Uint8List(bytes);
      0|  for (var i = 0; i < bytes; i++) {
      0|    data[i] = random.nextInt(256);
       |  }
      0|  return BASE64.encode(data);
       |}
       |
       |/// Throws an [ArgumentError] if [message] isn't recursively JSON-safe.
       |void ensureJsonEncodable(Object message) {
       |  if (message == null ||
      0|      message is String ||
      0|      message is num ||
      0|      message is bool) {
       |    // JSON-encodable, hooray!
      0|  } else if (message is List) {
      0|    for (var element in message) {
      0|      ensureJsonEncodable(element);
       |    }
      0|  } else if (message is Map) {
      0|    message.forEach((key, value) {
      0|      if (key is! String) {
      0|        throw new ArgumentError("$message can't be JSON-encoded.");
       |      }
       |
      0|      ensureJsonEncodable(value);
       |    });
       |  } else {
      0|    throw new ArgumentError.value("$message can't be JSON-encoded.");
       |  }
       |}
       |
       |/// Prepends a vertical bar to [text].
      0|String addBar(String text) => prefixLines(text, "${glyph.verticalLine} ",
      0|    first: "${glyph.downEnd} ", last: "${glyph.upEnd} ", single: "| ");
       |
       |/// Indents [text], and adds a bullet at the beginning.
       |String addBullet(String text) =>
      0|    prefixLines(text, "  ", first: "${glyph.bullet} ");
       |
       |/// Converts [strings] to a bulleted list.
      0|String bullet(Iterable<String> strings) => strings.map(addBullet).join("\n");
       |
       |/// Prepends each line in [text] with [prefix].
       |///
       |/// If [first] or [last] is passed, the first and last lines, respectively, are
       |/// prefixed with those instead. If [single] is passed, it's used if there's
       |/// only a single line; otherwise, [first], [last], or [prefix] is used, in that
       |/// order of precedence.
       |String prefixLines(String text, String prefix,
       |    {String first, String last, String single}) {
       |  first ??= prefix;
       |  last ??= prefix;
       |  single ??= first ?? last ?? prefix;
       |
      1|  var lines = text.split('\n');
      3|  if (lines.length == 1) return "$single$text";
       |
      3|  var buffer = new StringBuffer("$first${lines.first}\n");
       |
       |  // Write out all but the first and last lines with [prefix].
      6|  for (var line in lines.skip(1).take(lines.length - 2)) {
      2|    buffer.writeln("$prefix$line");
       |  }
      3|  buffer.write("$last${lines.last}");
      1|  return buffer.toString();
       |}
       |
       |/// Returns a pretty-printed representation of [value].
       |///
       |/// The matcher package doesn't expose its pretty-print function directly, but
       |/// we can use it through StringDescription.
       |String prettyPrint(value) =>
      3|    new StringDescription().addDescriptionOf(value).toString();
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/expect.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../backend/closed_exception.dart';
       |import '../backend/invoker.dart';
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |
       |/// A future that emits `null`.
       |///
       |/// We cache and re-use this value to avoid adding a new microtask hit for each
       |/// call to `expect()`.
       |final _emptyFuture = new Future.value();
       |
       |/// An exception thrown when a test assertion fails.
       |class TestFailure {
       |  final String message;
       |
      1|  TestFailure(this.message);
       |
      1|  String toString() => message;
       |}
       |
       |/// The type used for functions that can be used to build up error reports
       |/// upon failures in [expect].
       |@Deprecated("Will be removed in 0.13.0.")
       |typedef String ErrorFormatter(
       |    actual, Matcher matcher, String reason, Map matchState, bool verbose);
       |
       |/// Assert that [actual] matches [matcher].
       |///
       |/// This is the main assertion function. [reason] is optional and is typically
       |/// not supplied, as a reason is generated from [matcher]; if [reason]
       |/// is included it is appended to the reason generated by the matcher.
       |///
       |/// [matcher] can be a value in which case it will be wrapped in an
       |/// [equals] matcher.
       |///
       |/// If the assertion fails a [TestFailure] is thrown.
       |///
       |/// If [skip] is a String or `true`, the assertion is skipped. The arguments are
       |/// still evaluated, but [actual] is not verified to match [matcher]. If
       |/// [actual] is a [Future], the test won't complete until the future emits a
       |/// value.
       |///
       |/// If [skip] is a string, it should explain why the assertion is skipped; this
       |/// reason will be printed when running the test.
       |///
       |/// In some cases extra diagnostic info can be produced on failure (for
       |/// example, stack traces on mismatched exceptions). To enable these,
       |/// [verbose] should be specified as `true`.
       |///
       |/// Certain matchers, like [completion] and [throwsA], either match or fail
       |/// asynchronously. When you use [expect] with these matchers, it ensures that
       |/// the test doesn't complete until the matcher has either matched or failed. If
       |/// you want to wait for the matcher to complete before continuing the test, you
       |/// can call [expectLater] instead and `await` the result.
       |void expect(actual, matcher,
       |    {String reason,
       |    skip,
       |    @Deprecated("Will be removed in 0.13.0.") bool verbose: false,
       |    @Deprecated("Will be removed in 0.13.0.") ErrorFormatter formatter}) {
      1|  _expect(actual, matcher,
       |      reason: reason, skip: skip, verbose: verbose, formatter: formatter);
       |}
       |
       |/// Just like [expect], but returns a [Future] that completes when the matcher
       |/// has finished matching.
       |///
       |/// For the [completes] and [completion] matchers, as well as [throwsA] and
       |/// related matchers when they're matched against a [Future], the returned
       |/// future completes when the matched future completes. For the [prints]
       |/// matcher, it completes when the future returned by the callback completes.
       |/// Otherwise, it completes immediately.
       |///
       |/// If the matcher fails asynchronously, that failure is piped to the returned
       |/// future where it can be handled by user code.
       |Future expectLater(actual, matcher, {String reason, skip}) =>
      0|    _expect(actual, matcher, reason: reason, skip: skip);
       |
       |/// The implementation of [expect] and [expectLater].
       |Future _expect(actual, matcher,
       |    {String reason, skip, bool verbose: false, ErrorFormatter formatter}) {
       |  formatter ??= (actual, matcher, reason, matchState, verbose) {
      1|    var mismatchDescription = new StringDescription();
      1|    matcher.describeMismatch(actual, mismatchDescription, matchState, verbose);
       |
      2|    return formatFailure(matcher, actual, mismatchDescription.toString(),
       |        reason: reason);
       |  };
       |
      1|  if (Invoker.current == null) {
      0|    throw new StateError("expect() may only be called within a test.");
       |  }
       |
      2|  if (Invoker.current.closed) throw new ClosedException();
       |
      0|  if (skip != null && skip is! bool && skip is! String) {
      0|    throw new ArgumentError.value(skip, "skip", "must be a bool or a String");
       |  }
       |
      1|  matcher = wrapMatcher(matcher);
      0|  if (skip != null && skip != false) {
       |    String message;
      0|    if (skip is String) {
      0|      message = "Skip expect: $skip";
       |    } else if (reason != null) {
      0|      message = "Skip expect ($reason).";
       |    } else {
      0|      var description = new StringDescription().addDescriptionOf(matcher);
      0|      message = "Skip expect ($description).";
       |    }
       |
      0|    Invoker.current.skip(message);
      0|    return _emptyFuture;
       |  }
       |
      1|  if (matcher is AsyncMatcher) {
       |    // Avoid async/await so that expect() throws synchronously when possible.
      0|    var result = matcher.matchAsync(actual);
      0|    expect(
       |        result,
      0|        anyOf([
      0|          equals(null),
      0|          new isInstanceOf<Future>(),
      0|          new isInstanceOf<String>()
       |        ]),
       |        reason: "matchAsync() may only return a String, a Future, or null.");
       |
      0|    if (result is String) {
      0|      fail(formatFailure(matcher, actual, result, reason: reason));
      0|    } else if (result is Future) {
      0|      Invoker.current.addOutstandingCallback();
      0|      return result.then((realResult) {
       |        if (realResult == null) return;
      0|        fail(formatFailure(matcher, actual, realResult, reason: reason));
      0|      }).whenComplete(() {
       |        // Always remove this, in case the failure is caught and handled
       |        // gracefully.
      0|        Invoker.current.removeOutstandingCallback();
       |      });
       |    }
       |
      0|    return _emptyFuture;
       |  }
       |
      1|  var matchState = {};
       |  try {
      2|    if (matcher.matches(actual, matchState)) return _emptyFuture;
       |  } catch (e, trace) {
      0|    reason ??= '$e at $trace';
       |  }
      2|  fail(formatter(actual, matcher, reason, matchState, verbose));
      0|  return _emptyFuture;
       |}
       |
       |/// Convenience method for throwing a new [TestFailure] with the provided
       |/// [message].
      1|void fail(String message) => throw new TestFailure(message);
       |
       |// The default error formatter.
       |@Deprecated("Will be removed in 0.13.0.")
       |String formatFailure(Matcher expected, actual, String which, {String reason}) {
      1|  var buffer = new StringBuffer();
      3|  buffer.writeln(indent(prettyPrint(expected), first: 'Expected: '));
      3|  buffer.writeln(indent(prettyPrint(actual), first: '  Actual: '));
      1|  if (which.isNotEmpty) buffer.writeln(indent(which, first: '   Which: '));
      0|  if (reason != null) buffer.writeln(reason);
      1|  return buffer.toString();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/expect_async.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../backend/invoker.dart';
       |import 'expect.dart';
       |
       |/// An object used to detect unpassed arguments.
       |const _PLACEHOLDER = const Object();
       |
       |// Function types returned by expectAsync# methods.
       |
       |typedef T Func0<T>();
       |typedef T Func1<T, A>([A a]);
       |typedef T Func2<T, A, B>([A a, B b]);
       |typedef T Func3<T, A, B, C>([A a, B b, C c]);
       |typedef T Func4<T, A, B, C, D>([A a, B b, C c, D d]);
       |typedef T Func5<T, A, B, C, D, E>([A a, B b, C c, D d, E e]);
       |typedef T Func6<T, A, B, C, D, E, F>([A a, B b, C c, D d, E e, F f]);
       |
       |// Functions used to check how many arguments a callback takes. We can't use the
       |// previous functions for this, because (a) {} is not a subtype of
       |// ([dynamic]) -> dynamic.
       |
       |typedef _Func0();
       |typedef _Func1(a);
       |typedef _Func2(a, b);
       |typedef _Func3(a, b, c);
       |typedef _Func4(a, b, c, d);
       |typedef _Func5(a, b, c, d, e);
       |typedef _Func6(a, b, c, d, e, f);
       |
       |typedef bool _IsDoneCallback();
       |
       |/// A wrapper for a function that ensures that it's called the appropriate
       |/// number of times.
       |///
       |/// The containing test won't be considered to have completed successfully until
       |/// this function has been called the appropriate number of times.
       |///
       |/// The wrapper function is accessible via [func]. It supports up to six
       |/// optional and/or required positional arguments, but no named arguments.
       |class _ExpectedFunction<T> {
       |  /// The wrapped callback.
       |  final Function _callback;
       |
       |  /// The minimum number of calls that are expected to be made to the function.
       |  ///
       |  /// If fewer calls than this are made, the test will fail.
       |  final int _minExpectedCalls;
       |
       |  /// The maximum number of calls that are expected to be made to the function.
       |  ///
       |  /// If more calls than this are made, the test will fail.
       |  final int _maxExpectedCalls;
       |
       |  /// A callback that should return whether the function is not expected to have
       |  /// any more calls.
       |  ///
       |  /// This will be called after every time the function is run. The test case
       |  /// won't be allowed to terminate until it returns `true`.
       |  ///
       |  /// This may be `null`. If so, the function is considered to be done after
       |  /// it's been run once.
       |  final _IsDoneCallback _isDone;
       |
       |  /// A descriptive name for the function.
       |  final String _id;
       |
       |  /// An optional description of why the function is expected to be called.
       |  ///
       |  /// If not passed, this will be an empty string.
       |  final String _reason;
       |
       |  /// The number of times the function has been called.
       |  int _actualCalls = 0;
       |
       |  /// The test invoker in which this function was wrapped.
      0|  Invoker get _invoker => _zone[#test.invoker];
       |
       |  /// The zone in which this function was wrapped.
       |  final Zone _zone;
       |
       |  /// Whether this function has been called the requisite number of times.
       |  bool _complete;
       |
       |  /// Wraps [callback] in a function that asserts that it's called at least
       |  /// [minExpected] times and no more than [maxExpected] times.
       |  ///
       |  /// If passed, [id] is used as a descriptive name fo the function and [reason]
       |  /// as a reason it's expected to be called. If [isDone] is passed, the test
       |  /// won't be allowed to complete until it returns `true`.
       |  _ExpectedFunction(Function callback, int minExpected, int maxExpected,
       |      {String id, String reason, bool isDone()})
       |      : this._callback = callback,
       |        _minExpectedCalls = minExpected,
       |        _maxExpectedCalls =
      0|            (maxExpected == 0 && minExpected > 0) ? minExpected : maxExpected,
       |        this._isDone = isDone,
      0|        this._reason = reason == null ? '' : '\n$reason',
      0|        this._zone = Zone.current,
      0|        this._id = _makeCallbackId(id, callback) {
      0|    if (_invoker == null) {
      0|      throw new StateError("[expectAsync] was called outside of a test.");
      0|    } else if (maxExpected > 0 && minExpected > maxExpected) {
      0|      throw new ArgumentError("max ($maxExpected) may not be less than count "
      0|          "($minExpected).");
       |    }
       |
      0|    if (isDone != null || minExpected > 0) {
      0|      _invoker.addOutstandingCallback();
      0|      _complete = false;
       |    } else {
      0|      _complete = true;
       |    }
       |  }
       |
       |  /// Tries to find a reasonable name for [callback].
       |  ///
       |  /// If [id] is passed, uses that. Otherwise, tries to determine a name from
       |  /// calling `toString`. If no name can be found, returns the empty string.
       |  static String _makeCallbackId(String id, Function callback) {
      0|    if (id != null) return "$id ";
       |
       |    // If the callback is not an anonymous closure, try to get the
       |    // name.
      0|    var toString = callback.toString();
       |    var prefix = "Function '";
      0|    var start = toString.indexOf(prefix);
      0|    if (start == -1) return '';
       |
      0|    start += prefix.length;
      0|    var end = toString.indexOf("'", start);
      0|    if (end == -1) return '';
      0|    return "${toString.substring(start, end)} ";
       |  }
       |
       |  /// Returns a function that has the same number of positional arguments as the
       |  /// wrapped function (up to a total of 6).
       |  Function get func {
      0|    if (_callback is _Func6) return max6;
      0|    if (_callback is _Func5) return max5;
      0|    if (_callback is _Func4) return max4;
      0|    if (_callback is _Func3) return max3;
      0|    if (_callback is _Func2) return max2;
      0|    if (_callback is _Func1) return max1;
      0|    if (_callback is _Func0) return max0;
       |
      0|    _invoker.removeOutstandingCallback();
      0|    throw new ArgumentError(
       |        'The wrapped function has more than 6 required arguments');
       |  }
       |
       |  // This indirection is critical. It ensures the returned function has an
       |  // argument count of zero.
      0|  T max0() => max6();
       |
      0|  T max1([Object a0 = _PLACEHOLDER]) => max6(a0);
       |
      0|  T max2([Object a0 = _PLACEHOLDER, Object a1 = _PLACEHOLDER]) => max6(a0, a1);
       |
       |  T max3(
       |          [Object a0 = _PLACEHOLDER,
       |          Object a1 = _PLACEHOLDER,
       |          Object a2 = _PLACEHOLDER]) =>
      0|      max6(a0, a1, a2);
       |
       |  T max4(
       |          [Object a0 = _PLACEHOLDER,
       |          Object a1 = _PLACEHOLDER,
       |          Object a2 = _PLACEHOLDER,
       |          Object a3 = _PLACEHOLDER]) =>
      0|      max6(a0, a1, a2, a3);
       |
       |  T max5(
       |          [Object a0 = _PLACEHOLDER,
       |          Object a1 = _PLACEHOLDER,
       |          Object a2 = _PLACEHOLDER,
       |          Object a3 = _PLACEHOLDER,
       |          Object a4 = _PLACEHOLDER]) =>
      0|      max6(a0, a1, a2, a3, a4);
       |
       |  T max6(
       |          [Object a0 = _PLACEHOLDER,
       |          Object a1 = _PLACEHOLDER,
       |          Object a2 = _PLACEHOLDER,
       |          Object a3 = _PLACEHOLDER,
       |          Object a4 = _PLACEHOLDER,
       |          Object a5 = _PLACEHOLDER]) =>
      0|      _run([a0, a1, a2, a3, a4, a5].where((a) => a != _PLACEHOLDER));
       |
       |  /// Runs the wrapped function with [args] and returns its return value.
       |  T _run(Iterable args) {
       |    // Note that in the old test, this returned `null` if it encountered an
       |    // error, where now it just re-throws that error because Zone machinery will
       |    // pass it to the invoker anyway.
       |    try {
      0|      _actualCalls++;
      0|      if (_invoker.liveTest.state.shouldBeDone) {
      0|        throw 'Callback ${_id}called ($_actualCalls) after test case '
      0|            '${_invoker.liveTest.test.name} had already completed.$_reason';
      0|      } else if (_maxExpectedCalls >= 0 && _actualCalls > _maxExpectedCalls) {
      0|        throw new TestFailure('Callback ${_id}called more times than expected '
      0|            '($_maxExpectedCalls).$_reason');
       |      }
       |
      0|      return Function.apply(_callback, args.toList()) as T;
       |    } catch (error, stackTrace) {
      0|      _zone.handleUncaughtError(error, stackTrace);
       |      return null;
       |    } finally {
      0|      _afterRun();
       |    }
       |  }
       |
       |  /// After each time the function is run, check to see if it's complete.
       |  void _afterRun() {
      0|    if (_complete) return;
      0|    if (_minExpectedCalls > 0 && _actualCalls < _minExpectedCalls) return;
      0|    if (_isDone != null && !_isDone()) return;
       |
       |    // Mark this callback as complete and remove it from the test case's
       |    // oustanding callback count; if that hits zero the test is done.
      0|    _complete = true;
      0|    _invoker.removeOutstandingCallback();
       |  }
       |}
       |
       |/// This function is deprecated because it doesn't work well with strong mode.
       |/// Use [expectAsync0], [expectAsync1],
       |/// [expectAsync2], [expectAsync3], [expectAsync4], [expectAsync5], or
       |/// [expectAsync6] instead.
       |@Deprecated("Will be removed in 0.13.0")
       |Function expectAsync(Function callback,
       |    {int count: 1, int max: 0, String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction(callback, count, max, id: id, reason: reason)
      0|      .func;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 0 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with zero arguments. See also
       |/// [expectAsync1], [expectAsync2], [expectAsync3], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
       |Func0<dynamic/*=T*/ > expectAsync0/*<T>*/(dynamic/*=T*/ callback(),
       |    {int count: 1, int max: 0, String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync0() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, count, max,
       |          id: id, reason: reason)
      0|      .max0;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 1 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with one argument. See also
       |/// [expectAsync0], [expectAsync2], [expectAsync3], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
       |Func1<dynamic/*=T*/, dynamic/*=A*/ > expectAsync1/*<T, A>*/(
       |    dynamic/*=T*/ callback(dynamic/*=A*/ a),
       |    {int count: 1,
       |    int max: 0,
       |    String id,
       |    String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync1() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, count, max,
       |          id: id, reason: reason)
      0|      .max1;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 2 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with two arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync3], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
       |Func2<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/ > expectAsync2/*<T, A, B>*/(
       |    dynamic/*=T*/ callback(dynamic/*=A*/ a, dynamic/*=B*/ b),
       |    {int count: 1,
       |    int max: 0,
       |    String id,
       |    String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync2() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, count, max,
       |          id: id, reason: reason)
      0|      .max2;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 3 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with three arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
       |Func3<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/ >
       |    expectAsync3/*<T, A, B, C>*/(
       |        dynamic/*=T*/ callback(
       |            dynamic/*=A*/ a, dynamic/*=B*/ b, dynamic/*=C*/ c),
       |        {int count: 1,
       |        int max: 0,
       |        String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync3() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, count, max,
       |          id: id, reason: reason)
      0|      .max3;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 4 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with four arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync3],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
       |Func4<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/,
       |        dynamic/*=D*/ >
       |    expectAsync4/*<T, A, B, C, D>*/(
       |        dynamic/*=T*/ callback(
       |            dynamic/*=A*/ a, dynamic/*=B*/ b, dynamic/*=C*/ c, dynamic/*=D*/ d),
       |        {int count: 1,
       |        int max: 0,
       |        String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync4() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, count, max,
       |          id: id, reason: reason)
      0|      .max4;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 5 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with five arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync3],
       |/// [expectAsync4], and [expectAsync6] for callbacks with different arity.
       |Func5<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/, dynamic/*=D*/,
       |        dynamic/*=E*/ >
       |    expectAsync5/*<T, A, B, C, D, E>*/(
       |        dynamic/*=T*/ callback(dynamic/*=A*/ a, dynamic/*=B*/ b,
       |            dynamic/*=C*/ c, dynamic/*=D*/ d, dynamic/*=E*/ e),
       |        {int count: 1,
       |        int max: 0,
       |        String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync5() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, count, max,
       |          id: id, reason: reason)
      0|      .max5;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 6 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with six arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync3],
       |/// [expectAsync4], and [expectAsync5] for callbacks with different arity.
       |Func6<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/, dynamic/*=D*/,
       |        dynamic/*=E*/, dynamic/*=F*/ >
       |    expectAsync6/*<T, A, B, C, D, E, F>*/(
       |        dynamic/*=T*/ callback(dynamic/*=A*/ a, dynamic/*=B*/ b,
       |            dynamic/*=C*/ c, dynamic/*=D*/ d, dynamic/*=E*/ e, dynamic/*=F*/ f),
       |        {int count: 1,
       |        int max: 0,
       |        String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError("expectAsync6() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, count, max,
       |          id: id, reason: reason)
      0|      .max6;
       |}
       |
       |/// This function is deprecated because it doesn't work well with strong mode.
       |/// Use [expectAsyncUntil0], [expectAsyncUntil1],
       |/// [expectAsyncUntil2], [expectAsyncUntil3], [expectAsyncUntil4],
       |/// [expectAsyncUntil5], or [expectAsyncUntil6] instead.
       |@Deprecated("Will be removed in 0.13.0")
       |Function expectAsyncUntil(Function callback, bool isDone(),
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .func;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 0 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with zero arguments. See also
       |/// [expectAsyncUntil1], [expectAsyncUntil2], [expectAsyncUntil3],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
       |Func0<dynamic/*=T*/ > expectAsyncUntil0/*<T>*/(
       |    dynamic/*=T*/ callback(), bool isDone(),
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil0() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max0;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 1 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with one argument. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil2], [expectAsyncUntil3],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
       |Func1<dynamic/*=T*/, dynamic/*=A*/ > expectAsyncUntil1/*<T, A>*/(
       |    dynamic/*=T*/ callback(dynamic/*=A*/ a), bool isDone(),
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil1() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max1;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 2 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with two arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil3],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
       |Func2<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/ >
       |    expectAsyncUntil2/*<T, A, B>*/(
       |        dynamic/*=T*/ callback(dynamic/*=A*/ a, dynamic/*=B*/ b), bool isDone(),
       |        {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil2() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max2;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 3 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with three arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
       |Func3<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/ >
       |    expectAsyncUntil3/*<T, A, B, C>*/(
       |        dynamic/*=T*/ callback(
       |            dynamic/*=A*/ a, dynamic/*=B*/ b, dynamic/*=C*/ c),
       |        bool isDone(),
       |        {String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil3() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max3;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 4 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with four arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil3], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
       |Func4<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/,
       |        dynamic/*=D*/ >
       |    expectAsyncUntil4/*<T, A, B, C, D>*/(
       |        dynamic/*=T*/ callback(
       |            dynamic/*=A*/ a, dynamic/*=B*/ b, dynamic/*=C*/ c, dynamic/*=D*/ d),
       |        bool isDone(),
       |        {String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil4() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max4;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 5 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with five arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil3], [expectAsyncUntil4], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
       |Func5<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/, dynamic/*=D*/,
       |        dynamic/*=E*/ >
       |    expectAsyncUntil5/*<T, A, B, C, D, E>*/(
       |        dynamic/*=T*/ callback(dynamic/*=A*/ a, dynamic/*=B*/ b,
       |            dynamic/*=C*/ c, dynamic/*=D*/ d, dynamic/*=E*/ e),
       |        bool isDone(),
       |        {String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil5() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max5;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 6 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with six arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil3], [expectAsyncUntil4], and [expectAsyncUntil5] for
       |/// callbacks with different arity.
       |Func6<dynamic/*=T*/, dynamic/*=A*/, dynamic/*=B*/, dynamic/*=C*/, dynamic/*=D*/,
       |        dynamic/*=E*/, dynamic/*=F*/ >
       |    expectAsyncUntil6/*<T, A, B, C, D, E, F>*/(
       |        dynamic/*=T*/ callback(dynamic/*=A*/ a, dynamic/*=B*/ b,
       |            dynamic/*=C*/ c, dynamic/*=D*/ d, dynamic/*=E*/ e, dynamic/*=F*/ f),
       |        bool isDone(),
       |        {String id,
       |        String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw new StateError(
       |        "expectAsyncUntil() may only be called within a test.");
       |  }
       |
      0|  return new _ExpectedFunction/*<T>*/(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max6;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/future_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |import 'expect.dart';
       |
       |/// Matches a [Future] that completes successfully with a value.
       |///
       |/// Note that this creates an asynchronous expectation. The call to `expect()`
       |/// that includes this will return immediately and execution will continue.
       |/// Later, when the future completes, the actual expectation will run.
       |///
       |/// To test that a Future completes with an exception, you can use [throws] and
       |/// [throwsA].
       |///
       |/// This returns an [AsyncMatcher], so [expect] won't complete until the matched
       |/// future does.
       |final Matcher completes = const _Completes(null);
       |
       |/// Matches a [Future] that completes succesfully with a value that matches
       |/// [matcher].
       |///
       |/// Note that this creates an asynchronous expectation. The call to
       |/// `expect()` that includes this will return immediately and execution will
       |/// continue. Later, when the future completes, the actual expectation will run.
       |///
       |/// To test that a Future completes with an exception, you can use [throws] and
       |/// [throwsA].
       |///
       |/// The [description] parameter is deprecated and shouldn't be used.
       |///
       |/// This returns an [AsyncMatcher], so [expect] won't complete until the matched
       |/// future does.
       |Matcher completion(matcher, [@deprecated String description]) =>
      0|    new _Completes(wrapMatcher(matcher));
       |
       |class _Completes extends AsyncMatcher {
       |  final Matcher _matcher;
       |
      0|  const _Completes(this._matcher);
       |
       |  // Avoid async/await so we synchronously start listening to [item].
       |  /*FutureOr<String>*/ matchAsync(item) {
      0|    if (item is! Future) return "was not a Future";
       |
      0|    return item.then((value) async {
      0|      if (_matcher == null) return null;
       |
       |      String result;
      0|      if (_matcher is AsyncMatcher) {
      0|        result = await (_matcher as AsyncMatcher).matchAsync(value);
      0|        if (result == null) return null;
       |      } else {
      0|        var matchState = {};
      0|        if (_matcher.matches(value, matchState)) return null;
      0|        result = _matcher
      0|            .describeMismatch(value, new StringDescription(), matchState, false)
      0|            .toString();
       |      }
       |
      0|      var buffer = new StringBuffer();
      0|      buffer.writeln(indent(prettyPrint(value), first: 'emitted '));
      0|      if (result.isNotEmpty) buffer.writeln(indent(result, first: '  which '));
      0|      return buffer.toString().trimRight();
       |    });
       |  }
       |
       |  Description describe(Description description) {
      0|    if (_matcher == null) {
      0|      description.add('completes successfully');
       |    } else {
      0|      description.add('completes to a value that ').addDescriptionOf(_matcher);
       |    }
       |    return description;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/on_platform.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation for platform-specific customizations for a test suite.
       |///
       |/// See [the README][onPlatform].
       |///
       |/// [onPlatform]: https://github.com/dart-lang/test/blob/master/README.md#platform-specific-configuration
       |class OnPlatform {
       |  final Map<String, dynamic> annotationsByPlatform;
       |
      0|  const OnPlatform(this.annotationsByPlatform);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/prints_matcher.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |import 'expect.dart';
       |
       |/// Matches a [Function] that prints text that matches [matcher].
       |///
       |/// [matcher] may be a String or a [Matcher].
       |///
       |/// If the function this runs against returns a [Future], all text printed by
       |/// the function (using [Zone] scoping) until that Future completes is matched.
       |///
       |/// This only tracks text printed using the [print] function.
       |///
       |/// This returns an [AsyncMatcher], so [expect] won't complete until the matched
       |/// function does.
      0|Matcher prints(matcher) => new _Prints(wrapMatcher(matcher));
       |
       |class _Prints extends AsyncMatcher {
       |  final Matcher _matcher;
       |
      0|  _Prints(this._matcher);
       |
       |  // Avoid async/await so we synchronously fail if the function is
       |  // synchronous.
       |  /*FutureOr<String>*/ matchAsync(item) {
      0|    if (item is! Function) return "was not a Function";
       |
      0|    var buffer = new StringBuffer();
      0|    var result = runZoned(item,
      0|        zoneSpecification: new ZoneSpecification(print: (_, __, ____, line) {
      0|      buffer.writeln(line);
       |    }));
       |
      0|    return result is Future
      0|        ? result.then((_) => _check(buffer.toString()))
      0|        : _check(buffer.toString());
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add('prints ').addDescriptionOf(_matcher);
       |
       |  /// Verifies that [actual] matches [_matcher] and returns a [String]
       |  /// description of the failure if it doesn't.
       |  String _check(String actual) {
      0|    var matchState = {};
      0|    if (_matcher.matches(actual, matchState)) return null;
       |
      0|    var result = _matcher
      0|        .describeMismatch(actual, new StringDescription(), matchState, false)
      0|        .toString();
       |
      0|    var buffer = new StringBuffer();
      0|    if (actual.isEmpty) {
      0|      buffer.writeln('printed nothing');
       |    } else {
      0|      buffer.writeln(indent(prettyPrint(actual), first: 'printed '));
       |    }
      0|    if (result.isNotEmpty) buffer.writeln(indent(result, first: '  which '));
      0|    return buffer.toString().trimRight();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/skip.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation for marking a test suite as skipped.
       |class Skip {
       |  /// The reason the test suite is skipped, or `null` if no reason is given.
       |  final String reason;
       |
       |  /// Marks a suite as skipped.
       |  ///
       |  /// If [reason] is passed, it's included in the test output as the reason the
       |  /// test is skipped.
      0|  const Skip([this.reason]);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/spawn_hybrid.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:convert';
       |
       |import 'package:async/async.dart';
       |import 'package:path/path.dart' as p;
       |import 'package:stream_channel/stream_channel.dart';
       |
       |import '../../test.dart';
       |import '../backend/invoker.dart';
       |import '../util/remote_exception.dart';
       |import '../utils.dart';
       |
       |/// A transformer that handles messages from the spawned isolate and ensures
       |/// that messages sent to it are JSON-encodable.
       |///
       |/// The spawned isolate sends three kinds of messages. Data messages are emitted
       |/// as data events, error messages are emitted as error events, and print
       |/// messages are printed using `print()`.
       |final _transformer = new StreamChannelTransformer<Object, Map>(
       |    new StreamTransformer.fromHandlers(handleData: (message, sink) {
       |  switch (message["type"]) {
       |    case "data":
       |      sink.add(message["data"]);
       |      break;
       |
       |    case "print":
       |      print(message["line"]);
       |      break;
       |
       |    case "error":
       |      var error = RemoteException.deserialize(message["error"]);
       |      sink.addError(error.error, error.stackTrace);
       |      break;
       |  }
       |}), new StreamSinkTransformer.fromHandlers(handleData: (message, sink) {
       |  // This is called synchronously from the user's `Sink.add()` call, so if
       |  // [ensureJsonEncodable] throws here they'll get a helpful stack trace.
       |  ensureJsonEncodable(message);
       |  sink.add(message);
       |}));
       |
       |/// Spawns a VM isolate for the given [uri], which may be a [Uri] or a [String].
       |///
       |/// This allows browser tests to spawn servers with which they can communicate
       |/// to test client/server interactions. It can also be used by VM tests to
       |/// easily spawn an isolate.
       |///
       |/// The Dart file at [uri] must define a top-level `hybridMain()` function that
       |/// takes a `StreamChannel` argument and, optionally, an `Object` argument to
       |/// which [message] will be passed. Note that [message] must be JSON-encodable.
       |/// For example:
       |///
       |/// ```dart
       |/// import "package:stream_channel/stream_channel.dart";
       |///
       |/// hybridMain(StreamChannel channel, Object message) {
       |///   // ...
       |/// }
       |/// ```
       |///
       |/// If [uri] is relative, it will be interpreted relative to the `file:` URL for
       |/// the test suite being executed. If it's a `package:` URL, it will be resolved
       |/// using the current package's dependency constellation.
       |///
       |/// Returns a [StreamChannel] that's connected to the channel passed to
       |/// `hybridMain()`. Only JSON-encodable objects may be sent through this
       |/// channel. If the channel is closed, the hybrid isolate is killed. If the
       |/// isolate is killed, the channel's stream will emit a "done" event.
       |///
       |/// Any unhandled errors loading or running the hybrid isolate will be emitted
       |/// as errors over the channel's stream. Any calls to `print()` in the hybrid
       |/// isolate will be printed as though they came from the test that created the
       |/// isolate.
       |///
       |/// Code in the hybrid isolate is not considered to be running in a test
       |/// context, so it can't access test functions like `expect()` and
       |/// `expectAsync()`.
       |///
       |/// By default, the hybrid isolate is automatically killed when the test
       |/// finishes running. If [stayAlive] is `true`, it won't be killed until the
       |/// entire test suite finishes running.
       |///
       |/// **Note**: If you use this API, be sure to add a dependency on the
       |/// **`stream_channel` package, since you're using its API as well!
       |StreamChannel spawnHybridUri(uri, {Object message, bool stayAlive: false}) {
       |  Uri parsedUrl;
      0|  if (uri is Uri) {
       |    parsedUrl = uri;
      0|  } else if (uri is String) {
      0|    parsedUrl = Uri.parse(uri);
       |  } else {
      0|    throw new ArgumentError.value(uri, "uri", "must be a Uri or a String.");
       |  }
       |
       |  String absoluteUri;
      0|  if (parsedUrl.scheme.isEmpty) {
      0|    var suitePath = Invoker.current.liveTest.suite.path;
      0|    absoluteUri = p.url.join(
      0|        p.url.dirname(p.toUri(p.absolute(suitePath)).toString()),
      0|        parsedUrl.toString());
       |  } else {
      0|    absoluteUri = uri.toString();
       |  }
       |
      0|  return _spawn(absoluteUri, message, stayAlive: stayAlive);
       |}
       |
       |/// Spawns a VM isolate that runs the given [dartCode], which is loaded as the
       |/// contents of a Dart library.
       |///
       |/// This allows browser tests to spawn servers with which they can communicate
       |/// to test client/server interactions. It can also be used by VM tests to
       |/// easily spawn an isolate.
       |///
       |/// The [dartCode] must define a top-level `hybridMain()` function that takes a
       |/// `StreamChannel` argument and, optionally, an `Object` argument to which
       |/// [message] will be passed. Note that [message] must be JSON-encodable. For
       |/// example:
       |///
       |/// ```dart
       |/// import "package:stream_channel/stream_channel.dart";
       |///
       |/// hybridMain(StreamChannel channel, Object message) {
       |///   // ...
       |/// }
       |/// ```
       |///
       |/// Returns a [StreamChannel] that's connected to the channel passed to
       |/// `hybridMain()`. Only JSON-encodable objects may be sent through this
       |/// channel. If the channel is closed, the hybrid isolate is killed. If the
       |/// isolate is killed, the channel's stream will emit a "done" event.
       |///
       |/// Any unhandled errors loading or running the hybrid isolate will be emitted
       |/// as errors over the channel's stream. Any calls to `print()` in the hybrid
       |/// isolate will be printed as though they came from the test that created the
       |/// isolate.
       |///
       |/// Code in the hybrid isolate is not considered to be running in a test
       |/// context, so it can't access test functions like `expect()` and
       |/// `expectAsync()`.
       |///
       |/// By default, the hybrid isolate is automatically killed when the test
       |/// finishes running. If [stayAlive] is `true`, it won't be killed until the
       |/// entire test suite finishes running.
       |///
       |/// **Note**: If you use this API, be sure to add a dependency on the
       |/// **`stream_channel` package, since you're using its API as well!
       |StreamChannel spawnHybridCode(String dartCode,
       |    {Object message, bool stayAlive: false}) {
      0|  var uri = new Uri.dataFromString(dartCode,
       |      encoding: UTF8, mimeType: 'application/dart');
      0|  return _spawn(uri.toString(), message, stayAlive: stayAlive);
       |}
       |
       |/// Like [spawnHybridUri], but doesn't take [Uri] objects and doesn't handle
       |/// relative URLs.
       |StreamChannel _spawn(String uri, Object message, {bool stayAlive: false}) {
      0|  var channel = Zone.current[#test.runner.test_channel] as MultiChannel;
       |  if (channel == null) {
       |    // TODO(nweiz): Link to an issue tracking support when running the test file
       |    // directly.
      0|    throw new UnsupportedError("Can't connect to the test runner.\n"
       |        'spawnHybridUri() is currently only supported within "pub run test".');
       |  }
       |
      0|  ensureJsonEncodable(message);
       |
      0|  var isolateChannel = channel.virtualChannel();
      0|  channel.sink.add({
       |    "type": "spawn-hybrid-uri",
       |    "url": uri,
       |    "message": message,
      0|    "channel": isolateChannel.id
       |  });
       |
       |  if (!stayAlive) {
      0|    var disconnector = new Disconnector();
      0|    addTearDown(() => disconnector.disconnect());
      0|    isolateChannel = isolateChannel.transform(disconnector);
       |  }
       |
      0|  return isolateChannel.transform(_transformer);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/stream_matcher.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |
       |/// The type for [_StreamMatcher._matchQueue].
       |typedef Future<String> _MatchQueue(StreamQueue queue);
       |
       |/// A matcher that matches events from [Stream]s or [StreamQueue]s.
       |///
       |/// Stream matchers are designed to make it straightforward to create complex
       |/// expectations for streams, and to interleave expectations with the rest of a
       |/// test. They can be used on a [Stream] to match all events it emits:
       |///
       |/// ```dart
       |/// expect(stream, emitsInOrder([
       |///   // Values match individual events.
       |///   "Ready.",
       |///
       |///   // Matchers also run against individual events.
       |///   startsWith("Loading took"),
       |///
       |///   // Stream matchers can be nested. This asserts that one of two events are
       |///   // emitted after the "Loading took" line.
       |///   emitsAnyOf(["Succeeded!", "Failed!"]),
       |///
       |///   // By default, more events are allowed after the matcher finishes
       |///   // matching. This asserts instead that the stream emits a done event and
       |///   // nothing else.
       |///   emitsDone
       |/// ]));
       |/// ```
       |///
       |/// It can also match a [StreamQueue], in which case it consumes the matched
       |/// events. The call to [expect] returns a [Future] that completes when the
       |/// matcher is done matching. You can `await` this to consume different events
       |/// at different times:
       |///
       |/// ```dart
       |/// var stdout = new StreamQueue(stdoutLineStream);
       |///
       |/// // Ignore lines from the process until it's about to emit the URL.
       |/// await expect(stdout, emitsThrough("WebSocket URL:"));
       |///
       |/// // Parse the next line as a URL.
       |/// var url = Uri.parse(await stdout.next);
       |/// expect(url.host, equals('localhost'));
       |///
       |/// // You can match against the same StreamQueue multiple times.
       |/// await expect(stdout, emits("Waiting for connection..."));
       |/// ```
       |///
       |/// Users can call [new StreamMatcher] to create custom matchers.
       |abstract class StreamMatcher extends Matcher {
       |  /// The description of this matcher.
       |  ///
       |  /// This is in the subjunctive mood, which means it can be used after the word
       |  /// "should". For example, it might be "emit the right events".
       |  String get description;
       |
       |  /// Creates a new [StreamMatcher] described by [description] that matches
       |  /// events with [matchQueue].
       |  ///
       |  /// The [matchQueue] callback is used to implement [StreamMatcher.matchQueue],
       |  /// and should follow all the guarantees of that method. In particular:
       |  ///
       |  /// * If it matches successfully, it should return `null` and possibly consume
       |  ///   events.
       |  /// * If it fails to match, consume no events and return a description of the
       |  ///   failure.
       |  /// * The description should be in past tense.
       |  /// * The description should be gramatically valid when used after "the
       |  ///   stream"—"emitted the wrong events", for example.
       |  ///
       |  /// The [matchQueue] callback may return the empty string to indicate a
       |  /// failure if it has no information to add beyond the description of the
       |  /// failure and the events actually emitted by the stream.
       |  ///
       |  /// The [description] should be in the subjunctive mood. This means that it
       |  /// should be grammatically valid when used after the word "should". For
       |  /// example, it might be "emit the right events".
       |  factory StreamMatcher(
       |          Future<String> matchQueue(StreamQueue queue), String description) =
       |      _StreamMatcher;
       |
       |  /// Tries to match events emitted by [queue].
       |  ///
       |  /// If this matches successfully, it consumes the matching events from [queue]
       |  /// and returns `null`.
       |  ///
       |  /// If this fails to match, it doesn't consume any events and returns a
       |  /// description of the failure. This description is in the past tense, and
       |  /// could grammatically be used after "the stream". For example, it might
       |  /// return "emitted the wrong events".
       |  ///
       |  /// The description string may also be empty, which indicates that the
       |  /// matcher's description and the events actually emitted by the stream are
       |  /// enough to understand the failure.
       |  ///
       |  /// If the queue emits an error, that error is re-thrown unless otherwise
       |  /// indicated by the matcher.
       |  Future<String> matchQueue(StreamQueue queue);
       |}
       |
       |/// A concrete implementation of [StreamMatcher].
       |///
       |/// This is separate from the original type to hide the private [AsyncMatcher]
       |/// interface.
       |class _StreamMatcher extends AsyncMatcher implements StreamMatcher {
       |  final String description;
       |
       |  /// The callback used to implement [matchQueue].
       |  final _MatchQueue _matchQueue;
       |
      0|  _StreamMatcher(this._matchQueue, this.description);
       |
      0|  Future<String> matchQueue(StreamQueue queue) => _matchQueue(queue);
       |
       |  /*FutureOr<String>*/ matchAsync(item) {
       |    StreamQueue queue;
      0|    if (item is StreamQueue) {
       |      queue = item;
      0|    } else if (item is Stream) {
      0|      queue = new StreamQueue(item);
       |    } else {
       |      return "was not a Stream or a StreamQueue";
       |    }
       |
       |    // Avoid async/await in the outer method so that we synchronously error out
       |    // for an invalid argument type.
      0|    var transaction = queue.startTransaction();
      0|    var copy = transaction.newQueue();
      0|    return matchQueue(copy).then((result) async {
       |      // Accept the transaction if the result is null, indicating that the match
       |      // succeeded.
       |      if (result == null) {
      0|        transaction.commit(copy);
      0|        return null;
       |      }
       |
       |      // Get a list of events emitted by the stream so we can emit them as part
       |      // of the error message.
      0|      var replay = transaction.newQueue();
      0|      var events = <Result>[];
       |      var subscription = Result.captureStreamTransformer
      0|          .bind(replay.rest)
      0|          .listen(events.add, onDone: () => events.add(null));
       |
       |      // Wait on a timer tick so all buffered events are emitted.
      0|      await new Future.delayed(Duration.ZERO);
      0|      subscription.cancel();
       |
      0|      var eventsString = events.map((event) {
       |        if (event == null) {
       |          return "x Stream closed.";
      0|        } else if (event.isValue) {
      0|          return addBullet(event.asValue.value.toString());
       |        } else {
      0|          var error = event.asError;
      0|          var text = "${error.error}\n${testChain(error.stackTrace)}";
      0|          return prefixLines(text, "  ", first: "! ");
       |        }
      0|      }).join("\n");
      0|      if (eventsString.isEmpty) eventsString = "no events";
       |
      0|      transaction.reject();
       |
      0|      var buffer = new StringBuffer();
      0|      buffer.writeln(indent(eventsString, first: "emitted "));
      0|      if (result.isNotEmpty) buffer.writeln(indent(result, first: "  which "));
      0|      return buffer.toString().trimRight();
       |    }, onError: (error) {
      0|      transaction.reject();
       |      throw error;
       |    });
       |  }
       |
       |  Description describe(Description description) =>
      0|      description.add("should ").add(this.description);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/stream_matchers.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |import 'package:matcher/matcher.dart';
       |
       |import 'async_matcher.dart';
       |import 'stream_matcher.dart';
       |import 'throws_matcher.dart';
       |import '../utils.dart';
       |
       |/// Returns a [StreamMatcher] that asserts that the stream emits a "done" event.
       |final emitsDone = new StreamMatcher(
       |    (queue) async => (await queue.hasNext) ? "" : null, "be done");
       |
       |/// Returns a [StreamMatcher] for [matcher].
       |///
       |/// If [matcher] is already a [StreamMatcher], it's returned as-is. If it's any
       |/// other [Matcher], this matches a single event that matches that matcher. If
       |/// it's any other Object, this matches a single event that's equal to that
       |/// object.
       |///
       |/// This functions like [wrapMatcher] for [StreamMatcher]s: it can convert any
       |/// matcher-like value into a proper [StreamMatcher].
       |StreamMatcher emits(matcher) {
      0|  if (matcher is StreamMatcher) return matcher;
      0|  var wrapped = wrapMatcher(matcher);
       |
      0|  var matcherDescription = wrapped.describe(new StringDescription());
       |
      0|  return new StreamMatcher((queue) async {
      0|    if (!await queue.hasNext) return "";
       |
      0|    var matchState = {};
      0|    var actual = await queue.next;
      0|    if (wrapped.matches(actual, matchState)) return null;
       |
      0|    var mismatchDescription = new StringDescription();
      0|    wrapped.describeMismatch(actual, mismatchDescription, matchState, false);
       |
      0|    if (mismatchDescription.length == 0) return "";
      0|    return "emitted an event that $mismatchDescription";
       |  },
       |      // TODO(nweiz): add "should" once matcher#42 is fixed.
      0|      "emit an event that $matcherDescription");
       |}
       |
       |/// Returns a [StreamMatcher] that matches a single error event that matches
       |/// [matcher].
       |StreamMatcher emitsError(matcher) {
      0|  var wrapped = wrapMatcher(matcher);
      0|  var matcherDescription = wrapped.describe(new StringDescription());
      0|  var throwsMatcher = throwsA(wrapped) as AsyncMatcher;
       |
      0|  return new StreamMatcher(
      0|      (queue) => throwsMatcher.matchAsync(queue.next),
       |      // TODO(nweiz): add "should" once matcher#42 is fixed.
      0|      "emit an error that $matcherDescription");
       |}
       |
       |/// Returns a [StreamMatcher] that allows (but doesn't require) [matcher] to
       |/// match the stream.
       |///
       |/// This matcher always succeeds; if [matcher] doesn't match, this just consumes
       |/// no events.
       |StreamMatcher mayEmit(matcher) {
      0|  var streamMatcher = emits(matcher);
      0|  return new StreamMatcher((queue) async {
      0|    await queue.withTransaction(
      0|        (copy) async => (await streamMatcher.matchQueue(copy)) == null);
      0|    return null;
      0|  }, "maybe ${streamMatcher.description}");
       |}
       |
       |/// Returns a [streamMatcher] that matches the stream if at least one of
       |/// [matchers] matches.
       |///
       |/// If multiple matchers match the stream, this chooses the matcher that
       |/// consumes as many events as possible.
       |///
       |/// If any matchers match the stream, no errors from other matchers are thrown.
       |/// If no matchers match and multiple matchers threw errors, the first error is
       |/// re-thrown.
       |StreamMatcher emitsAnyOf(Iterable matchers) {
      0|  var streamMatchers = matchers.map(emits).toList();
      0|  if (streamMatchers.isEmpty) {
      0|    throw new ArgumentError("matcher may not be empty");
       |  }
       |
      0|  if (streamMatchers.length == 1) return streamMatchers.first;
      0|  var description = "do one of the following:\n" +
      0|      bullet(streamMatchers.map((matcher) => matcher.description));
       |
      0|  return new StreamMatcher((queue) async {
      0|    var transaction = queue.startTransaction();
       |
       |    // Allocate the failures list ahead of time so that its order matches the
       |    // order of [matchers], and thus the order the matchers will be listed in
       |    // the description.
      0|    var failures = new List<String>(matchers.length);
       |
       |    // The first error thrown. If no matchers match and this exists, we rethrow
       |    // it.
       |    Object firstError;
       |    StackTrace firstStackTrace;
       |
      0|    var futures = <Future>[];
       |    StreamQueue consumedMost;
      0|    for (var i = 0; i < matchers.length; i++) {
      0|      futures.add(() async {
      0|        var copy = transaction.newQueue();
       |
       |        String result;
       |        try {
      0|          result = await streamMatchers[i].matchQueue(copy);
       |        } catch (error, stackTrace) {
       |          if (firstError == null) {
       |            firstError = error;
       |            firstStackTrace = stackTrace;
       |          }
      0|          return;
       |        }
       |
       |        if (result != null) {
      0|          failures[i] = result;
       |        } else if (consumedMost == null ||
      0|            consumedMost.eventsDispatched < copy.eventsDispatched) {
       |          consumedMost = copy;
       |        }
      0|      }());
       |    }
       |
      0|    await Future.wait(futures);
       |
       |    if (consumedMost == null) {
      0|      transaction.reject();
       |      if (firstError != null) {
      0|        await new Future.error(firstError, firstStackTrace);
       |      }
       |
      0|      var failureMessages = <String>[];
      0|      for (var i = 0; i < matchers.length; i++) {
      0|        var message = "failed to ${streamMatchers[i].description}";
      0|        if (failures[i].isNotEmpty) {
      0|          message += message.contains("\n") ? "\n" : " ";
      0|          message += "because it ${failures[i]}";
       |        }
       |
      0|        failureMessages.add(message);
       |      }
       |
      0|      return "failed all options:\n${bullet(failureMessages)}";
       |    } else {
      0|      transaction.commit(consumedMost);
      0|      return null;
       |    }
       |  }, description);
       |}
       |
       |/// Returns a [StreamMatcher] that matches the stream if each matcher in
       |/// [matchers] matches, one after another.
       |///
       |/// If any matcher fails to match, this fails and consumes no events.
       |StreamMatcher emitsInOrder(Iterable matchers) {
      0|  var streamMatchers = matchers.map(emits).toList();
      0|  if (streamMatchers.length == 1) return streamMatchers.first;
       |
      0|  var description = "do the following in order:\n" +
      0|      bullet(streamMatchers.map((matcher) => matcher.description));
       |
      0|  return new StreamMatcher((queue) async {
      0|    for (var i = 0; i < streamMatchers.length; i++) {
      0|      var matcher = streamMatchers[i];
      0|      var result = await matcher.matchQueue(queue);
       |      if (result == null) continue;
       |
      0|      var newResult = "didn't ${matcher.description}";
      0|      if (result.isNotEmpty) {
      0|        newResult += newResult.contains("\n") ? "\n" : " ";
      0|        newResult += "because it $result";
       |      }
      0|      return newResult;
       |    }
      0|  }, description);
       |}
       |
       |/// Returns a [StreamMatcher] that matches any number of events followed by
       |/// events that match [matcher].
       |///
       |/// This consumes all events matched by [matcher], as well as all events before.
       |/// If the stream emits a done event without matching [matcher], this fails and
       |/// consumes no events.
       |StreamMatcher emitsThrough(matcher) {
      0|  var streamMatcher = emits(matcher);
      0|  return new StreamMatcher((queue) async {
      0|    var failures = <String>[];
       |
      0|    tryHere() => queue.withTransaction((copy) async {
      0|          var result = await streamMatcher.matchQueue(copy);
      0|          if (result == null) return true;
      0|          failures.add(result);
      0|          return false;
       |        });
       |
      0|    while (await queue.hasNext) {
      0|      if (await tryHere()) return null;
      0|      await queue.next;
       |    }
       |
       |    // Try after the queue is done in case the matcher can match an empty
       |    // stream.
      0|    if (await tryHere()) return null;
       |
      0|    var result = "never did ${streamMatcher.description}";
       |
       |    var failureMessages =
      0|        bullet(failures.where((failure) => failure.isNotEmpty));
      0|    if (failureMessages.isNotEmpty) {
      0|      result += result.contains("\n") ? "\n" : " ";
      0|      result += "because it:\n$failureMessages";
       |    }
       |
      0|    return result;
      0|  }, "eventually ${streamMatcher.description}");
       |}
       |
       |/// Returns a [StreamMatcher] that matches any number of events that match
       |/// [matcher].
       |///
       |/// This consumes events until [matcher] no longer matches. It always succeeds;
       |/// if [matcher] doesn't match, this just consumes no events. It never rethrows
       |/// errors.
       |StreamMatcher mayEmitMultiple(matcher) {
      0|  var streamMatcher = emits(matcher);
       |
      0|  var description = streamMatcher.description;
      0|  description += description.contains("\n") ? "\n" : " ";
      0|  description += "zero or more times";
       |
      0|  return new StreamMatcher((queue) async {
      0|    while (await _tryMatch(queue, streamMatcher)) {
       |      // Do nothing; the matcher presumably already consumed events.
       |    }
      0|    return null;
       |  }, description);
       |}
       |
       |/// Returns a [StreamMatcher] that matches a stream that never matches
       |/// [matcher].
       |///
       |/// This doesn't complete until the stream emits a done event. It never consumes
       |/// any events. It never re-throws errors.
       |StreamMatcher neverEmits(matcher) {
      0|  var streamMatcher = emits(matcher);
      0|  return new StreamMatcher((queue) async {
       |    var events = 0;
       |    var matched = false;
      0|    await queue.withTransaction((copy) async {
      0|      while (await copy.hasNext) {
      0|        matched = await _tryMatch(copy, streamMatcher);
      0|        if (matched) return false;
       |
      0|        events++;
       |
       |        try {
      0|          await copy.next;
       |        } catch (_) {
       |          // Ignore errors events.
       |        }
       |      }
       |
      0|      matched = await _tryMatch(copy, streamMatcher);
      0|      return false;
       |    });
       |
      0|    if (!matched) return null;
      0|    return "after $events ${pluralize('event', events)} did "
      0|        "${streamMatcher.description}";
      0|  }, "never ${streamMatcher.description}");
       |}
       |
       |/// Returns whether [matcher] matches [queue] at its current position.
       |///
       |/// This treats errors as failures to match.
       |Future<bool> _tryMatch(StreamQueue queue, StreamMatcher matcher) {
      0|  return queue.withTransaction((copy) async {
       |    try {
      0|      return (await matcher.matchQueue(copy)) == null;
       |    } catch (_) {
      0|      return false;
       |    }
       |  });
       |}
       |
       |/// Returns a [StreamMatcher] that matches the stream if each matcher in
       |/// [matchers] matches, in any order.
       |///
       |/// If any matcher fails to match, this fails and consumes no events. If the
       |/// matchers match in multiple different possible orders, this chooses the order
       |/// that consumes as many events as possible.
       |///
       |/// If any sequence of matchers matches the stream, no errors from other
       |/// sequences are thrown. If no sequences match and multiple sequences throw
       |/// errors, the first error is re-thrown.
       |///
       |/// Note that checking every ordering of [matchers] is O(n!) in the worst case,
       |/// so this should only be called when there are very few [matchers].
       |StreamMatcher emitsInAnyOrder(Iterable matchers) {
      0|  var streamMatchers = matchers.map(emits).toSet();
      0|  if (streamMatchers.length == 1) return streamMatchers.first;
      0|  var description = "do the following in any order:\n" +
      0|      bullet(streamMatchers.map((matcher) => matcher.description));
       |
      0|  return new StreamMatcher(
      0|      (queue) async => await _tryInAnyOrder(queue, streamMatchers) ? null : "",
       |      description);
       |}
       |
       |/// Returns whether [queue] matches [matchers] in any order.
       |Future<bool> _tryInAnyOrder(
       |    StreamQueue queue, Set<StreamMatcher> matchers) async {
      0|  if (matchers.length == 1)
      0|    return await matchers.first.matchQueue(queue) == null;
       |
      0|  var transaction = queue.startTransaction();
       |  StreamQueue consumedMost;
       |
       |  // The first error thrown. If no matchers match and this exists, we rethrow
       |  // it.
       |  Object firstError;
       |  StackTrace firstStackTrace;
       |
      0|  await Future.wait(matchers.map((matcher) async {
      0|    var copy = transaction.newQueue();
       |    try {
      0|      if (await matcher.matchQueue(copy) != null) return;
       |    } catch (error, stackTrace) {
       |      if (firstError == null) {
       |        firstError = error;
       |        firstStackTrace = stackTrace;
       |      }
      0|      return;
       |    }
       |
      0|    var rest = new Set<StreamMatcher>.from(matchers);
      0|    rest.remove(matcher);
       |
       |    try {
      0|      if (!await _tryInAnyOrder(copy, rest)) return;
       |    } catch (error, stackTrace) {
       |      if (firstError == null) {
       |        firstError = error;
       |        firstStackTrace = stackTrace;
       |      }
      0|      return;
       |    }
       |
       |    if (consumedMost == null ||
      0|        consumedMost.eventsDispatched < copy.eventsDispatched) {
       |      consumedMost = copy;
       |    }
      0|  }));
       |
       |  if (consumedMost == null) {
      0|    transaction.reject();
      0|    if (firstError != null) await new Future.error(firstError, firstStackTrace);
      0|    return false;
       |  } else {
      0|    transaction.commit(consumedMost);
      0|    return true;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/tags.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation for applying a set of user-defined tags to a test suite.
       |///
       |/// See [the documentation on tagging tests][tagging tests].
       |///
       |/// [tagging tests]: https://github.com/dart-lang/test/blob/master/README.md#tagging-tests
       |class Tags {
       |  /// The tags for the test suite.
      0|  Set<String> get tags => _tags.toSet();
       |
       |  final Iterable<String> _tags;
       |
       |  /// Applies a set of user-defined tags to a test suite.
      0|  const Tags(this._tags);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/test_on.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation indicating which platforms a test suite supports.
       |///
       |/// For the full syntax of [expression], see [the README][].
       |///
       |/// [the README]: https://github.com/dart-lang/test/#platform-selector-syntax
       |class TestOn {
       |  /// The expression specifying the platform.
       |  final String expression;
       |
      0|  const TestOn(this.expression);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/throws_matcher.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |
       |/// This function is deprecated.
       |///
       |/// Use [throwsA] instead. We strongly recommend that you add assertions about
       |/// at least the type of the error, but you can write `throwsA(anything)` to
       |/// mimic the behavior of this matcher.
       |@Deprecated("Will be removed in 0.13.0")
       |const Matcher throws = const Throws();
       |
       |/// This can be used to match two kinds of objects:
       |///
       |/// * A [Function] that throws an exception when called. The function cannot
       |///   take any arguments. If you want to test that a function expecting
       |///   arguments throws, wrap it in another zero-argument function that calls
       |///   the one you want to test.
       |///
       |/// * A [Future] that completes with an exception. Note that this creates an
       |///   asynchronous expectation. The call to `expect()` that includes this will
       |///   return immediately and execution will continue. Later, when the future
       |///   completes, the actual expectation will run.
       |///
       |/// In both cases, when an exception is thrown, this will test that the
       |/// exception object matches [matcher]. If [matcher] is not an instance of
       |/// [Matcher], it will implicitly be treated as `equals(matcher)`.
      0|Matcher throwsA(matcher) => new Throws(wrapMatcher(matcher));
       |
       |/// Use the [throwsA] function instead.
       |@Deprecated("Will be removed in 0.13.0")
       |class Throws extends AsyncMatcher {
       |  final Matcher _matcher;
       |
      0|  const Throws([Matcher matcher]) : this._matcher = matcher;
       |
       |  // Avoid async/await so we synchronously fail if we match a synchronous
       |  // function.
       |  /*FutureOr<String>*/ matchAsync(item) {
      0|    if (item is! Function && item is! Future) {
       |      return "was not a Function or Future";
       |    }
       |
      0|    if (item is Future) {
      0|      return item.then((value) => indent(prettyPrint(value), first: 'emitted '),
      0|          onError: _check);
       |    }
       |
       |    try {
      0|      var value = item();
      0|      return indent(prettyPrint(value), first: 'returned ');
       |    } catch (error, trace) {
      0|      return _check(error, trace);
       |    }
       |  }
       |
       |  Description describe(Description description) {
      0|    if (_matcher == null) {
      0|      return description.add("throws");
       |    } else {
      0|      return description.add('throws ').addDescriptionOf(_matcher);
       |    }
       |  }
       |
       |  /// Verifies that [error] matches [_matcher] and returns a [String]
       |  /// description of the failure if it doesn't.
       |  String _check(error, StackTrace trace) {
      0|    if (_matcher == null) return null;
       |
      0|    var matchState = {};
      0|    if (_matcher.matches(error, matchState)) return null;
       |
      0|    var result = _matcher
      0|        .describeMismatch(error, new StringDescription(), matchState, false)
      0|        .toString();
       |
      0|    var buffer = new StringBuffer();
      0|    buffer.writeln(indent(prettyPrint(error), first: 'threw '));
       |    if (trace != null) {
      0|      buffer.writeln(indent(testChain(trace).toString(), first: 'stack '));
       |    }
      0|    if (result.isNotEmpty) buffer.writeln(indent(result, first: 'which '));
      0|    return buffer.toString().trimRight();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.1/lib/src/exception.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |/// An exception thrown by a [StringScanner] that failed to parse a string.
       |class StringScannerException extends SourceSpanFormatException {
      0|  String get source => super.source;
       |
       |  /// The URL of the source file being parsed.
       |  ///
       |  /// This may be `null`, indicating that the source URL is unknown.
      0|  Uri get sourceUrl => span.sourceUrl;
       |
       |  StringScannerException(String message, SourceSpan span, String source)
      0|      : super(message, span, source);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.1/lib/src/line_scanner.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:charcode/ascii.dart';
       |
       |import 'string_scanner.dart';
       |
       |// Note that much of this code is duplicated in eager_span_scanner.dart.
       |
       |/// A regular expression matching newlines across platforms.
       |final _newlineRegExp = new RegExp(r"\r\n?|\n");
       |
       |/// A subclass of [StringScanner] that tracks line and column information.
       |class LineScanner extends StringScanner {
       |  /// The scanner's current (zero-based) line number.
      0|  int get line => _line;
       |  int _line = 0;
       |
       |  /// The scanner's current (zero-based) column number.
      0|  int get column => _column;
       |  int _column = 0;
       |
       |  /// The scanner's state, including line and column information.
       |  ///
       |  /// This can be used to efficiently save and restore the state of the scanner
       |  /// when backtracking. A given [LineScannerState] is only valid for the
       |  /// [LineScanner] that created it.
       |  ///
       |  /// This does not include the scanner's match information.
       |  LineScannerState get state =>
      0|      new LineScannerState._(this, position, line, column);
       |
       |  /// Whether the current position is between a CR character and an LF
       |  /// charactet.
      0|  bool get _betweenCRLF => peekChar(-1) == $cr && peekChar() == $lf;
       |
       |  set state(LineScannerState state) {
      0|    if (!identical(state._scanner, this)) {
      0|      throw new ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    super.position = state.position;
      0|    _line = state.line;
      0|    _column = state.column;
       |  }
       |
       |  set position(int newPosition) {
      0|    var oldPosition = position;
      0|    super.position = newPosition;
       |
      0|    if (newPosition > oldPosition) {
      0|      var newlines = _newlinesIn(string.substring(oldPosition, newPosition));
      0|      _line += newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column += newPosition - oldPosition;
       |      } else {
      0|        _column = newPosition - newlines.last.end;
       |      }
       |    } else {
      0|      var newlines = _newlinesIn(string.substring(newPosition, oldPosition));
      0|      if (_betweenCRLF) newlines.removeLast();
       |
      0|      _line -= newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column -= oldPosition - newPosition;
       |      } else {
      0|        _column = newPosition -
      0|            string.lastIndexOf(_newlineRegExp, newPosition) - 1;
       |      }
       |    }
       |  }
       |
       |  LineScanner(String string, {sourceUrl, int position})
      0|      : super(string, sourceUrl: sourceUrl, position: position);
       |
       |  bool scanChar(int character) {
      0|    if (!super.scanChar(character)) return false;
      0|    _adjustLineAndColumn(character);
       |    return true;
       |  }
       |
       |  int readChar() {
      0|    var character = super.readChar();
      0|    _adjustLineAndColumn(character);
       |    return character;
       |  }
       |
       |  /// Adjusts [_line] and [_column] after having consumed [character].
       |  void _adjustLineAndColumn(int character) {
      0|    if (character == $lf || (character == $cr && peekChar() != $lf)) {
      0|      _line += 1;
      0|      _column = 0;
       |    } else {
      0|      _column += 1;
       |    }
       |  }
       |
       |  bool scan(Pattern pattern) {
      0|    if (!super.scan(pattern)) return false;
       |
      0|    var newlines = _newlinesIn(lastMatch[0]);
      0|    _line += newlines.length;
      0|    if (newlines.isEmpty) {
      0|      _column += lastMatch[0].length;
       |    } else {
      0|      _column = lastMatch[0].length - newlines.last.end;
       |    }
       |
       |    return true;
       |  }
       |
       |  /// Returns a list of [Match]es describing all the newlines in [text], which
       |  /// is assumed to end at [position].
       |  List<Match> _newlinesIn(String text) {
      0|    var newlines = _newlineRegExp.allMatches(text).toList();
      0|    if (_betweenCRLF) newlines.removeLast();
       |    return newlines;
       |  }
       |}
       |
       |/// A class representing the state of a [LineScanner].
       |class LineScannerState {
       |  /// The [LineScanner] that created this.
       |  final LineScanner _scanner;
       |
       |  /// The position of the scanner in this state.
       |  final int position;
       |
       |  /// The zero-based line number of the scanner in this state.
       |  final int line;
       |
       |  /// The zero-based column number of the scanner in this state.
       |  final int column;
       |
      0|  LineScannerState._(this._scanner, this.position, this.line, this.column);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.1/lib/src/span_scanner.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'eager_span_scanner.dart';
       |import 'exception.dart';
       |import 'line_scanner.dart';
       |import 'relative_span_scanner.dart';
       |import 'string_scanner.dart';
       |import 'utils.dart';
       |
       |/// A subclass of [LineScanner] that exposes matched ranges as source map
       |/// [Span]s.
       |class SpanScanner extends StringScanner implements LineScanner {
       |  /// The source of the scanner.
       |  ///
       |  /// This caches line break information and is used to generate [Span]s.
       |  final SourceFile _sourceFile;
       |
      0|  int get line => _sourceFile.getLine(position);
      0|  int get column => _sourceFile.getColumn(position);
       |
      0|  LineScannerState get state => new _SpanScannerState(this, position);
       |
       |  set state(LineScannerState state) {
      0|    if (state is! _SpanScannerState ||
      0|        !identical((state as _SpanScannerState)._scanner, this)) {
      0|      throw new ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    this.position = state.position;
       |  }
       |
       |  /// The [FileSpan] for [lastMatch].
       |  ///
       |  /// This is the span for the entire match. There's no way to get spans for
       |  /// subgroups since [Match] exposes no information about their positions.
       |  FileSpan get lastSpan {
      1|    if (lastMatch == null) _lastSpan = null;
      1|    return _lastSpan;
       |  }
       |  FileSpan _lastSpan;
       |
       |  /// The current location of the scanner.
      0|  FileLocation get location => _sourceFile.location(position);
       |
       |  /// Returns an empty span at the current location.
      0|  FileSpan get emptySpan => location.pointSpan();
       |
       |  /// Creates a new [SpanScanner] that starts scanning from [position].
       |  ///
       |  /// [sourceUrl] is used as [SourceLocation.sourceUrl] for the returned
       |  /// [FileSpan]s as well as for error reporting. It can be a [String], a
       |  /// [Uri], or `null`.
       |  SpanScanner(String string, {sourceUrl, int position})
      1|      : _sourceFile = new SourceFile(string, url: sourceUrl),
      1|        super(string, sourceUrl: sourceUrl, position: position);
       |
       |  /// Creates a new [SpanScanner] that eagerly computes line and column numbers.
       |  ///
       |  /// In general [new SpanScanner] will be more efficient, since it avoids extra
       |  /// computation on every scan. However, eager scanning can be useful for
       |  /// situations where the normal course of parsing frequently involves
       |  /// accessing the current line and column numbers.
       |  ///
       |  /// Note that *only* the `line` and `column` fields on the `SpanScanner`
       |  /// itself and its `LineScannerState` are eagerly computed. To limit their
       |  /// memory footprint, returned spans and locations will still lazily compute
       |  /// their line and column numbers.
       |  factory SpanScanner.eager(String string, {sourceUrl, int position}) =
       |      EagerSpanScanner;
       |
       |  /// Creates a new [SpanScanner] that scans within [span].
       |  ///
       |  /// This scans through [span.text], but emits new spans from [span.file] in
       |  /// their appropriate relative positions. The [string] field contains only
       |  /// [span.text], and [position], [line], and [column] are all relative to the
       |  /// span.
       |  factory SpanScanner.within(FileSpan span) = RelativeSpanScanner;
       |
       |  /// Creates a [FileSpan] representing the source range between [startState]
       |  /// and the current position.
       |  FileSpan spanFrom(LineScannerState startState, [LineScannerState endState]) {
      0|    var endPosition = endState == null ? position : endState.position;
      0|    return _sourceFile.span(startState.position, endPosition);
       |  }
       |
       |  bool matches(Pattern pattern) {
      1|    if (!super.matches(pattern)) {
      1|      _lastSpan = null;
       |      return false;
       |    }
       |
      6|    _lastSpan = _sourceFile.span(position, lastMatch.end);
       |    return true;
       |  }
       |
       |  void error(String message, {Match match, int position, int length}) {
      0|    validateErrorArgs(string, match, position, length);
       |
      0|    if (match == null && position == null && length == null) match = lastMatch;
       |    if (position == null) {
      0|      position = match == null ? this.position : match.start;
       |    }
      0|    if (length == null) length = match == null ? 0 : match.end - match.start;
       |
      0|    var span = _sourceFile.span(position, position + length);
      0|    throw new StringScannerException(message, span, string);
       |  }
       |}
       |
       |/// A class representing the state of a [SpanScanner].
       |class _SpanScannerState implements LineScannerState {
       |  /// The [SpanScanner] that created this.
       |  final SpanScanner _scanner;
       |
       |  final int position;
      0|  int get line => _scanner._sourceFile.getLine(position);
      0|  int get column => _scanner._sourceFile.getColumn(position);
       |
      0|  _SpanScannerState(this._scanner, this.position);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.1/lib/src/string_scanner.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:charcode/charcode.dart';
       |import 'package:source_span/source_span.dart';
       |
       |import 'exception.dart';
       |import 'utils.dart';
       |
       |/// When compiled to JS, forward slashes are always escaped in [RegExp.pattern].
       |///
       |/// See issue 17998.
       |final _slashAutoEscape = new RegExp("/").pattern == "\\/";
       |
       |/// A class that scans through a string using [Pattern]s.
       |class StringScanner {
       |  /// The URL of the source of the string being scanned.
       |  ///
       |  /// This is used for error reporting. It may be `null`, indicating that the
       |  /// source URL is unknown or unavailable.
       |  final Uri sourceUrl;
       |
       |  /// The string being scanned through.
       |  final String string;
       |
       |  /// The current position of the scanner in the string, in characters.
      1|  int get position => _position;
       |  set position(int position) {
      0|    if (position < 0 || position > string.length) {
      0|      throw new ArgumentError("Invalid position $position");
       |    }
       |
      0|    _position = position;
      0|    _lastMatch = null;
       |  }
       |  int _position = 0;
       |
       |  /// The data about the previous match made by the scanner.
       |  ///
       |  /// If the last match failed, this will be `null`.
       |  Match get lastMatch {
       |    // Lazily unset [_lastMatch] so that we avoid extra assignments in
       |    // character-by-character methods that are used in core loops.
      3|    if (_position != _lastMatchPosition) _lastMatch = null;
      1|    return _lastMatch;
       |  }
       |  Match _lastMatch;
       |  int _lastMatchPosition;
       |
       |  /// The portion of the string that hasn't yet been scanned.
      0|  String get rest => string.substring(position);
       |
       |  /// Whether the scanner has completely consumed [string].
      4|  bool get isDone => position == string.length;
       |
       |  /// Creates a new [StringScanner] that starts scanning from [position].
       |  ///
       |  /// [position] defaults to 0, the beginning of the string. [sourceUrl] is the
       |  /// URL of the source of the string being scanned, if available. It can be
       |  /// a [String], a [Uri], or `null`.
       |  StringScanner(this.string, {sourceUrl, int position})
      2|      : sourceUrl = sourceUrl is String ? Uri.parse(sourceUrl) : sourceUrl {
      0|    if (position != null) this.position = position;
       |  }
       |
       |  /// Consumes a single character and returns its character code.
       |  ///
       |  /// This throws a [FormatException] if the string has been fully consumed. It
       |  /// doesn't affect [lastMatch].
       |  int readChar() {
      0|    if (isDone) _fail("more input");
      0|    return string.codeUnitAt(_position++);
       |  }
       |
       |  /// Returns the character code of the character [offset] away from [position].
       |  ///
       |  /// [offset] defaults to zero, and may be negative to inspect already-consumed
       |  /// characters.
       |  ///
       |  /// This returns `null` if [offset] points outside the string. It doesn't
       |  /// affect [lastMatch].
       |  int peekChar([int offset]) {
       |    if (offset == null) offset = 0;
      0|    var index = position + offset;
      0|    if (index < 0 || index >= string.length) return null;
      0|    return string.codeUnitAt(index);
       |  }
       |
       |  /// If the next character in the string is [character], consumes it.
       |  ///
       |  /// Returns whether or not [character] was consumed.
       |  bool scanChar(int character) {
      0|    if (isDone) return false;
      0|    if (string.codeUnitAt(_position) != character) return false;
      0|    _position++;
       |    return true;
       |  }
       |
       |  /// If the next character in the string is [character], consumes it.
       |  ///
       |  /// If [character] could not be consumed, throws a [FormatException]
       |  /// describing the position of the failure. [name] is used in this error as
       |  /// the expected name of the character being matched; if it's `null`, the
       |  /// character itself is used instead.
       |  void expectChar(int character, {String name}) {
      0|    if (scanChar(character)) return;
       |
       |    if (name == null) {
      0|      if (character == $backslash) {
       |        name = r'"\"';
      0|      } else if (character == $double_quote) {
       |        name = r'"\""';
       |      } else {
      0|        name = '"${new String.fromCharCode(character)}"';
       |      }
       |    }
       |
      0|    _fail(name);
       |  }
       |
       |  /// If [pattern] matches at the current position of the string, scans forward
       |  /// until the end of the match.
       |  ///
       |  /// Returns whether or not [pattern] matched.
       |  bool scan(Pattern pattern) {
      1|    var success = matches(pattern);
       |    if (success) {
      3|      _position = _lastMatch.end;
      2|      _lastMatchPosition = _position;
       |    }
       |    return success;
       |  }
       |
       |  /// If [pattern] matches at the current position of the string, scans forward
       |  /// until the end of the match.
       |  ///
       |  /// If [pattern] did not match, throws a [FormatException] describing the
       |  /// position of the failure. [name] is used in this error as the expected name
       |  /// of the pattern being matched; if it's `null`, the pattern itself is used
       |  /// instead.
       |  void expect(Pattern pattern, {String name}) {
      0|    if (scan(pattern)) return;
       |
       |    if (name == null) {
      0|      if (pattern is RegExp) {
      0|        var source = pattern.pattern;
      0|        if (!_slashAutoEscape) source = source.replaceAll("/", "\\/");
      0|        name = "/$source/";
       |      } else {
       |        name =
      0|            pattern.toString().replaceAll("\\", "\\\\").replaceAll('"', '\\"');
      0|        name = '"$name"';
       |      }
       |    }
      0|    _fail(name);
       |  }
       |
       |  /// If the string has not been fully consumed, this throws a
       |  /// [FormatException].
       |  void expectDone() {
      0|    if (isDone) return;
      0|    _fail("no more input");
       |  }
       |
       |  /// Returns whether or not [pattern] matches at the current position of the
       |  /// string.
       |  ///
       |  /// This doesn't move the scan pointer forward.
       |  bool matches(Pattern pattern) {
      4|    _lastMatch = pattern.matchAsPrefix(string, position);
      2|    _lastMatchPosition = _position;
      1|    return _lastMatch != null;
       |  }
       |
       |  /// Returns the substring of [string] between [start] and [end].
       |  ///
       |  /// Unlike [String.substring], [end] defaults to [position] rather than the
       |  /// end of the string.
       |  String substring(int start, [int end]) {
      0|    if (end == null) end = position;
      0|    return string.substring(start, end);
       |  }
       |
       |  /// Throws a [FormatException] with [message] as well as a detailed
       |  /// description of the location of the error in the string.
       |  ///
       |  /// [match] is the match information for the span of the string with which the
       |  /// error is associated. This should be a match returned by this scanner's
       |  /// [lastMatch] property. By default, the error is associated with the last
       |  /// match.
       |  ///
       |  /// If [position] and/or [length] are passed, they are used as the error span
       |  /// instead. If only [length] is passed, [position] defaults to the current
       |  /// position; if only [position] is passed, [length] defaults to 0.
       |  ///
       |  /// It's an error to pass [match] at the same time as [position] or [length].
       |  void error(String message, {Match match, int position, int length}) {
      0|    validateErrorArgs(string, match, position, length);
       |
      0|    if (match == null && position == null && length == null) match = lastMatch;
       |    if (position == null) {
      0|      position = match == null ? this.position : match.start;
       |    }
      0|    if (length == null) length = match == null ? 0 : match.end - match.start;
       |
      0|    var sourceFile = new SourceFile(string, url: sourceUrl);
      0|    var span = sourceFile.span(position, position + length);
      0|    throw new StringScannerException(message, span, string);
       |  }
       |
       |  // TODO(nweiz): Make this handle long lines more gracefully.
       |  /// Throws a [FormatException] describing that [name] is expected at the
       |  /// current position in the string.
       |  void _fail(String name) {
      0|    error("expected $name.", position: this.position, length: 0);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/context.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |
       |import 'characters.dart' as chars;
       |import 'internal_style.dart';
       |import 'style.dart';
       |import 'parsed_path.dart';
       |import 'path_exception.dart';
       |import '../path.dart' as p;
       |
      1|Context createInternal() => new Context._internal();
       |
       |/// An instantiable class for manipulating paths. Unlike the top-level
       |/// functions, this lets you explicitly select what platform the paths will use.
       |class Context {
       |  /// Creates a new path context for the given style and current directory.
       |  ///
       |  /// If [style] is omitted, it uses the host operating system's path style. If
       |  /// only [current] is omitted, it defaults ".". If *both* [style] and
       |  /// [current] are omitted, [current] defaults to the real current working
       |  /// directory.
       |  ///
       |  /// On the browser, [style] defaults to [Style.url] and [current] defaults to
       |  /// the current URL.
       |  factory Context({Style style, String current}) {
       |    if (current == null) {
       |      if (style == null) {
      0|        current = p.current;
       |      } else {
       |        current = ".";
       |      }
       |    }
       |
       |    if (style == null) {
      0|      style = Style.platform;
      0|    } else if (style is! InternalStyle) {
      0|      throw new ArgumentError("Only styles defined by the path package are "
       |          "allowed.");
       |    }
       |
      0|    return new Context._(style as InternalStyle, current);
       |  }
       |
       |  /// Create a [Context] to be used internally within path.
       |  Context._internal()
      2|      : style = Style.platform as InternalStyle,
      1|        _current = null;
       |
      0|  Context._(this.style, this._current);
       |
       |  /// The style of path that this context works with.
       |  final InternalStyle style;
       |
       |  /// The current directory given when Context was created. If null, current
       |  /// directory is evaluated from 'p.current'.
       |  final String _current;
       |
       |  /// The current directory that relative paths are relative to.
      2|  String get current => _current != null ? _current : p.current;
       |
       |  /// Gets the path separator for the context's [style]. On Mac and Linux,
       |  /// this is `/`. On Windows, it's `\`.
      0|  String get separator => style.separator;
       |
       |  /// Creates a new path by appending the given path parts to [current].
       |  /// Equivalent to [join()] with [current] as the first argument. Example:
       |  ///
       |  ///     var context = new Context(current: '/root');
       |  ///     context.absolute('path', 'to', 'foo'); // -> '/root/path/to/foo'
       |  ///
       |  /// If [current] isn't absolute, this won't return an absolute path.
       |  String absolute(String part1, [String part2, String part3, String part4,
       |      String part5, String part6, String part7]) {
      0|    _validateArgList(
      0|        "absolute", [part1, part2, part3, part4, part5, part6, part7]);
       |
       |    // If there's a single absolute path, just return it. This is a lot faster
       |    // for the common case of `p.absolute(path)`.
      0|    if (part2 == null && isAbsolute(part1) && !isRootRelative(part1)) {
       |      return part1;
       |    }
       |
      0|    return join(current, part1, part2, part3, part4, part5, part6, part7);
       |  }
       |
       |  /// Gets the part of [path] after the last separator on the context's
       |  /// platform.
       |  ///
       |  ///     context.basename('path/to/foo.dart'); // -> 'foo.dart'
       |  ///     context.basename('path/to');          // -> 'to'
       |  ///
       |  /// Trailing separators are ignored.
       |  ///
       |  ///     context.basename('path/to/'); // -> 'to'
      0|  String basename(String path) => _parse(path).basename;
       |
       |  /// Gets the part of [path] after the last separator on the context's
       |  /// platform, and without any trailing file extension.
       |  ///
       |  ///     context.basenameWithoutExtension('path/to/foo.dart'); // -> 'foo'
       |  ///
       |  /// Trailing separators are ignored.
       |  ///
       |  ///     context.basenameWithoutExtension('path/to/foo.dart/'); // -> 'foo'
       |  String basenameWithoutExtension(String path) =>
      0|      _parse(path).basenameWithoutExtension;
       |
       |  /// Gets the part of [path] before the last separator.
       |  ///
       |  ///     context.dirname('path/to/foo.dart'); // -> 'path/to'
       |  ///     context.dirname('path/to');          // -> 'path'
       |  ///
       |  /// Trailing separators are ignored.
       |  ///
       |  ///     context.dirname('path/to/'); // -> 'path'
       |  String dirname(String path) {
      0|    var parsed = _parse(path);
      0|    parsed.removeTrailingSeparators();
      0|    if (parsed.parts.isEmpty) return parsed.root == null ? '.' : parsed.root;
      0|    if (parsed.parts.length == 1) {
      0|      return parsed.root == null ? '.' : parsed.root;
       |    }
      0|    parsed.parts.removeLast();
      0|    parsed.separators.removeLast();
      0|    parsed.removeTrailingSeparators();
      0|    return parsed.toString();
       |  }
       |
       |  /// Gets the file extension of [path]: the portion of [basename] from the last
       |  /// `.` to the end (including the `.` itself).
       |  ///
       |  ///     context.extension('path/to/foo.dart'); // -> '.dart'
       |  ///     context.extension('path/to/foo'); // -> ''
       |  ///     context.extension('path.to/foo'); // -> ''
       |  ///     context.extension('path/to/foo.dart.js'); // -> '.js'
       |  ///
       |  /// If the file name starts with a `.`, then it is not considered an
       |  /// extension:
       |  ///
       |  ///     context.extension('~/.bashrc');    // -> ''
       |  ///     context.extension('~/.notes.txt'); // -> '.txt'
      0|  String extension(String path) => _parse(path).extension;
       |
       |  // TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
       |  /// Returns the root of [path] if it's absolute, or an empty string if it's
       |  /// relative.
       |  ///
       |  ///     // Unix
       |  ///     context.rootPrefix('path/to/foo'); // -> ''
       |  ///     context.rootPrefix('/path/to/foo'); // -> '/'
       |  ///
       |  ///     // Windows
       |  ///     context.rootPrefix(r'path\to\foo'); // -> ''
       |  ///     context.rootPrefix(r'C:\path\to\foo'); // -> r'C:\'
       |  ///
       |  ///     // URL
       |  ///     context.rootPrefix('path/to/foo'); // -> ''
       |  ///     context.rootPrefix('http://dartlang.org/path/to/foo');
       |  ///       // -> 'http://dartlang.org'
      0|  String rootPrefix(String path) => path.substring(0, style.rootLength(path));
       |
       |  /// Returns `true` if [path] is an absolute path and `false` if it is a
       |  /// relative path.
       |  ///
       |  /// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |  /// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |  /// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
       |  /// optional hostname (e.g. `http://dartlang.org`, `file://`) or with a `/`.
       |  ///
       |  /// URLs that start with `/` are known as "root-relative", since they're
       |  /// relative to the root of the current URL. Since root-relative paths are
       |  /// still absolute in every other sense, [isAbsolute] will return true for
       |  /// them. They can be detected using [isRootRelative].
      3|  bool isAbsolute(String path) => style.rootLength(path) > 0;
       |
       |  /// Returns `true` if [path] is a relative path and `false` if it is absolute.
       |  /// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |  /// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |  /// `:/` or `:\`.
      1|  bool isRelative(String path) => !this.isAbsolute(path);
       |
       |  /// Returns `true` if [path] is a root-relative path and `false` if it's not.
       |  ///
       |  /// URLs that start with `/` are known as "root-relative", since they're
       |  /// relative to the root of the current URL. Since root-relative paths are
       |  /// still absolute in every other sense, [isAbsolute] will return true for
       |  /// them. They can be detected using [isRootRelative].
       |  ///
       |  /// No POSIX and Windows paths are root-relative.
      2|  bool isRootRelative(String path) => style.isRootRelative(path);
       |
       |  /// Joins the given path parts into a single path. Example:
       |  ///
       |  ///     context.join('path', 'to', 'foo'); // -> 'path/to/foo'
       |  ///
       |  /// If any part ends in a path separator, then a redundant separator will not
       |  /// be added:
       |  ///
       |  ///     context.join('path/', 'to', 'foo'); // -> 'path/to/foo
       |  ///
       |  /// If a part is an absolute path, then anything before that will be ignored:
       |  ///
       |  ///     context.join('path', '/to', 'foo'); // -> '/to/foo'
       |  ///
       |  String join(String part1, [String part2, String part3, String part4,
       |      String part5, String part6, String part7, String part8]) {
      0|    var parts = <String>[
       |      part1,
       |      part2,
       |      part3,
       |      part4,
       |      part5,
       |      part6,
       |      part7,
       |      part8
       |    ];
      0|    _validateArgList("join", parts);
      0|    return joinAll(parts.where((part) => part != null));
       |  }
       |
       |  /// Joins the given path parts into a single path. Example:
       |  ///
       |  ///     context.joinAll(['path', 'to', 'foo']); // -> 'path/to/foo'
       |  ///
       |  /// If any part ends in a path separator, then a redundant separator will not
       |  /// be added:
       |  ///
       |  ///     context.joinAll(['path/', 'to', 'foo']); // -> 'path/to/foo
       |  ///
       |  /// If a part is an absolute path, then anything before that will be ignored:
       |  ///
       |  ///     context.joinAll(['path', '/to', 'foo']); // -> '/to/foo'
       |  ///
       |  /// For a fixed number of parts, [join] is usually terser.
       |  String joinAll(Iterable<String> parts) {
      0|    var buffer = new StringBuffer();
       |    var needsSeparator = false;
       |    var isAbsoluteAndNotRootRelative = false;
       |
      0|    for (var part in parts.where((part) => part != '')) {
      0|      if (this.isRootRelative(part) && isAbsoluteAndNotRootRelative) {
       |        // If the new part is root-relative, it preserves the previous root but
       |        // replaces the path after it.
      0|        var parsed = _parse(part);
      0|        var path = buffer.toString();
      0|        parsed.root = path.substring(
      0|            0, style.rootLength(path, withDrive: true));
      0|        if (style.needsSeparator(parsed.root)) {
      0|          parsed.separators[0] = style.separator;
       |        }
      0|        buffer.clear();
      0|        buffer.write(parsed.toString());
      0|      } else if (this.isAbsolute(part)) {
      0|        isAbsoluteAndNotRootRelative = !this.isRootRelative(part);
       |        // An absolute path discards everything before it.
      0|        buffer.clear();
      0|        buffer.write(part);
       |      } else {
      0|        if (part.length > 0 && style.containsSeparator(part[0])) {
       |          // The part starts with a separator, so we don't need to add one.
       |        } else if (needsSeparator) {
      0|          buffer.write(separator);
       |        }
       |
      0|        buffer.write(part);
       |      }
       |
       |      // Unless this part ends with a separator, we'll need to add one before
       |      // the next part.
      0|      needsSeparator = style.needsSeparator(part);
       |    }
       |
      0|    return buffer.toString();
       |  }
       |
       |  // TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
       |  /// Splits [path] into its components using the current platform's
       |  /// [separator]. Example:
       |  ///
       |  ///     context.split('path/to/foo'); // -> ['path', 'to', 'foo']
       |  ///
       |  /// The path will *not* be normalized before splitting.
       |  ///
       |  ///     context.split('path/../foo'); // -> ['path', '..', 'foo']
       |  ///
       |  /// If [path] is absolute, the root directory will be the first element in the
       |  /// array. Example:
       |  ///
       |  ///     // Unix
       |  ///     context.split('/path/to/foo'); // -> ['/', 'path', 'to', 'foo']
       |  ///
       |  ///     // Windows
       |  ///     context.split(r'C:\path\to\foo'); // -> [r'C:\', 'path', 'to', 'foo']
       |  List<String> split(String path) {
      1|    var parsed = _parse(path);
       |    // Filter out empty parts that exist due to multiple separators in a row.
      5|    parsed.parts = parsed.parts.where((part) => !part.isEmpty).toList();
      4|    if (parsed.root != null) parsed.parts.insert(0, parsed.root);
      1|    return parsed.parts;
       |  }
       |
       |  /// Canonicalizes [path].
       |  ///
       |  /// This is guaranteed to return the same path for two different input paths
       |  /// if and only if both input paths point to the same location. Unlike
       |  /// [normalize], it returns absolute paths when possible and canonicalizes
       |  /// ASCII case on Windows.
       |  ///
       |  /// Note that this does not resolve symlinks.
       |  ///
       |  /// If you want a map that uses path keys, it's probably more efficient to
       |  /// pass [equals] and [hash] to [new HashMap] than it is to canonicalize every
       |  /// key.
       |  String canonicalize(String path) {
      0|    path = absolute(path);
      0|    if (style != Style.windows && !_needsNormalization(path)) return path;
       |
      0|    var parsed = _parse(path);
      0|    parsed.normalize(canonicalize: true);
      0|    return parsed.toString();
       |  }
       |
       |  /// Normalizes [path], simplifying it by handling `..`, and `.`, and
       |  /// removing redundant path separators whenever possible.
       |  ///
       |  /// Note that this is *not* guaranteed to return the same result for two
       |  /// equivalent input paths. For that, see [canonicalize]. Or, if you're using
       |  /// paths as map keys, pass [equals] and [hash] to [new HashMap].
       |  ///
       |  ///     context.normalize('path/./to/..//file.text'); // -> 'path/file.txt'
       |  String normalize(String path) {
      1|    if (!_needsNormalization(path)) return path;
       |
      1|    var parsed = _parse(path);
      1|    parsed.normalize();
      1|    return parsed.toString();
       |  }
       |
       |  /// Returns whether [path] needs to be normalized.
       |  bool _needsNormalization(String path) {
       |    var start = 0;
      1|    var codeUnits = path.codeUnits;
       |    var previousPrevious;
       |    var previous;
       |
       |    // Skip past the root before we start looking for snippets that need
       |    // normalization. We want to normalize "//", but not when it's part of
       |    // "http://".
      2|    var root = style.rootLength(path);
      1|    if (root != 0) {
       |      start = root;
       |      previous = chars.SLASH;
       |
       |      // On Windows, the root still needs to be normalized if it contains a
       |      // forward slash.
      3|      if (style == Style.windows) {
      0|        for (var i = 0; i < root; i++) {
      0|          if (codeUnits[i] == chars.SLASH) return true;
       |        }
       |      }
       |    }
       |
      3|    for (var i = start; i < codeUnits.length; i++) {
      1|      var codeUnit = codeUnits[i];
      2|      if (style.isSeparator(codeUnit)) {
       |        // Forward slashes in Windows paths are normalized to backslashes.
      3|        if (style == Style.windows && codeUnit == chars.SLASH) return true;
       |
       |        // Multiple separators are normalized to single separators.
      2|        if (previous != null && style.isSeparator(previous)) return true;
       |
       |        // Single dots and double dots are normalized to directory traversals.
       |        //
       |        // This can return false positives for ".../", but that's unlikely
       |        // enough that it's probably not going to cause performance issues.
      1|        if (previous == chars.PERIOD &&
       |            (previousPrevious == null ||
      0|             previousPrevious == chars.PERIOD ||
      0|             style.isSeparator(previousPrevious))) {
       |          return true;
       |        }
       |      }
       |
       |      previousPrevious = previous;
       |      previous = codeUnit;
       |    }
       |
       |    // Empty paths are normalized to ".".
       |    if (previous == null) return true;
       |
       |    // Trailing separators are removed.
      2|    if (style.isSeparator(previous)) return true;
       |
       |    // Single dots and double dots are normalized to directory traversals.
      1|    if (previous == chars.PERIOD &&
       |        (previousPrevious == null ||
      0|         previousPrevious == chars.SLASH ||
      0|         previousPrevious == chars.PERIOD)) {
       |      return true;
       |    }
       |
       |    return false;
       |  }
       |
       |  /// Attempts to convert [path] to an equivalent relative path relative to
       |  /// [root].
       |  ///
       |  ///     var context = new Context(current: '/root/path');
       |  ///     context.relative('/root/path/a/b.dart'); // -> 'a/b.dart'
       |  ///     context.relative('/root/other.dart'); // -> '../other.dart'
       |  ///
       |  /// If the [from] argument is passed, [path] is made relative to that instead.
       |  ///
       |  ///     context.relative('/root/path/a/b.dart',
       |  ///         from: '/root/path'); // -> 'a/b.dart'
       |  ///     context.relative('/root/other.dart',
       |  ///         from: '/root/path'); // -> '../other.dart'
       |  ///
       |  /// If [path] and/or [from] are relative paths, they are assumed to be
       |  /// relative to [current].
       |  ///
       |  /// Since there is no relative path from one drive letter to another on
       |  /// Windows, this will return an absolute path in that case.
       |  ///
       |  ///     context.relative(r'D:\other', from: r'C:\other'); // -> 'D:\other'
       |  ///
       |  /// This will also return an absolute path if an absolute [path] is passed to
       |  /// a context with a relative path for [current].
       |  ///
       |  ///     var context = new Context(r'some/relative/path');
       |  ///     context.relative(r'/absolute/path'); // -> '/absolute/path'
       |  ///
       |  /// If [root] is relative, it may be impossible to determine a path from
       |  /// [from] to [path]. For example, if [root] and [path] are "." and [from] is
       |  /// "/", no path can be determined. In this case, a [PathException] will be
       |  /// thrown.
       |  String relative(String path, {String from}) {
       |    // Avoid expensive computation if the path is already relative.
      1|    if (from == null && this.isRelative(path)) return this.normalize(path);
       |
      1|    from = from == null ? current : absolute(from);
       |
       |    // We can't determine the path from a relative path to an absolute path.
      1|    if (this.isRelative(from) && this.isAbsolute(path)) {
      0|      return this.normalize(path);
       |    }
       |
       |    // If the given path is relative, resolve it relative to the context's
       |    // current directory.
      2|    if (this.isRelative(path) || this.isRootRelative(path)) {
      0|      path = this.absolute(path);
       |    }
       |
       |    // If the path is still relative and `from` is absolute, we're unable to
       |    // find a path from `from` to `path`.
      1|    if (this.isRelative(path) && this.isAbsolute(from)) {
      0|      throw new PathException('Unable to find a path to "$path" from "$from".');
       |    }
       |
      2|    var fromParsed = _parse(from)..normalize();
      2|    var pathParsed = _parse(path)..normalize();
       |
      6|    if (fromParsed.parts.length > 0 && fromParsed.parts[0] == '.') {
      0|      return pathParsed.toString();
       |    }
       |
       |    // If the root prefixes don't match (for example, different drive letters
       |    // on Windows), then there is no relative path, so just return the absolute
       |    // one. In Windows, drive letters are case-insenstive and we allow
       |    // calculation of relative paths, even if a path has not been normalized.
      3|    if (fromParsed.root != pathParsed.root &&
      0|        ((fromParsed.root == null || pathParsed.root == null) ||
      0|            !style.pathsEqual(fromParsed.root, pathParsed.root))) {
      0|      return pathParsed.toString();
       |    }
       |
       |    // Strip off their common prefix.
      3|    while (fromParsed.parts.length > 0 &&
      3|        pathParsed.parts.length > 0 &&
      6|        style.pathsEqual(fromParsed.parts[0], pathParsed.parts[0])) {
      2|      fromParsed.parts.removeAt(0);
      2|      fromParsed.separators.removeAt(1);
      2|      pathParsed.parts.removeAt(0);
      2|      pathParsed.separators.removeAt(1);
       |    }
       |
       |    // If there are any directories left in the from path, we need to walk up
       |    // out of them. If a directory left in the from path is '..', it cannot
       |    // be cancelled by adding a '..'.
      3|    if (fromParsed.parts.length > 0 && fromParsed.parts[0] == '..') {
      0|      throw new PathException('Unable to find a path to "$path" from "$from".');
       |    }
      2|    pathParsed.parts.insertAll(
      3|        0, new List.filled(fromParsed.parts.length, '..'));
      2|    pathParsed.separators[0] = '';
      2|    pathParsed.separators.insertAll(
      5|        1, new List.filled(fromParsed.parts.length, style.separator));
       |
       |    // Corner case: the paths completely collapsed.
      3|    if (pathParsed.parts.length == 0) return '.';
       |
       |    // Corner case: path was '.' and some '..' directories were added in front.
       |    // Don't add a final '/.' in that case.
      6|    if (pathParsed.parts.length > 1 && pathParsed.parts.last == '.') {
      0|      pathParsed.parts.removeLast();
      0|      pathParsed.separators
      0|        ..removeLast()
      0|        ..removeLast()
      0|        ..add('');
       |    }
       |
       |    // Make it relative.
      1|    pathParsed.root = '';
      1|    pathParsed.removeTrailingSeparators();
       |
      1|    return pathParsed.toString();
       |  }
       |
       |  /// Returns `true` if [child] is a path beneath `parent`, and `false`
       |  /// otherwise.
       |  ///
       |  ///     path.isWithin('/root/path', '/root/path/a'); // -> true
       |  ///     path.isWithin('/root/path', '/root/other'); // -> false
       |  ///     path.isWithin('/root/path', '/root/path'); // -> false
       |  bool isWithin(String parent, String child) =>
      0|      _isWithinOrEquals(parent, child) == _PathRelation.within;
       |
       |  /// Returns `true` if [path1] points to the same location as [path2], and
       |  /// `false` otherwise.
       |  ///
       |  /// The [hash] function returns a hash code that matches these equality
       |  /// semantics.
       |  bool equals(String path1, String path2) =>
      0|      _isWithinOrEquals(path1, path2) == _PathRelation.equal;
       |
       |  /// Compares two paths and returns an enum value indicating their relationship
       |  /// to one another.
       |  ///
       |  /// This never returns [_PathRelation.inconclusive].
       |  _PathRelation _isWithinOrEquals(String parent, String child) {
       |    // Make both paths the same level of relative. We're only able to do the
       |    // quick comparison if both paths are in the same format, and making a path
       |    // absolute is faster than making it relative.
      0|    var parentIsAbsolute = isAbsolute(parent);
      0|    var childIsAbsolute = isAbsolute(child);
       |    if (parentIsAbsolute && !childIsAbsolute) {
      0|      child = absolute(child);
      0|      if (style.isRootRelative(parent)) parent = absolute(parent);
       |    } else if (childIsAbsolute && !parentIsAbsolute) {
      0|      parent = absolute(parent);
      0|      if (style.isRootRelative(child)) child = absolute(child);
       |    } else if (childIsAbsolute && parentIsAbsolute) {
      0|      var childIsRootRelative = style.isRootRelative(child);
      0|      var parentIsRootRelative = style.isRootRelative(parent);
       |
       |      if (childIsRootRelative && !parentIsRootRelative) {
      0|        child = absolute(child);
       |      } else if (parentIsRootRelative && !childIsRootRelative) {
      0|        parent = absolute(parent);
       |      }
       |    }
       |
      0|    var result = _isWithinOrEqualsFast(parent, child);
      0|    if (result != _PathRelation.inconclusive) return result;
       |
       |    var relative;
       |    try {
      0|      relative = this.relative(child, from: parent);
      0|    } on PathException catch (_) {
       |      // If no relative path from [parent] to [child] is found, [child]
       |      // definitely isn't a child of [parent].
       |      return _PathRelation.different;
       |    }
       |
      0|    if (!this.isRelative(relative)) return _PathRelation.different;
      0|    if (relative == '.') return _PathRelation.equal;
      0|    if (relative == '..') return _PathRelation.different;
      0|    return (relative.length >= 3 &&
      0|            relative.startsWith('..') &&
      0|             style.isSeparator(relative.codeUnitAt(2)))
       |        ? _PathRelation.different
       |        : _PathRelation.within;
       |  }
       |
       |  /// An optimized implementation of [_isWithinOrEquals] that doesn't handle a
       |  /// few complex cases.
       |  _PathRelation _isWithinOrEqualsFast(String parent, String child) {
       |    // Normally we just bail when we see "." path components, but we can handle
       |    // a single dot easily enough.
      0|    if (parent == '.') parent = '';
       |
      0|    var parentRootLength = style.rootLength(parent);
      0|    var childRootLength = style.rootLength(child);
       |
       |    // If the roots aren't the same length, we know both paths are absolute or
       |    // both are root-relative, and thus that the roots are meaningfully
       |    // different.
       |    //
       |    //     isWithin("C:/bar", "//foo/bar/baz") //=> false
       |    //     isWithin("http://example.com/", "http://google.com/bar") //=> false
      0|    if (parentRootLength != childRootLength) return _PathRelation.different;
       |
       |    // Make sure that the roots are textually the same as well.
       |    //
       |    //     isWithin("C:/bar", "D:/bar/baz") //=> false
       |    //     isWithin("http://example.com/", "http://example.org/bar") //=> false
      0|    for (var i = 0; i < parentRootLength; i++) {
      0|      var parentCodeUnit = parent.codeUnitAt(i);
      0|      var childCodeUnit = child.codeUnitAt(i);
      0|      if (!style.codeUnitsEqual(parentCodeUnit, childCodeUnit)) {
       |        return _PathRelation.different;
       |      }
       |    }
       |
       |    // Start by considering the last code unit as a separator, since
       |    // semantically we're starting at a new path component even if we're
       |    // comparing relative paths.
       |    var lastCodeUnit = chars.SLASH;
       |
       |    /// The index of the last separator in [parent].
       |    int lastParentSeparator;
       |
       |    // Iterate through both paths as long as they're semantically identical.
       |    var parentIndex = parentRootLength;
       |    var childIndex = childRootLength;
      0|    while (parentIndex < parent.length && childIndex < child.length) {
      0|      var parentCodeUnit = parent.codeUnitAt(parentIndex);
      0|      var childCodeUnit = child.codeUnitAt(childIndex);
      0|      if (style.codeUnitsEqual(parentCodeUnit, childCodeUnit)) {
      0|        if (style.isSeparator(parentCodeUnit)) {
       |          lastParentSeparator = parentIndex;
       |        }
       |
       |        lastCodeUnit = parentCodeUnit;
      0|        parentIndex++;
      0|        childIndex++;
       |        continue;
       |      }
       |
       |      // Ignore multiple separators in a row.
      0|      if (style.isSeparator(parentCodeUnit) &&
      0|          style.isSeparator(lastCodeUnit)) {
       |        lastParentSeparator = parentIndex;
      0|        parentIndex++;
       |        continue;
      0|      } else if (style.isSeparator(childCodeUnit) &&
      0|          style.isSeparator(lastCodeUnit)) {
      0|        childIndex++;
       |        continue;
       |      }
       |
       |      // If a dot comes after a separator, it may be a directory traversal
       |      // operator. To check that, we need to know if it's followed by either
       |      // "/" or "./". Otherwise, it's just a normal non-matching character.
       |      //
       |      //     isWithin("foo/./bar", "foo/bar/baz") //=> true
       |      //     isWithin("foo/bar/../baz", "foo/bar/.foo") //=> false
      0|      if (parentCodeUnit == chars.PERIOD && style.isSeparator(lastCodeUnit)) {
      0|        parentIndex++;
       |
       |        // We've hit "/." at the end of the parent path, which we can ignore,
       |        // since the paths were equivalent up to this point.
      0|        if (parentIndex == parent.length) break;
      0|        parentCodeUnit = parent.codeUnitAt(parentIndex);
       |
       |        // We've hit "/./", which we can ignore.
      0|        if (style.isSeparator(parentCodeUnit)) {
       |          lastParentSeparator = parentIndex;
      0|          parentIndex++;
       |          continue;
       |        }
       |
       |        // We've hit "/..", which may be a directory traversal operator that
       |        // we can't handle on the fast track.
      0|        if (parentCodeUnit == chars.PERIOD) {
      0|          parentIndex++;
      0|          if (parentIndex == parent.length ||
      0|              style.isSeparator(parent.codeUnitAt(parentIndex))) {
       |            return _PathRelation.inconclusive;
       |          }
       |        }
       |
       |        // If this isn't a directory traversal, fall through so we hit the
       |        // normal handling for mismatched paths.
       |      }
       |
       |      // This is the same logic as above, but for the child path instead of the
       |      // parent.
      0|      if (childCodeUnit == chars.PERIOD && style.isSeparator(lastCodeUnit)) {
      0|        childIndex++;
      0|        if (childIndex == child.length) break;
      0|        childCodeUnit = child.codeUnitAt(childIndex);
       |
      0|        if (style.isSeparator(childCodeUnit)) {
      0|          childIndex++;
       |          continue;
       |        }
       |
      0|        if (childCodeUnit == chars.PERIOD) {
      0|          childIndex++;
      0|          if (childIndex == child.length ||
      0|              style.isSeparator(child.codeUnitAt(childIndex))) {
       |            return _PathRelation.inconclusive;
       |          }
       |        }
       |      }
       |
       |      // If we're here, we've hit two non-matching, non-significant characters.
       |      // As long as the remainders of the two paths don't have any unresolved
       |      // ".." components, we can be confident that [child] is not within
       |      // [parent].
      0|      var childDirection = _pathDirection(child, childIndex);
      0|      if (childDirection != _PathDirection.belowRoot) {
       |        return _PathRelation.inconclusive;
       |      }
       |
      0|      var parentDirection = _pathDirection(parent, parentIndex);
      0|      if (parentDirection != _PathDirection.belowRoot) {
       |        return _PathRelation.inconclusive;
       |      }
       |
       |      return _PathRelation.different;
       |    }
       |
       |    // If the child is shorter than the parent, it's probably not within the
       |    // parent. The only exception is if the parent has some weird ".." stuff
       |    // going on, in which case we do the slow check.
       |    //
       |    //     isWithin("foo/bar/baz", "foo/bar") //=> false
       |    //     isWithin("foo/bar/baz/../..", "foo/bar") //=> true
      0|    if (childIndex == child.length) {
      0|      if (parentIndex == parent.length ||
      0|          style.isSeparator(parent.codeUnitAt(parentIndex))) {
       |        lastParentSeparator = parentIndex;
       |      } else {
      1|        lastParentSeparator ??= math.max(0, parentRootLength - 1);
       |      }
       |
      0|      var direction = _pathDirection(parent,
      0|          lastParentSeparator ?? parentRootLength - 1);
      0|      if (direction == _PathDirection.atRoot) return _PathRelation.equal;
      0|      return direction == _PathDirection.aboveRoot
       |          ? _PathRelation.inconclusive
       |          : _PathRelation.different;
       |    }
       |
       |    // We've reached the end of the parent path, which means it's time to make a
       |    // decision. Before we do, though, we'll check the rest of the child to see
       |    // what that tells us.
      0|    var direction = _pathDirection(child, childIndex);
       |
       |    // If there are no more components in the child, then it's the same as
       |    // the parent.
       |    //
       |    //     isWithin("foo/bar", "foo/bar") //=> false
       |    //     isWithin("foo/bar", "foo/bar//") //=> false
       |    //     equals("foo/bar", "foo/bar") //=> true
       |    //     equals("foo/bar", "foo/bar//") //=> true
      0|    if (direction == _PathDirection.atRoot) return _PathRelation.equal;
       |
       |    // If there are unresolved ".." components in the child, no decision we make
       |    // will be valid. We'll abort and do the slow check instead.
       |    //
       |    //     isWithin("foo/bar", "foo/bar/..") //=> false
       |    //     isWithin("foo/bar", "foo/bar/baz/bang/../../..") //=> false
       |    //     isWithin("foo/bar", "foo/bar/baz/bang/../../../bar/baz") //=> true
      0|    if (direction == _PathDirection.aboveRoot) {
       |      return _PathRelation.inconclusive;
       |    }
       |
       |    // The child is within the parent if and only if we're on a separator
       |    // boundary.
       |    //
       |    //     isWithin("foo/bar", "foo/bar/baz") //=> true
       |    //     isWithin("foo/bar/", "foo/bar/baz") //=> true
       |    //     isWithin("foo/bar", "foo/barbaz") //=> false
      0|    return (style.isSeparator(child.codeUnitAt(childIndex)) ||
      0|            style.isSeparator(lastCodeUnit))
       |        ? _PathRelation.within
       |        : _PathRelation.different;
       |  }
       |
       |  // Returns a [_PathDirection] describing the path represented by [codeUnits]
       |  // starting at [index].
       |  //
       |  // This ignores leading separators.
       |  //
       |  //     pathDirection("foo") //=> below root
       |  //     pathDirection("foo/bar/../baz") //=> below root
       |  //     pathDirection("//foo/bar/baz") //=> below root
       |  //     pathDirection("/") //=> at root
       |  //     pathDirection("foo/..") //=> at root
       |  //     pathDirection("foo/../baz") //=> reaches root
       |  //     pathDirection("foo/../..") //=> above root
       |  //     pathDirection("foo/../../foo/bar/baz") //=> above root
       |  _PathDirection _pathDirection(String path, int index) {
       |    var depth = 0;
       |    var reachedRoot = false;
       |    var i = index;
      0|    while (i < path.length) {
       |      // Ignore initial separators or doubled separators.
      0|      while (i < path.length && style.isSeparator(path.codeUnitAt(i))) {
      0|        i++;
       |      }
       |
       |      // If we're at the end, stop.
      0|      if (i == path.length) break;
       |
       |      // Move through the path component to the next separator.
       |      var start = i;
      0|      while (i < path.length && !style.isSeparator(path.codeUnitAt(i))) {
      0|        i++;
       |      }
       |
       |      // See if the path component is ".", "..", or a name.
      0|      if (i - start == 1 && path.codeUnitAt(start) == chars.PERIOD) {
       |        // Don't change the depth.
      0|      } else if (i - start == 2 &&
      0|          path.codeUnitAt(start) == chars.PERIOD &&
      0|          path.codeUnitAt(start + 1) == chars.PERIOD) {
       |        // ".." backs out a directory.
      0|        depth--;
       |
       |        // If we work back beyond the root, stop.
      0|        if (depth < 0) break;
       |
       |        // Record that we reached the root so we don't return
       |        // [_PathDirection.belowRoot].
      0|        if (depth == 0) reachedRoot = true;
       |      } else {
       |        // Step inside a directory.
      0|        depth++;
       |      }
       |
       |      // If we're at the end, stop.
      0|      if (i == path.length) break;
       |
       |      // Move past the separator.
      0|      i++;
       |    }
       |
      0|    if (depth < 0) return _PathDirection.aboveRoot;
      0|    if (depth == 0) return _PathDirection.atRoot;
       |    if (reachedRoot) return _PathDirection.reachesRoot;
       |    return _PathDirection.belowRoot;
       |  }
       |
       |  /// Returns a hash code for [path] that matches the semantics of [equals].
       |  ///
       |  /// Note that the same path may have different hash codes in different
       |  /// [Context]s.
       |  int hash(String path) {
       |    // Make [path] absolute to ensure that equivalent relative and absolute
       |    // paths have the same hash code.
      0|    path = absolute(path);
       |
      0|    var result = _hashFast(path);
       |    if (result != null) return result;
       |
      0|    var parsed = _parse(path);
      0|    parsed.normalize();
      0|    return _hashFast(parsed.toString());
       |  }
       |
       |  /// An optimized implementation of [hash] that doesn't handle internal `..`
       |  /// components.
       |  ///
       |  /// This will handle `..` components that appear at the beginning of the path.
       |  int _hashFast(String path) {
       |    var hash = 4603;
       |    var beginning = true;
       |    var wasSeparator = true;
      0|    for (var i = 0; i < path.length; i++) {
      0|      var codeUnit = style.canonicalizeCodeUnit(path.codeUnitAt(i));
       |
       |      // Take advantage of the fact that collisions are allowed to ignore
       |      // separators entirely. This lets us avoid worrying about cases like
       |      // multiple trailing slashes.
      0|      if (style.isSeparator(codeUnit)) {
       |        wasSeparator = true;
       |        continue;
       |      }
       |
      0|      if (codeUnit == chars.PERIOD && wasSeparator) {
       |        // If a dot comes after a separator, it may be a directory traversal
       |        // operator. To check that, we need to know if it's followed by either
       |        // "/" or "./". Otherwise, it's just a normal character.
       |        //
       |        //     hash("foo/./bar") == hash("foo/bar")
       |
       |        // We've hit "/." at the end of the path, which we can ignore.
      0|        if (i + 1 == path.length) break;
       |
      0|        var next = path.codeUnitAt(i + 1);
       |
       |        // We can just ignore "/./", since they don't affect the semantics of
       |        // the path.
      0|        if (style.isSeparator(next)) continue;
       |
       |        // If the path ends with "/.." or contains "/../", we need to
       |        // canonicalize it before we can hash it. We make an exception for ".."s
       |        // at the beginning of the path, since those may appear even in a
       |        // canonicalized path.
       |        if (!beginning &&
      0|            next == chars.PERIOD &&
      0|            (i + 2 == path.length ||
      0|             style.isSeparator(path.codeUnitAt(i + 2)))) {
       |          return null;
       |        }
       |      }
       |
       |      // Make sure [hash] stays under 32 bits even after multiplication.
      0|      hash &= 0x3FFFFFF;
      0|      hash *= 33;
      0|      hash ^= codeUnit;
       |      wasSeparator = false;
       |      beginning = false;
       |    }
       |    return hash;
       |  }
       |
       |  /// Removes a trailing extension from the last part of [path].
       |  ///
       |  ///     context.withoutExtension('path/to/foo.dart'); // -> 'path/to/foo'
       |  String withoutExtension(String path) {
      0|    var parsed = _parse(path);
       |
      0|    for (var i = parsed.parts.length - 1; i >= 0; i--) {
      0|      if (!parsed.parts[i].isEmpty) {
      0|        parsed.parts[i] = parsed.basenameWithoutExtension;
       |        break;
       |      }
       |    }
       |
      0|    return parsed.toString();
       |  }
       |
       |  /// Returns the path represented by [uri], which may be a [String] or a [Uri].
       |  ///
       |  /// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
       |  /// style, this will just convert [uri] to a string.
       |  ///
       |  ///     // POSIX
       |  ///     context.fromUri('file:///path/to/foo')
       |  ///       // -> '/path/to/foo'
       |  ///
       |  ///     // Windows
       |  ///     context.fromUri('file:///C:/path/to/foo')
       |  ///       // -> r'C:\path\to\foo'
       |  ///
       |  ///     // URL
       |  ///     context.fromUri('http://dartlang.org/path/to/foo')
       |  ///       // -> 'http://dartlang.org/path/to/foo'
       |  ///
       |  /// If [uri] is relative, a relative path will be returned.
       |  ///
       |  ///     path.fromUri('path/to/foo'); // -> 'path/to/foo'
       |  String fromUri(uri) {
      1|    if (uri is String) uri = Uri.parse(uri);
      2|    return style.pathFromUri(uri);
       |  }
       |
       |  /// Returns the URI that represents [path].
       |  ///
       |  /// For POSIX and Windows styles, this will return a `file:` URI. For the URL
       |  /// style, this will just convert [path] to a [Uri].
       |  ///
       |  ///     // POSIX
       |  ///     context.toUri('/path/to/foo')
       |  ///       // -> Uri.parse('file:///path/to/foo')
       |  ///
       |  ///     // Windows
       |  ///     context.toUri(r'C:\path\to\foo')
       |  ///       // -> Uri.parse('file:///C:/path/to/foo')
       |  ///
       |  ///     // URL
       |  ///     context.toUri('http://dartlang.org/path/to/foo')
       |  ///       // -> Uri.parse('http://dartlang.org/path/to/foo')
       |  Uri toUri(String path) {
      0|    if (isRelative(path)) {
      0|      return style.relativePathToUri(path);
       |    } else {
      0|      return style.absolutePathToUri(join(current, path));
       |    }
       |  }
       |
       |  /// Returns a terse, human-readable representation of [uri].
       |  ///
       |  /// [uri] can be a [String] or a [Uri]. If it can be made relative to the
       |  /// current working directory, that's done. Otherwise, it's returned as-is.
       |  /// This gracefully handles non-`file:` URIs for [Style.posix] and
       |  /// [Style.windows].
       |  ///
       |  /// The returned value is meant for human consumption, and may be either URI-
       |  /// or path-formatted.
       |  ///
       |  ///     // POSIX
       |  ///     var context = new Context(current: '/root/path');
       |  ///     context.prettyUri('file:///root/path/a/b.dart'); // -> 'a/b.dart'
       |  ///     context.prettyUri('http://dartlang.org/'); // -> 'http://dartlang.org'
       |  ///
       |  ///     // Windows
       |  ///     var context = new Context(current: r'C:\root\path');
       |  ///     context.prettyUri('file:///C:/root/path/a/b.dart'); // -> r'a\b.dart'
       |  ///     context.prettyUri('http://dartlang.org/'); // -> 'http://dartlang.org'
       |  ///
       |  ///     // URL
       |  ///     var context = new Context(current: 'http://dartlang.org/root/path');
       |  ///     context.prettyUri('http://dartlang.org/root/path/a/b.dart');
       |  ///         // -> r'a/b.dart'
       |  ///     context.prettyUri('file:///root/path'); // -> 'file:///root/path'
       |  String prettyUri(uri) {
      1|    if (uri is String) uri = Uri.parse(uri);
      5|    if (uri.scheme == 'file' && style == Style.url) return uri.toString();
      7|    if (uri.scheme != 'file' && uri.scheme != '' && style != Style.url) {
      1|      return uri.toString();
       |    }
       |
      2|    var path = normalize(fromUri(uri));
      1|    var rel = relative(path);
       |
       |    // Only return a relative path if it's actually shorter than the absolute
       |    // path. This avoids ugly things like long "../" chains to get to the root
       |    // and then go back down.
      5|    return split(rel).length > split(path).length ? path : rel;
       |  }
       |
      2|  ParsedPath _parse(String path) => new ParsedPath.parse(path, style);
       |}
       |
       |/// Validates that there are no non-null arguments following a null one and
       |/// throws an appropriate [ArgumentError] on failure.
       |_validateArgList(String method, List<String> args) {
      0|  for (var i = 1; i < args.length; i++) {
       |    // Ignore nulls hanging off the end.
      0|    if (args[i] == null || args[i - 1] != null) continue;
       |
       |    var numArgs;
      0|    for (numArgs = args.length; numArgs >= 1; numArgs--) {
      0|      if (args[numArgs - 1] != null) break;
       |    }
       |
       |    // Show the arguments.
      0|    var message = new StringBuffer();
      0|    message.write("$method(");
      0|    message.write(args
      0|        .take(numArgs)
      0|        .map((arg) => arg == null ? "null" : '"$arg"')
      0|        .join(", "));
      0|    message.write("): part ${i - 1} was null, but part $i was not.");
      0|    throw new ArgumentError(message.toString());
       |  }
       |}
       |
       |/// An enum of possible return values for [Context._pathDirection].
       |class _PathDirection {
       |  /// The path contains enough ".." components that at some point it reaches
       |  /// above its original root.
       |  ///
       |  /// Note that this applies even if the path ends beneath its original root. It
       |  /// takes precendence over any other return values that may apple.
       |  static const aboveRoot = const _PathDirection("above root");
       |
       |  /// The path contains enough ".." components that it ends at its original
       |  /// root.
       |  static const atRoot = const _PathDirection("at root");
       |
       |  /// The path contains enough ".." components that at some point it reaches its
       |  /// original root, but it ends beneath that root.
       |  static const reachesRoot = const _PathDirection("reaches root");
       |
       |  /// The path never reaches to or above its original root.
       |  static const belowRoot = const _PathDirection("below root");
       |
       |  final String name;
       |
      1|  const _PathDirection(this.name);
       |
      0|  String toString() => name;
       |}
       |
       |/// An enum of possible return values for [Context._isWithinOrEquals].
       |class _PathRelation {
       |  /// The first path is a proper parent of the second.
       |  ///
       |  /// For example, `foo` is a proper parent of `foo/bar`, but not of `foo`.
       |  static const within = const _PathRelation("within");
       |
       |  /// The two paths are equivalent.
       |  ///
       |  /// For example, `foo//bar` is equivalent to `foo/bar`.
       |  static const equal = const _PathRelation("equal");
       |
       |  /// The first path is neither a parent of nor equal to the second.
       |  static const different = const _PathRelation("different");
       |
       |  /// We couldn't quickly determine any information about the paths'
       |  /// relationship to each other.
       |  ///
       |  /// Only returned by [Context._isWithinOrEqualsFast].
       |  static const inconclusive = const _PathRelation("inconclusive");
       |
       |  final String name;
       |
      1|  const _PathRelation(this.name);
       |
      0|  String toString() => name;
       |}
       |
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/style.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'context.dart';
       |import 'style/posix.dart';
       |import 'style/url.dart';
       |import 'style/windows.dart';
       |
       |/// An enum type describing a "flavor" of path.
       |abstract class Style {
       |  /// POSIX-style paths use "/" (forward slash) as separators. Absolute paths
       |  /// start with "/". Used by UNIX, Linux, Mac OS X, and others.
       |  static final Style posix = new PosixStyle();
       |
       |  /// Windows paths use "\" (backslash) as separators. Absolute paths start with
       |  /// a drive letter followed by a colon (example, "C:") or two backslashes
       |  /// ("\\") for UNC paths.
       |  // TODO(rnystrom): The UNC root prefix should include the drive name too, not
       |  // just the "\\".
       |  static final Style windows = new WindowsStyle();
       |
       |  /// URLs aren't filesystem paths, but they're supported to make it easier to
       |  /// manipulate URL paths in the browser.
       |  ///
       |  /// URLs use "/" (forward slash) as separators. Absolute paths either start
       |  /// with a protocol and optional hostname (e.g. `http://dartlang.org`,
       |  /// `file://`) or with "/".
       |  static final Style url = new UrlStyle();
       |
       |  /// The style of the host platform.
       |  ///
       |  /// When running on the command line, this will be [windows] or [posix] based
       |  /// on the host operating system. On a browser, this will be [url].
       |  static final Style platform = _getPlatformStyle();
       |
       |  /// Gets the type of the host platform.
       |  static Style _getPlatformStyle() {
       |    // If we're running a Dart file in the browser from a `file:` URI,
       |    // [Uri.base] will point to a file. If we're running on the standalone,
       |    // it will point to a directory. We can use that fact to determine which
       |    // style to use.
      3|    if (Uri.base.scheme != 'file') return Style.url;
      3|    if (!Uri.base.path.endsWith('/')) return Style.url;
      3|    if (new Uri(path: 'a/b').toFilePath() == 'a\\b') return Style.windows;
      1|    return Style.posix;
       |  }
       |
       |  /// The name of this path style. Will be "posix" or "windows".
       |  String get name;
       |
       |  /// A [Context] that uses this style.
      0|  Context get context => new Context(style: this);
       |
       |  @Deprecated("Most Style members will be removed in path 2.0.")
       |  String get separator;
       |
       |  @Deprecated("Most Style members will be removed in path 2.0.")
       |  Pattern get separatorPattern;
       |
       |  @Deprecated("Most Style members will be removed in path 2.0.")
       |  Pattern get needsSeparatorPattern;
       |
       |  @Deprecated("Most Style members will be removed in path 2.0.")
       |  Pattern get rootPattern;
       |
       |  @Deprecated("Most Style members will be removed in path 2.0.")
       |  Pattern get relativeRootPattern;
       |
       |  @Deprecated("Most style members will be removed in path 2.0.")
       |  String getRoot(String path);
       |
       |  @Deprecated("Most style members will be removed in path 2.0.")
       |  String getRelativeRoot(String path);
       |
       |  @Deprecated("Most style members will be removed in path 2.0.")
       |  String pathFromUri(Uri uri);
       |
       |  @Deprecated("Most style members will be removed in path 2.0.")
       |  Uri relativePathToUri(String path);
       |
       |  @Deprecated("Most style members will be removed in path 2.0.")
       |  Uri absolutePathToUri(String path);
       |
      0|  String toString() => name;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/path_exception.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An exception class that's thrown when a path operation is unable to be
       |/// computed accurately.
       |class PathException implements Exception {
       |  String message;
       |
      0|  PathException(this.message);
       |
      0|  String toString() => "PathException: $message";
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/compiler_tools-1.0.0-dev/lib/src/base_parser.dart
       |import 'package:source_span/source_span.dart';
       |import 'syntax_error.dart';
       |import 'token.dart';
       |
       |/// A base parser that traverses a list of tokens.
       |class BaseParser<TokenType> {
       |  int _index = -1;
       |  SourceLocation _location;
       |
       |  /// The tokens, scanned from source code, that are being parsed.
       |  final List<Token<TokenType>> tokens;
       |
      0|  BaseParser(this.tokens);
       |
       |  /// Returns the [Token] at the current position.
      0|  Token<TokenType> get current => eof() || _index == -1 ? null : tokens[_index];
       |
       |  /// Returns the current location of the parser within source code.
      0|  SourceLocation get location => _location;
       |
       |  /// Returns `true` if the parser has reached the end of the token stream.
      0|  bool eof() => _index >= tokens.length;
       |
       |  /// Advances a negative [n] number of steps, and returns the token at the new position.
      0|  Token<TokenType> backtrack([int n]) => read((n ?? 1) * -1);
       |
       |  /// Returns a [SyntaxError] with the given message, and [current] as the offending token.
       |  SyntaxError error(String msg) {
      0|    return new SyntaxError(msg, offendingToken: current);
       |  }
       |
       |  /// Throws a [SyntaxError] indicating that an expected token type was not found.
       |  SyntaxError expectedType(TokenType type) {
      0|    return error('Expected $type, ${current?.type ?? "nothing"} found.');
       |  }
       |
       |  /// Checks if the next token is of the given [type]. If `true`, it will be consumed.
       |  bool next(TokenType type) {
      0|    if (_index >= tokens.length - 1) {
       |      return false;
       |    }
       |
      0|    if (peek()?.type == type) {
      0|      read();
       |      return true;
       |    }
       |
       |    return false;
       |  }
       |
       |  /// Looks ahead an [n] number of steps without advancing the position.
      0|  Token<TokenType> peek([int n]) => tokens[_index + (n ?? 1)];
       |
       |  /// Looks behind an [n] number of steps without advancing the position.
      0|  Token<TokenType> peekBehind([int n]) => peek((n ?? -1) * -1);
       |
       |  /// Advances the stream an [n] number of steps, and returns the token at the new position.
       |  Token<TokenType> read([int n]) {
      0|    final tok = tokens[_index += (n ?? 1)];
      0|    _location = tok.span.start;
       |    return tok;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/compiler_tools-1.0.0-dev/lib/src/location.dart
       |import 'package:source_span/source_span.dart';
       |
       |/// Represents a location within source code.
       |class Location {
       |  /// The filename where the source code is found.
       |  String filename;
       |
       |  /// Most editors recognize line `1` as the beginning of a file.
       |  final int line;
       |
       |  /// Most editors recognize index `1` as the beginning of a [line].
       |  final int index;
       |
       |  /// The character offset of this location.
       |  final int offset;
       |
      0|  Location(this.offset, this.line, this.index, {this.filename});
       |
       |  /// Creates a [SourceSpan] encompassing [a] and [b] within [source] code.
       |  static SourceSpan toSourceSpan(String source, Location a, Location b) =>
      0|      new SourceSpan(a.toSourceLocation(), b.toSourceLocation(),
      0|          source.substring(a.offset, b.offset));
       |
       |  /// Compares this [Location] to another.
       |  @override
       |  bool operator ==(other) {
      0|    return other is Location && other.index == index && other.line == line;
       |  }
       |
       |  /// Converts to a [SourceLocation].
      0|  SourceLocation toSourceLocation() => new SourceLocation(offset,
      0|      line: line,
      0|      column: index,
      0|      sourceUrl: filename != null ? Uri.parse(filename) : null);
       |
       |  @override
      0|  String toString() => '$line:$index';
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/compiler_tools-1.0.0-dev/lib/src/syntax_error.dart
       |import 'token.dart';
       |
       |/// Represents a syntax error.
       |class SyntaxError implements Exception {
       |  /// The cause of this error.
       |  final String cause;
       |
       |  /// The [Token] that caused this syntax error.
       |  final Token offendingToken;
       |
      0|  SyntaxError(this.cause, {this.offendingToken});
       |
       |  @override
       |  String toString() {
      0|    if (offendingToken == null)
      0|      return 'Syntax error: $cause';
      0|    else if (offendingToken.span.sourceUrl != null) {
      0|      return '(${offendingToken.span.sourceUrl}:${offendingToken.span.start.line}:${offendingToken.span.start.column}) Syntax Error: $cause';
       |    } else {
      0|      return '(${offendingToken.span.start.line}:${offendingToken.span.start.column}) Syntax Error: $cause';
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/compiler_tools-1.0.0-dev/lib/src/token.dart
       |import 'package:source_span/source_span.dart';
       |
       |/// Represents a lexeme in code.
       |class Token<TokenType> {
       |  /// This should usually be an `enum`.
       |  final TokenType type;
       |  
       |  final SourceSpan span;
       |
       |  /// This token's text.
      2|  String get text => span.text;
       |
      1|  Token(this.type, {this.span});
       |
       |  @override
       |  String toString() =>
      0|      '${span.start.line}:${span.start.column} "$text" -> $type';
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/group.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import 'group_entry.dart';
       |import 'metadata.dart';
       |import 'operating_system.dart';
       |import 'test.dart';
       |import 'test_platform.dart';
       |
       |/// A group contains one or more tests and subgroups.
       |///
       |/// It includes metadata that applies to all contained tests.
       |class Group implements GroupEntry {
       |  final String name;
       |
       |  final Metadata metadata;
       |
       |  final Trace trace;
       |
       |  /// The children of this group.
       |  final List<GroupEntry> entries;
       |
       |  /// Returns a new root-level group.
       |  Group.root(Iterable<GroupEntry> entries, {Metadata metadata})
      0|      : this(null, entries, metadata: metadata);
       |
       |  /// A test to run before all tests in the group.
       |  ///
       |  /// This is `null` if no `setUpAll` callbacks were declared.
       |  final Test setUpAll;
       |
       |  /// A test to run after all tests in the group.
       |  ///
       |  /// This is `null` if no `tearDown` callbacks were declared.
       |  final Test tearDownAll;
       |
       |  /// The number of tests (recursively) in this group.
       |  int get testCount {
      0|    if (_testCount != null) return _testCount;
      0|    _testCount = entries.fold(
      0|        0, (count, entry) => count + (entry is Group ? entry.testCount : 1));
      0|    return _testCount;
       |  }
       |
       |  int _testCount;
       |
       |  Group(this.name, Iterable<GroupEntry> entries,
       |      {Metadata metadata,
       |      this.trace,
       |      Test this.setUpAll,
       |      Test this.tearDownAll})
      1|      : entries = new List<GroupEntry>.unmodifiable(entries),
      1|        metadata = metadata == null ? new Metadata() : metadata;
       |
       |  Group forPlatform(TestPlatform platform, {OperatingSystem os}) {
      3|    if (!metadata.testOn.evaluate(platform, os: os)) return null;
      2|    var newMetadata = metadata.forPlatform(platform, os: os);
      2|    var filtered = _map((entry) => entry.forPlatform(platform, os: os));
      1|    if (filtered.isEmpty && !entries.isEmpty) return null;
      2|    return new Group(name, filtered,
       |        metadata: newMetadata,
      1|        trace: trace,
      1|        setUpAll: setUpAll,
      1|        tearDownAll: tearDownAll);
       |  }
       |
       |  Group filter(bool callback(Test test)) {
      0|    var filtered = _map((entry) => entry.filter(callback));
      0|    if (filtered.isEmpty && !entries.isEmpty) return null;
      0|    return new Group(name, filtered,
      0|        metadata: metadata,
      0|        trace: trace,
      0|        setUpAll: setUpAll,
      0|        tearDownAll: tearDownAll);
       |  }
       |
       |  /// Returns the entries of this group mapped using [callback].
       |  ///
       |  /// Any `null` values returned by [callback] will be removed.
       |  List<GroupEntry> _map(GroupEntry callback(GroupEntry entry)) {
      1|    return entries
      2|        .map((entry) => callback(entry))
      1|        .where((entry) => entry != null)
      1|        .toList();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/metadata.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'package:boolean_selector/boolean_selector.dart';
       |import 'package:collection/collection.dart';
       |
       |import '../frontend/skip.dart';
       |import '../frontend/timeout.dart';
       |import '../utils.dart';
       |import 'operating_system.dart';
       |import 'platform_selector.dart';
       |import 'test_platform.dart';
       |
       |/// Metadata for a test or test suite.
       |///
       |/// This metadata comes from declarations on the test itself; it doesn't include
       |/// configuration from the user.
       |class Metadata {
       |  /// Empty metadata with only default values.
       |  ///
       |  /// Using this is slightly more efficient than manually constructing a new
       |  /// metadata with no arguments.
       |  static final empty = new Metadata._();
       |
       |  /// The selector indicating which platforms the suite supports.
       |  final PlatformSelector testOn;
       |
       |  /// The modification to the timeout for the test or suite.
       |  final Timeout timeout;
       |
       |  /// Whether the test or suite should be skipped.
      1|  bool get skip => _skip ?? false;
       |  final bool _skip;
       |
       |  /// The reason the test or suite should be skipped, if given.
       |  final String skipReason;
       |
       |  /// Whether to use verbose stack traces.
      1|  bool get verboseTrace => _verboseTrace ?? false;
       |  final bool _verboseTrace;
       |
       |  /// Whether to chain stack traces.
      1|  bool get chainStackTraces => _chainStackTraces ?? true;
       |  final bool _chainStackTraces;
       |
       |  /// The user-defined tags attached to the test or suite.
       |  final Set<String> tags;
       |
       |  /// Platform-specific metadata.
       |  ///
       |  /// Each key identifies a platform, and its value identifies the specific
       |  /// metadata for that platform. These can be applied by calling [forPlatform].
       |  final Map<PlatformSelector, Metadata> onPlatform;
       |
       |  /// Metadata that applies only when specific tags are applied.
       |  ///
       |  /// Tag-specific metadata is applied when merging this with other metadata.
       |  /// Note that unlike [onPlatform], the base metadata takes precedence over any
       |  /// tag-specific metadata.
       |  ///
       |  /// This is guaranteed not to have any keys that match [tags]; those are
       |  /// resolved when the metadata is constructed.
       |  final Map<BooleanSelector, Metadata> forTag;
       |
       |  /// Parses a user-provided map into the value for [onPlatform].
       |  static Map<PlatformSelector, Metadata> _parseOnPlatform(
       |      Map<String, dynamic> onPlatform) {
      1|    if (onPlatform == null) return {};
       |
      0|    var result = <PlatformSelector, Metadata>{};
      0|    onPlatform.forEach((platform, metadata) {
      0|      if (metadata is Timeout || metadata is Skip) {
      0|        metadata = [metadata];
      0|      } else if (metadata is! List) {
      0|        throw new ArgumentError('Metadata for platform "$platform" must be a '
      0|            'Timeout, Skip, or List of those; was "$metadata".');
       |      }
       |
      0|      var selector = new PlatformSelector.parse(platform);
       |
       |      var timeout;
       |      var skip;
      0|      for (var metadatum in metadata) {
      0|        if (metadatum is Timeout) {
       |          if (timeout != null) {
      0|            throw new ArgumentError('Only a single Timeout may be declared for '
      0|                '"$platform".');
       |          }
       |
       |          timeout = metadatum;
      0|        } else if (metadatum is Skip) {
       |          if (skip != null) {
      0|            throw new ArgumentError('Only a single Skip may be declared for '
      0|                '"$platform".');
       |          }
       |
      0|          skip = metadatum.reason == null ? true : metadatum.reason;
       |        } else {
      0|          throw new ArgumentError('Metadata for platform "$platform" must be a '
      0|              'Timeout, Skip, or List of those; was "$metadata".');
       |        }
       |      }
       |
      0|      result[selector] = new Metadata.parse(timeout: timeout, skip: skip);
       |    });
       |    return result;
       |  }
       |
       |  /// Parses a user-provided [String] or [Iterable] into the value for [tags].
       |  ///
       |  /// Throws an [ArgumentError] if [tags] is not a [String] or an [Iterable].
       |  static Set<String> _parseTags(tags) {
      1|    if (tags == null) return new Set();
      0|    if (tags is String) return new Set.from([tags]);
      0|    if (tags is! Iterable) {
      0|      throw new ArgumentError.value(
       |          tags, "tags", "must be either a String or an Iterable.");
       |    }
       |
      0|    if (tags.any((tag) => tag is! String)) {
      0|      throw new ArgumentError.value(tags, "tags", "must contain only Strings.");
       |    }
       |
      0|    return new Set.from(tags);
       |  }
       |
       |  /// Creates new Metadata.
       |  ///
       |  /// [testOn] defaults to [PlatformSelector.all].
       |  ///
       |  /// If [forTag] contains metadata that applies to [tags], that metadata is
       |  /// included inline in the returned value. The values directly passed to the
       |  /// constructor take precedence over tag-specific metadata.
       |  factory Metadata(
       |      {PlatformSelector testOn,
       |      Timeout timeout,
       |      bool skip,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      String skipReason,
       |      Iterable<String> tags,
       |      Map<PlatformSelector, Metadata> onPlatform,
       |      Map<BooleanSelector, Metadata> forTag}) {
       |    // Returns metadata without forTag resolved at all.
      1|    _unresolved() => new Metadata._(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        verboseTrace: verboseTrace,
       |        chainStackTraces: chainStackTraces,
       |        skipReason: skipReason,
       |        tags: tags,
       |        onPlatform: onPlatform,
       |        forTag: forTag);
       |
       |    // If there's no tag-specific metadata, or if none of it applies, just
       |    // return the metadata as-is.
      1|    if (forTag == null || tags == null) return _unresolved();
      1|    tags = new Set.from(tags);
      1|    forTag = new Map.from(forTag);
       |
       |    // Otherwise, resolve the tag-specific components. Doing this eagerly means
       |    // we only have to resolve suite- or group-level tags once, rather than
       |    // doing it for every test individually.
      1|    var empty = new Metadata._();
      3|    var merged = forTag.keys.toList().fold(empty, (merged, selector) {
      0|      if (!selector.evaluate(tags)) return merged;
      0|      return merged.merge(forTag.remove(selector));
       |    });
       |
      2|    if (merged == empty) return _unresolved();
      0|    return merged.merge(_unresolved());
       |  }
       |
       |  /// Creates new Metadata.
       |  ///
       |  /// Unlike [new Metadata], this assumes [forTag] is already resolved.
       |  Metadata._(
       |      {PlatformSelector testOn,
       |      Timeout timeout,
       |      bool skip,
       |      this.skipReason,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      Iterable<String> tags,
       |      Map<PlatformSelector, Metadata> onPlatform,
       |      Map<BooleanSelector, Metadata> forTag})
       |      : testOn = testOn == null ? PlatformSelector.all : testOn,
       |        timeout = timeout == null ? const Timeout.factor(1) : timeout,
       |        _skip = skip,
       |        _verboseTrace = verboseTrace,
       |        _chainStackTraces = chainStackTraces,
      3|        tags = new UnmodifiableSetView(tags == null ? new Set() : tags.toSet()),
       |        onPlatform =
      1|            onPlatform == null ? const {} : new UnmodifiableMapView(onPlatform),
      2|        forTag = forTag == null ? const {} : new UnmodifiableMapView(forTag) {
      1|    _validateTags();
       |  }
       |
       |  /// Creates a new Metadata, but with fields parsed from caller-friendly values
       |  /// where applicable.
       |  ///
       |  /// Throws a [FormatException] if any field is invalid.
       |  Metadata.parse(
       |      {String testOn,
       |      Timeout timeout,
       |      skip,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      Map<String, dynamic> onPlatform,
       |      tags})
       |      : testOn = testOn == null
       |            ? PlatformSelector.all
      0|            : new PlatformSelector.parse(testOn),
       |        timeout = timeout == null ? const Timeout.factor(1) : timeout,
      0|        _skip = skip == null ? null : skip != false,
       |        _verboseTrace = verboseTrace,
       |        _chainStackTraces = chainStackTraces,
      1|        skipReason = skip is String ? skip : null,
      1|        onPlatform = _parseOnPlatform(onPlatform),
      1|        tags = _parseTags(tags),
      1|        forTag = const {} {
      0|    if (skip != null && skip is! String && skip is! bool) {
      0|      throw new ArgumentError(
      0|          '"skip" must be a String or a bool, was "$skip".');
       |    }
       |
      1|    _validateTags();
       |  }
       |
       |  /// Deserializes the result of [Metadata.serialize] into a new [Metadata].
       |  Metadata.deserialize(serialized)
      0|      : testOn = serialized['testOn'] == null
       |            ? PlatformSelector.all
      0|            : new PlatformSelector.parse(serialized['testOn']),
      0|        timeout = _deserializeTimeout(serialized['timeout']),
      0|        _skip = serialized['skip'],
      0|        skipReason = serialized['skipReason'],
      0|        _verboseTrace = serialized['verboseTrace'],
      0|        _chainStackTraces = serialized['chainStackTraces'],
      0|        tags = new Set.from(serialized['tags']),
      0|        onPlatform = new Map.fromIterable(serialized['onPlatform'],
      0|            key: (pair) => new PlatformSelector.parse(pair.first),
      0|            value: (pair) => new Metadata.deserialize(pair.last)),
      0|        forTag = mapMap(serialized['forTag'],
      0|            key: (key, _) => new BooleanSelector.parse(key),
      0|            value: (_, nested) => new Metadata.deserialize(nested));
       |
       |  /// Deserializes timeout from the format returned by [_serializeTimeout].
       |  static _deserializeTimeout(serialized) {
      0|    if (serialized == 'none') return Timeout.none;
      0|    var scaleFactor = serialized['scaleFactor'];
      0|    if (scaleFactor != null) return new Timeout.factor(scaleFactor);
      0|    return new Timeout(new Duration(microseconds: serialized['duration']));
       |  }
       |
       |  /// Throws an [ArgumentError] if any tags in [tags] aren't hyphenated
       |  /// identifiers.
       |  void _validateTags() {
      1|    var invalidTags = tags
      1|        .where((tag) => !tag.contains(anchoredHyphenatedIdentifier))
      1|        .map((tag) => '"$tag"')
      1|        .toList();
       |
      1|    if (invalidTags.isEmpty) return;
       |
      0|    throw new ArgumentError("Invalid ${pluralize('tag', invalidTags.length)} "
      0|        "${toSentence(invalidTags)}. Tags must be (optionally hyphenated) "
      0|        "Dart identifiers.");
       |  }
       |
       |  /// Return a new [Metadata] that merges [this] with [other].
       |  ///
       |  /// If the two [Metadata]s have conflicting properties, [other] wins. If
       |  /// either has a [forTag] metadata for one of the other's tags, that metadata
       |  /// is merged as well.
      1|  Metadata merge(Metadata other) => new Metadata(
      3|      testOn: testOn.intersection(other.testOn),
      3|      timeout: timeout.merge(other.timeout),
      2|      skip: other._skip ?? _skip,
      2|      skipReason: other.skipReason ?? skipReason,
      2|      verboseTrace: other._verboseTrace ?? _verboseTrace,
      2|      chainStackTraces: other._chainStackTraces ?? _chainStackTraces,
      3|      tags: tags.union(other.tags),
      3|      onPlatform: mergeMaps(onPlatform, other.onPlatform,
      0|          value: (metadata1, metadata2) => metadata1.merge(metadata2)),
      3|      forTag: mergeMaps(forTag, other.forTag,
      0|          value: (metadata1, metadata2) => metadata1.merge(metadata2)));
       |
       |  /// Returns a copy of [this] with the given fields changed.
       |  Metadata change(
       |      {PlatformSelector testOn,
       |      Timeout timeout,
       |      bool skip,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      String skipReason,
       |      Map<PlatformSelector, Metadata> onPlatform,
       |      Set<String> tags,
       |      Map<BooleanSelector, Metadata> forTag}) {
      0|    testOn ??= this.testOn;
      0|    timeout ??= this.timeout;
      0|    skip ??= this._skip;
      0|    verboseTrace ??= this._verboseTrace;
      0|    chainStackTraces ??= this._chainStackTraces;
      0|    skipReason ??= this.skipReason;
      0|    onPlatform ??= this.onPlatform;
      0|    tags ??= this.tags;
      0|    forTag ??= this.forTag;
      0|    return new Metadata(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        verboseTrace: verboseTrace,
       |        chainStackTraces: chainStackTraces,
       |        skipReason: skipReason,
       |        onPlatform: onPlatform,
       |        tags: tags,
       |        forTag: forTag);
       |  }
       |
       |  /// Returns a copy of [this] with all platform-specific metadata from
       |  /// [onPlatform] resolved.
       |  Metadata forPlatform(TestPlatform platform, {OperatingSystem os}) {
      2|    if (onPlatform.isEmpty) return this;
       |
       |    var metadata = this;
      0|    onPlatform.forEach((platformSelector, platformMetadata) {
      0|      if (!platformSelector.evaluate(platform, os: os)) return;
      0|      metadata = metadata.merge(platformMetadata);
       |    });
      0|    return metadata.change(onPlatform: {});
       |  }
       |
       |  /// Serializes [this] into a JSON-safe object that can be deserialized using
       |  /// [new Metadata.deserialize].
       |  serialize() {
       |    // Make this a list to guarantee that the order is preserved.
      0|    var serializedOnPlatform = [];
      0|    onPlatform.forEach((key, value) {
      0|      serializedOnPlatform.add([key.toString(), value.serialize()]);
       |    });
       |
      0|    return {
      0|      'testOn': testOn == PlatformSelector.all ? null : testOn.toString(),
      0|      'timeout': _serializeTimeout(timeout),
      0|      'skip': _skip,
      0|      'skipReason': skipReason,
      0|      'verboseTrace': _verboseTrace,
      0|      'chainStackTraces': _chainStackTraces,
      0|      'tags': tags.toList(),
       |      'onPlatform': serializedOnPlatform,
      0|      'forTag': mapMap(forTag,
      0|          key: (selector, _) => selector.toString(),
      0|          value: (_, metadata) => metadata.serialize())
       |    };
       |  }
       |
       |  /// Serializes timeout into a JSON-safe object.
       |  _serializeTimeout(Timeout timeout) {
      0|    if (timeout == Timeout.none) return 'none';
      0|    return {
       |      'duration':
      0|          timeout.duration == null ? null : timeout.duration.inMicroseconds,
      0|      'scaleFactor': timeout.scaleFactor
       |    };
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/test.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import 'group.dart';
       |import 'group_entry.dart';
       |import 'live_test.dart';
       |import 'metadata.dart';
       |import 'operating_system.dart';
       |import 'suite.dart';
       |import 'test_platform.dart';
       |
       |/// A single test.
       |///
       |/// A test is immutable and stateless, which means that it can't be run
       |/// directly. To run one, load a live version using [Test.load] and run it using
       |/// [LiveTest.run].
       |abstract class Test implements GroupEntry {
       |  String get name;
       |
       |  Metadata get metadata;
       |
       |  Trace get trace;
       |
       |  /// Loads a live version of this test, which can be used to run it a single
       |  /// time.
       |  ///
       |  /// [suite] is the suite within which this test is being run. If [groups] is
       |  /// passed, it's the list of groups containing this test; otherwise, it
       |  /// defaults to just containing `suite.group`.
       |  LiveTest load(Suite suite, {Iterable<Group> groups});
       |
       |  Test forPlatform(TestPlatform platform, {OperatingSystem os});
       |
      0|  Test filter(bool callback(Test test)) => callback(this) ? this : null;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/load_suite.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../../test.dart';
       |import '../backend/group.dart';
       |import '../backend/invoker.dart';
       |import '../backend/metadata.dart';
       |import '../backend/suite.dart';
       |import '../backend/test.dart';
       |import '../backend/test_platform.dart';
       |import '../utils.dart';
       |import 'configuration/suite.dart';
       |import 'load_exception.dart';
       |import 'plugin/environment.dart';
       |import 'runner_suite.dart';
       |
       |/// A [Suite] emitted by a [Loader] that provides a test-like interface for
       |/// loading a test file.
       |///
       |/// This is used to expose the current status of test loading to the user. It's
       |/// important to provide users visibility into what's taking a long time and
       |/// where failures occur. And since some tests may be loaded at the same time as
       |/// others are run, it's useful to provide that visibility in the form of a test
       |/// suite so that it can integrate well into the existing reporting interface
       |/// without too much extra logic.
       |///
       |/// A suite is constructed with logic necessary to produce a test suite. As with
       |/// a normal test body, this logic isn't run until [LiveTest.run] is called. The
       |/// suite itself is returned by [suite] once it's avaialble, but any errors or
       |/// prints will be emitted through the running [LiveTest].
       |class LoadSuite extends Suite implements RunnerSuite {
       |  final environment = const PluginEnvironment();
       |  final SuiteConfiguration config;
       |  final isDebugging = false;
       |  final onDebugging = new StreamController<bool>().stream;
       |
       |  /// A future that completes to the loaded suite once the suite's test has been
       |  /// run and completed successfully.
       |  ///
       |  /// This will return `null` if the suite is unavailable for some reason (for
       |  /// example if an error occurred while loading it).
      0|  Future<RunnerSuite> get suite async => (await _suiteAndZone)?.first;
       |
       |  /// A future that completes to a pair of [suite] and the load test's [Zone].
       |  ///
       |  /// This will return `null` if the suite is unavailable for some reason (for
       |  /// example if an error occurred while loading it).
       |  final Future<Pair<RunnerSuite, Zone>> _suiteAndZone;
       |
       |  /// Returns the test that loads the suite.
       |  ///
       |  /// Load suites are guaranteed to only contain one test. This is a utility
       |  /// method for accessing it directly.
      0|  Test get test => this.group.entries.single as Test;
       |
       |  /// Creates a load suite named [name] on [platform].
       |  ///
       |  /// [body] may return either a [RunnerSuite] or a [Future] that completes to a
       |  /// [RunnerSuite]. Its return value is forwarded through [suite], although if
       |  /// it throws an error that will be forwarded through the suite's test.
       |  ///
       |  /// If the the load test is closed before [body] is complete, it will close
       |  /// the suite returned by [body] once it completes.
       |  factory LoadSuite(
       |      String name, SuiteConfiguration config, FutureOr<RunnerSuite> body(),
       |      {String path, TestPlatform platform}) {
      0|    var completer = new Completer<Pair<RunnerSuite, Zone>>.sync();
      0|    return new LoadSuite._(name, config, () {
      0|      var invoker = Invoker.current;
      0|      invoker.addOutstandingCallback();
       |
      0|      invoke(() async {
       |        try {
      0|          var suite = await body();
      0|          if (completer.isCompleted) {
       |            // If the load test has already been closed, close the suite it
       |            // generated.
      0|            suite.close();
      0|            return;
       |          }
       |
       |          completer
      0|              .complete(suite == null ? null : new Pair(suite, Zone.current));
      0|          invoker.removeOutstandingCallback();
       |        } catch (error, stackTrace) {
      0|          registerException(error, stackTrace);
      0|          if (!completer.isCompleted) completer.complete();
       |        }
      0|      });
       |
       |      // If the test is forcibly closed, exit immediately. It doesn't have any
       |      // cleanup to do that won't be handled by Loader.close.
      0|      invoker.onClose.then((_) {
      0|        if (completer.isCompleted) return;
      0|        completer.complete();
      0|        invoker.removeOutstandingCallback();
       |      });
      0|    }, completer.future, path: path, platform: platform);
       |  }
       |
       |  /// A utility constructor for a load suite that just throws [exception].
       |  ///
       |  /// The suite's name will be based on [exception]'s path.
       |  factory LoadSuite.forLoadException(
       |      LoadException exception, SuiteConfiguration config,
       |      {StackTrace stackTrace, TestPlatform platform}) {
      0|    if (stackTrace == null) stackTrace = new Trace.current();
       |
      0|    return new LoadSuite(
      0|        "loading ${exception.path}",
      0|        config ?? SuiteConfiguration.empty,
      0|        () => new Future.error(exception, stackTrace),
      0|        path: exception.path,
       |        platform: platform);
       |  }
       |
       |  /// A utility constructor for a load suite that just emits [suite].
       |  factory LoadSuite.forSuite(RunnerSuite suite) {
      0|    return new LoadSuite("loading ${suite.path}", suite.config, () => suite,
      0|        path: suite.path, platform: suite.platform);
       |  }
       |
       |  LoadSuite._(String name, this.config, void body(), this._suiteAndZone,
       |      {String path, TestPlatform platform})
      0|      : super(
      0|            new Group.root([
      0|              new LocalTest(
       |                  name,
      0|                  new Metadata(timeout: new Timeout(new Duration(minutes: 5))),
       |                  body)
       |            ]),
       |            path: path,
       |            platform: platform);
       |
       |  /// A constructor used by [changeSuite].
       |  LoadSuite._changeSuite(LoadSuite old, this._suiteAndZone)
      0|      : config = old.config,
      0|        super(old.group, path: old.path, platform: old.platform);
       |
       |  /// A constructor used by [filter].
       |  LoadSuite._filtered(LoadSuite old, Group filtered)
      0|      : config = old.config,
      0|        _suiteAndZone = old._suiteAndZone,
      0|        super(old.group, path: old.path, platform: old.platform);
       |
       |  /// Creates a new [LoadSuite] that's identical to this one, but that
       |  /// transforms [suite] once it's loaded.
       |  ///
       |  /// If [suite] completes to `null`, [change] won't be run. [change] is run
       |  /// within the load test's zone, so any errors or prints it emits will be
       |  /// associated with that test.
       |  LoadSuite changeSuite(RunnerSuite change(RunnerSuite suite)) {
      0|    return new LoadSuite._changeSuite(this, _suiteAndZone.then((pair) {
       |      if (pair == null) return null;
       |
      0|      var zone = pair.last;
      0|      var newSuite = zone.runUnaryGuarded(change, pair.first);
      0|      return newSuite == null ? null : new Pair(newSuite, zone);
       |    }));
       |  }
       |
       |  /// Runs the test and returns the suite.
       |  ///
       |  /// Rather than emitting errors through a [LiveTest], this just pipes them
       |  /// through the return value.
       |  Future<RunnerSuite> getSuite() async {
      0|    var liveTest = await test.load(this);
      0|    liveTest.onMessage.listen((message) => print(message.text));
      0|    await liveTest.run();
       |
      0|    if (liveTest.errors.isEmpty) return await suite;
       |
      0|    var error = liveTest.errors.first;
      0|    await new Future.error(error.error, error.stackTrace);
       |    throw 'unreachable';
       |  }
       |
       |  LoadSuite filter(bool callback(Test test)) {
      0|    var filtered = this.group.filter(callback);
      0|    if (filtered == null) filtered = new Group.root([], metadata: metadata);
      0|    return new LoadSuite._filtered(this, filtered);
       |  }
       |
      0|  Future close() async {}
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/closed_exception.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An exception thrown by various front-end methods when the test framework has
       |/// been closed and a test must shut down as soon as possible.
       |class ClosedException implements Exception {
      0|  ClosedException();
       |
       |  String toString() => "This test has been closed.";
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/live_test.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'group.dart';
       |import 'message.dart';
       |import 'state.dart';
       |import 'suite.dart';
       |import 'test.dart';
       |
       |/// A runnable instance of a test.
       |///
       |/// This is distinct from [Test] in order to keep [Test] immutable. Running a
       |/// test requires state, and [LiveTest] provides a view of the state of the test
       |/// as it runs.
       |///
       |/// If the state changes, [state] will be updated before [onStateChange] fires.
       |/// Likewise, if an error is caught, it will be added to [errors] before being
       |/// emitted via [onError]. If an error causes a state change, [onStateChange]
       |/// will fire before [onError]. If an error or other state change causes the
       |/// test to complete, [onComplete] will complete after [onStateChange] and
       |/// [onError] fire.
       |abstract class LiveTest {
       |  /// The suite within which this test is being run.
       |  Suite get suite;
       |
       |  /// The groups within which this test is being run, from the outermost to the
       |  /// innermost.
       |  ///
       |  /// This will always contain at least the implicit top-level group.
       |  List<Group> get groups;
       |
       |  /// The running test.
       |  Test get test;
       |
       |  /// The current state of the running test.
       |  ///
       |  /// This starts as [Status.pending] and [Result.success]. It will be updated
       |  /// before [onStateChange] fires.
       |  ///
       |  /// Note that even if this is marked [Status.complete], the test may still be
       |  /// running code asynchronously. A test is considered complete either once it
       |  /// hits its first error or when all [expectAsync] callbacks have been called
       |  /// and any returned [Future] has completed, but it's possible for further
       |  /// processing to happen, which may cause further errors. It's even possible
       |  /// for a test that was marked [Status.complete] and [Result.success] to be
       |  /// marked as [Result.error] later.
       |  State get state;
       |
       |  /// Returns whether this test has completed.
       |  ///
       |  /// This is equivalent to [state.status] being [Status.complete].
       |  ///
       |  /// Note that even if this returns `true`, the test may still be
       |  /// running code asynchronously. A test is considered complete either once it
       |  /// hits its first error or when all [expectAsync] callbacks have been called
       |  /// and any returned [Future] has completed, but it's possible for further
       |  /// processing to happen, which may cause further errors.
      3|  bool get isComplete => state.status == Status.complete;
       |
       |  // A stream that emits a new [State] whenever [state] changes.
       |  //
       |  // This will only ever emit a [State] if it's different than the previous
       |  // [state]. It will emit an event after [state] has been updated. Note that
       |  // since this is an asynchronous stream, it's possible for [state] not to
       |  // match the [State] that it emits within the [Stream.listen] callback.
       |  Stream<State> get onStateChange;
       |
       |  /// An unmodifiable list of all errors that have been caught while running
       |  /// this test.
       |  ///
       |  /// This will be updated before [onError] fires. These errors are not
       |  /// guaranteed to have the same types as when they were thrown; for example,
       |  /// they may need to be serialized across isolate boundaries. The stack traces
       |  /// will be [Chain]s.
       |  List<AsyncError> get errors;
       |
       |  /// A stream that emits a new [AsyncError] whenever an error is caught.
       |  ///
       |  /// This will be emit an event after [errors] is updated. These errors are not
       |  /// guaranteed to have the same types as when they were thrown; for example,
       |  /// they may need to be serialized across isolate boundaries. The stack traces
       |  /// will be [Chain]s.
       |  Stream<AsyncError> get onError;
       |
       |  /// A stream that emits messages produced by the test.
       |  Stream<Message> get onMessage;
       |
       |  /// A [Future] that completes once the test is complete.
       |  ///
       |  /// This will complete after [onStateChange] has fired, and after [onError]
       |  /// has fired if the test completes because of an error. It's the same as the
       |  /// [Future] returned by [run].
       |  ///
       |  /// Note that even once this completes, the test may still be running code
       |  /// asynchronously. A test is considered complete either once it hits its
       |  /// first error or when all [expectAsync] callbacks have been called and any
       |  /// returned [Future] has completed, but it's possible for further processing
       |  /// to happen, which may cause further errors.
       |  Future get onComplete;
       |
       |  /// The name of this live test without any group prefixes.
       |  String get individualName {
      0|    var group = groups.last;
      0|    if (group.name == null) return test.name;
      0|    if (!test.name.startsWith(group.name)) return test.name;
       |
       |    // The test will have the same name as the group for virtual tests created
       |    // to represent skipping the entire group.
      0|    if (test.name.length == group.name.length) return "";
       |
      0|    return test.name.substring(group.name.length + 1);
       |  }
       |
       |  /// Loads a copy of this [LiveTest] that's able to be run again.
      0|  LiveTest copy() => test.load(suite, groups: groups);
       |
       |  /// Signals that this test should start running as soon as possible.
       |  ///
       |  /// A test may not start running immediately for various reasons specific to
       |  /// the means by which it's defined. Until it starts running, [state] will
       |  /// continue to be marked [Status.pending].
       |  ///
       |  /// This returns the same [Future] as [onComplete]. It may not be called more
       |  /// than once.
       |  Future run();
       |
       |  /// Signals that this test should stop emitting events and release any
       |  /// resources it may have allocated.
       |  ///
       |  /// Once [close] is called, [onComplete] will complete if it hasn't already
       |  /// and [onStateChange] and [onError] will close immediately. This means that,
       |  /// if the test was running at the time [close] is called, it will never emit
       |  /// a [Status.complete] state-change event. Once a test is closed, [expect]
       |  /// and [expectAsync] will throw a [ClosedException] to help the test
       |  /// terminate as quickly as possible.
       |  ///
       |  /// This doesn't automatically happen after the test completes because there
       |  /// may be more asynchronous work going on in the background that could
       |  /// produce new errors.
       |  ///
       |  /// Returns a [Future] that completes once all resources are released *and*
       |  /// the test has completed. This allows the caller to wait until the test's
       |  /// tear-down logic has run.
       |  Future close();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/live_test_controller.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import 'group.dart';
       |import 'live_test.dart';
       |import 'message.dart';
       |import 'state.dart';
       |import 'suite.dart';
       |import 'test.dart';
       |
       |/// An implementation of [LiveTest] that's controlled by a [LiveTestController].
       |class _LiveTest extends LiveTest {
       |  final LiveTestController _controller;
       |
      2|  Suite get suite => _controller._suite;
       |
      0|  List<Group> get groups => _controller._groups;
       |
      2|  Test get test => _controller._test;
       |
      2|  State get state => _controller._state;
       |
       |  Stream<State> get onStateChange =>
      3|      _controller._onStateChangeController.stream;
       |
      0|  List<AsyncError> get errors => new UnmodifiableListView(_controller._errors);
       |
      3|  Stream<AsyncError> get onError => _controller._onErrorController.stream;
       |
      3|  Stream<Message> get onMessage => _controller._onMessageController.stream;
       |
      3|  Future get onComplete => _controller.completer.future;
       |
      2|  Future run() => _controller._run();
       |
      0|  Future close() => _controller._close();
       |
      1|  _LiveTest(this._controller);
       |}
       |
       |/// A controller that drives a [LiveTest].
       |///
       |/// This is a utility class to make it easier for implementors of [Test] to
       |/// create the [LiveTest] returned by [Test.load]. The [LiveTest] is accessible
       |/// through [LiveTestController.liveTest].
       |///
       |/// This automatically handles some of [LiveTest]'s guarantees, but for the most
       |/// part it's the caller's responsibility to make sure everything gets
       |/// dispatched in the correct order.
       |class LiveTestController {
       |  /// The [LiveTest] controlled by [this].
      1|  LiveTest get liveTest => _liveTest;
       |  LiveTest _liveTest;
       |
       |  /// The test suite that's running [this].
       |  final Suite _suite;
       |
       |  /// The groups containing [this].
       |  final List<Group> _groups;
       |
       |  /// The test that's being run.
       |  final Test _test;
       |
       |  /// The function that will actually start the test running.
       |  final Function _onRun;
       |
       |  /// A function to run when the test is closed.
       |  ///
       |  /// This may be `null`.
       |  final Function _onClose;
       |
       |  /// The list of errors caught by the test.
       |  final _errors = new List<AsyncError>();
       |
       |  /// The current state of the test.
       |  var _state = const State(Status.pending, Result.success);
       |
       |  /// The controller for [LiveTest.onStateChange].
       |  ///
       |  /// This is synchronous to ensure that events are well-ordered across multiple
       |  /// streams.
       |  final _onStateChangeController =
       |      new StreamController<State>.broadcast(sync: true);
       |
       |  /// The controller for [LiveTest.onError].
       |  ///
       |  /// This is synchronous to ensure that events are well-ordered across multiple
       |  /// streams.
       |  final _onErrorController =
       |      new StreamController<AsyncError>.broadcast(sync: true);
       |
       |  /// The controller for [LiveTest.onMessage].
       |  ///
       |  /// This is synchronous to ensure that events are well-ordered across multiple
       |  /// streams.
       |  final _onMessageController =
       |      new StreamController<Message>.broadcast(sync: true);
       |
       |  /// The completer for [LiveTest.onComplete];
       |  final completer = new Completer();
       |
       |  /// Whether [run] has been called.
       |  var _runCalled = false;
       |
       |  /// Whether [close] has been called.
      2|  bool get _isClosed => _onErrorController.isClosed;
       |
       |  /// Creates a new controller for a [LiveTest].
       |  ///
       |  /// [test] is the test being run; [suite] is the suite that contains it.
       |  ///
       |  /// [onRun] is a function that's called from [LiveTest.run]. It should start
       |  /// the test running. The controller takes care of ensuring that
       |  /// [LiveTest.run] isn't called more than once and that [LiveTest.onComplete]
       |  /// is returned.
       |  ///
       |  /// [onClose] is a function that's called the first time [LiveTest.close] is
       |  /// called. It should clean up any resources that have been allocated for the
       |  /// test and ensure that the test finishes quickly if it's still running. It
       |  /// will only be called if [onRun] has been called first.
       |  ///
       |  /// If [groups] is passed, it's used to populate the list of groups that
       |  /// contain this test. Otherwise, `suite.group` is used.
       |  LiveTestController(Suite suite, this._test, void onRun(), void onClose(),
       |      {Iterable<Group> groups})
       |      : _suite = suite,
       |        _onRun = onRun,
       |        _onClose = onClose,
       |        _groups =
      2|            groups == null ? [suite.group] : new List.unmodifiable(groups) {
      2|    _liveTest = new _LiveTest(this);
       |  }
       |
       |  /// Adds an error to the [LiveTest].
       |  ///
       |  /// This both adds the error to [LiveTest.errors] and emits it via
       |  /// [LiveTest.onError]. [stackTrace] is automatically converted into a [Chain]
       |  /// if it's not one already.
       |  void addError(error, StackTrace stackTrace) {
      1|    if (_isClosed) return;
       |
      2|    var asyncError = new AsyncError(error, new Chain.forTrace(stackTrace));
      2|    _errors.add(asyncError);
      2|    _onErrorController.add(asyncError);
       |  }
       |
       |  /// Sets the current state of the [LiveTest] to [newState].
       |  ///
       |  /// If [newState] is different than the old state, this both sets
       |  /// [LiveTest.state] and emits the new state via [LiveTest.onStateChanged]. If
       |  /// it's not different, this does nothing.
       |  void setState(State newState) {
      1|    if (_isClosed) return;
      2|    if (_state == newState) return;
       |
      1|    _state = newState;
      2|    _onStateChangeController.add(newState);
       |  }
       |
       |  /// Emits message over [LiveTest.onMessage].
       |  void message(Message message) {
      2|    if (_onMessageController.hasListener) {
      2|      _onMessageController.add(message);
       |    } else {
       |      // Make sure all messages get surfaced one way or another to aid in
       |      // debugging.
      0|      Zone.ROOT.print(message.text);
       |    }
       |  }
       |
       |  /// A wrapper for [_onRun] that ensures that it follows the guarantees for
       |  /// [LiveTest.run].
       |  Future _run() {
      1|    if (_runCalled) {
      0|      throw new StateError("LiveTest.run() may not be called more than once.");
      1|    } else if (_isClosed) {
      0|      throw new StateError("LiveTest.run() may not be called for a closed "
       |          "test.");
       |    }
      1|    _runCalled = true;
       |
      2|    _onRun();
      2|    return liveTest.onComplete;
       |  }
       |
       |  /// A wrapper for [_onClose] that ensures that all controllers are closed.
       |  Future _close() {
      0|    if (_isClosed) return completer.future;
       |
      0|    _onStateChangeController.close();
      0|    _onErrorController.close();
       |
      0|    if (_runCalled) {
      0|      _onClose();
       |    } else {
      0|      completer.complete();
       |    }
       |
      0|    return completer.future;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/message.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A message emitted by a test.
       |///
       |/// A message encompasses any textual information that should be presented to
       |/// the user. Reporters are encouraged to visually distinguish different message
       |/// types.
       |class Message {
       |  final MessageType type;
       |
       |  final String text;
       |
      0|  Message(this.type, this.text);
       |
      1|  Message.print(this.text) : type = MessageType.print;
      0|  Message.skip(this.text) : type = MessageType.skip;
       |}
       |
       |class MessageType {
       |  /// A message explicitly printed by the user's test.
       |  static const print = const MessageType._("print");
       |
       |  /// A message indicating that a test, or some portion of one, was skipped.
       |  static const skip = const MessageType._("skip");
       |
       |  /// The name of the message type.
       |  final String name;
       |
       |  factory MessageType.parse(String name) {
       |    switch (name) {
      0|      case "print":
       |        return MessageType.print;
      0|      case "skip":
       |        return MessageType.skip;
       |      default:
      0|        throw new ArgumentError('Invalid message type "$name".');
       |    }
       |  }
       |
      1|  const MessageType._(this.name);
       |
      0|  String toString() => name;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/operating_system.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An enum of all operating systems supported by Dart.
       |///
       |/// This is used for selecting which operating systems a test can run on. Even
       |/// for browser tests, this indicates the operating system of the machine
       |/// running the test runner.
       |class OperatingSystem {
       |  /// Microsoft Windows.
       |  static const windows = const OperatingSystem._("Windows", "windows");
       |
       |  /// Mac OS X.
       |  static const macOS = const OperatingSystem._("OS X", "mac-os");
       |
       |  /// GNU/Linux.
       |  static const linux = const OperatingSystem._("Linux", "linux");
       |
       |  /// Android.
       |  ///
       |  /// Since this is the operating system the test runner is running on, this
       |  /// won't be true when testing remotely on an Android browser.
       |  static const android = const OperatingSystem._("Android", "android");
       |
       |  /// iOS.
       |  ///
       |  /// Since this is the operating system the test runner is running on, this
       |  /// won't be true when testing remotely on an iOS browser.
       |  static const iOS = const OperatingSystem._("iOS", "ios");
       |
       |  /// No operating system.
       |  ///
       |  /// This is used when running in the browser, or if an unrecognized operating
       |  /// system is used. It can't be referenced by name in platform selectors.
       |  static const none = const OperatingSystem._("none", "none");
       |
       |  /// A list of all instances of [OperatingSystem] other than [none].
       |  static const all = const [windows, macOS, linux, android, iOS];
       |
       |  /// Finds an operating system by its name.
       |  ///
       |  /// If no operating system is found, returns [none].
       |  static OperatingSystem find(String identifier) =>
      0|      all.firstWhere((platform) => platform.identifier == identifier,
       |          orElse: () => null);
       |
       |  /// Finds an operating system by the return value from `dart:io`'s
       |  /// `Platform.operatingSystem`.
       |  ///
       |  /// If no operating system is found, returns [none].
       |  static OperatingSystem findByIoName(String name) {
       |    switch (name) {
      0|      case "windows":
       |        return windows;
      0|      case "macos":
       |        return macOS;
      0|      case "linux":
       |        return linux;
      0|      case "android":
       |        return android;
      0|      case "ios":
       |        return iOS;
       |      default:
       |        return none;
       |    }
       |  }
       |
       |  /// The human-friendly of the operating system.
       |  final String name;
       |
       |  /// The identifier used to look up the operating system.
       |  final String identifier;
       |
       |  /// Whether this is a POSIX-ish operating system.
      0|  bool get isPosix => this != windows && this != none;
       |
      1|  const OperatingSystem._(this.name, this.identifier);
       |
      0|  String toString() => name;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/outstanding_callback_counter.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A class that counts outstanding callbacks for a test and fires a future once
       |/// they reach zero.
       |///
       |/// The outstanding callback count automatically starts at 1.
       |class OutstandingCallbackCounter {
       |  /// The number of outstanding callbacks.
       |  var _count = 1;
       |
       |  /// A future that fires when the oustanding callback count reaches 0.
      2|  Future get noOutstandingCallbacks => _completer.future;
       |  final _completer = new Completer();
       |
       |  /// Adds an outstanding callback.
       |  void addOutstandingCallback() {
      0|    _count++;
       |  }
       |
       |  /// Removes an outstanding callback.
       |  void removeOutstandingCallback() {
      2|    _count--;
      2|    if (_count != 0) return;
      2|    if (_completer.isCompleted) return;
      2|    _completer.complete();
       |  }
       |
       |  /// Removes all outstanding callbacks, forcing [noOutstandingCallbacks] to
       |  /// fire.
       |  ///
       |  /// Future calls to [addOutstandingCallback] and [removeOutstandingCallback]
       |  /// will be ignored.
       |  void removeAllOutstandingCallbacks() {
      4|    if (!_completer.isCompleted) _completer.complete();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/state.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// The state of a [LiveTest].
       |///
       |/// A test's state is made up of two components, its [status] and its [result].
       |/// The [status] represents where the test is in its process of running; the
       |/// [result] represents the outcome as far as its known.
       |class State {
       |  /// Where the test is in its process of running.
       |  final Status status;
       |
       |  /// The outcome of the test, as far as it's known.
       |  ///
       |  /// Note that if [status] is [Status.pending], [result] will always be
       |  /// [Result.success] since the test hasn't yet had a chance to fail.
       |  final Result result;
       |
       |  /// Whether a test in this state is expected to be done running code.
       |  ///
       |  /// If [status] is [Status.complete] and [result] doesn't indicate an error, a
       |  /// properly-written test case should not be running any more code. However,
       |  /// it may have started asynchronous processes without notifying the test
       |  /// runner.
      2|  bool get shouldBeDone => status == Status.complete && result.isPassing;
       |
      1|  const State(this.status, this.result);
       |
       |  bool operator ==(other) =>
      7|      other is State && status == other.status && result == other.result;
       |
      0|  int get hashCode => status.hashCode ^ (7 * result.hashCode);
       |
       |  String toString() {
      0|    if (status == Status.pending) return "pending";
      0|    if (status == Status.complete) return result.toString();
      0|    if (result == Result.success) return "running";
      0|    return "running with $result";
       |  }
       |}
       |
       |/// Where the test is in its process of running.
       |class Status {
       |  /// The test has not yet begun running.
       |  static const pending = const Status._("pending");
       |
       |  /// The test is currently running.
       |  static const running = const Status._("running");
       |
       |  /// The test has finished running.
       |  ///
       |  /// Note that even if the test is marked [complete], it may still be running
       |  /// code asynchronously. A test is considered complete either once it hits its
       |  /// first error or when all [expectAsync] callbacks have been called and any
       |  /// returned [Future] has completed, but it's possible for further processing
       |  /// to happen, which may cause further errors.
       |  static const complete = const Status._("complete");
       |
       |  /// The name of the status.
       |  final String name;
       |
       |  factory Status.parse(String name) {
       |    switch (name) {
      0|      case "pending":
       |        return Status.pending;
      0|      case "running":
       |        return Status.running;
      0|      case "complete":
       |        return Status.complete;
       |      default:
      0|        throw new ArgumentError('Invalid status name "$name".');
       |    }
       |  }
       |
      1|  const Status._(this.name);
       |
      0|  String toString() => name;
       |}
       |
       |/// The outcome of the test, as far as it's known.
       |class Result {
       |  /// The test has not yet failed in any way.
       |  ///
       |  /// Note that this doesn't mean that the test won't fail in the future.
       |  static const success = const Result._("success");
       |
       |  /// The test, or some part of it, has been skipped.
       |  ///
       |  /// This implies that the test hasn't failed *yet*. However, it this doesn't
       |  /// mean that the test won't fail in the future.
       |  static const skipped = const Result._("skipped");
       |
       |  /// The test has failed.
       |  ///
       |  /// A failure is specifically caused by a [TestFailure] being thrown; any
       |  /// other exception causes an error.
       |  static const failure = const Result._("failure");
       |
       |  /// The test has crashed.
       |  ///
       |  /// Any exception other than a [TestFailure] is considered to be an error.
       |  static const error = const Result._("error");
       |
       |  /// The name of the result.
       |  final String name;
       |
       |  /// Whether this is a passing result.
       |  ///
       |  /// A test is considered to have passed if it's a success or if it was
       |  /// skipped.
      2|  bool get isPassing => this == success || this == skipped;
       |
       |  /// Whether this is a failing result.
       |  ///
       |  /// A test is considered to have failed if it experiences a failure or an
       |  /// error.
      0|  bool get isFailing => !isPassing;
       |
       |  factory Result.parse(String name) {
       |    switch (name) {
      0|      case "success":
       |        return Result.success;
      0|      case "skipped":
       |        return Result.skipped;
      0|      case "failure":
       |        return Result.failure;
      0|      case "error":
       |        return Result.error;
       |      default:
      0|        throw new ArgumentError('Invalid result name "$name".');
       |    }
       |  }
       |
      1|  const Result._(this.name);
       |
      0|  String toString() => name;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/suite.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'group.dart';
       |import 'metadata.dart';
       |import 'operating_system.dart';
       |import 'test.dart';
       |import 'test_platform.dart';
       |
       |/// A test suite.
       |///
       |/// A test suite is a set of tests that are intended to be run together and that
       |/// share default configuration.
       |class Suite {
       |  /// The platform on which the suite is running, or `null` if that platform is
       |  /// unknown.
       |  final TestPlatform platform;
       |
       |  /// The operating system on which the suite is running, or `null` if that
       |  /// operating system is unknown.
       |  ///
       |  /// This will always be `null` if [platform] is `null`.
       |  final OperatingSystem os;
       |
       |  /// The path to the Dart test suite, or `null` if that path is unknown.
       |  final String path;
       |
       |  /// The metadata associated with this test suite.
       |  ///
       |  /// This is a shortcut for [group.metadata].
      0|  Metadata get metadata => group.metadata;
       |
       |  /// The top-level group for this test suite.
       |  final Group group;
       |
       |  /// Creates a new suite containing [entires].
       |  ///
       |  /// If [platform] and/or [os] are passed, [group] is filtered to match that
       |  /// platform information.
       |  ///
       |  /// If [os] is passed without [platform], throws an [ArgumentError].
       |  Suite(Group group, {this.path, TestPlatform platform, OperatingSystem os})
       |      : platform = platform,
       |        os = os,
      2|        group = _filterGroup(group, platform, os);
       |
       |  /// Returns [entries] filtered according to [platform] and [os].
       |  ///
       |  /// Gracefully handles [platform] being null.
       |  static Group _filterGroup(
       |      Group group, TestPlatform platform, OperatingSystem os) {
       |    if (platform == null && os != null) {
      0|      throw new ArgumentError.value(
       |          null, "os", "If os is passed, platform must be passed as well");
       |    }
       |
       |    if (platform == null) return group;
      1|    var filtered = group.forPlatform(platform, os: os);
       |    if (filtered != null) return filtered;
      0|    return new Group.root([], metadata: group.metadata);
       |  }
       |
       |  /// Returns a new suite with all tests matching [test] removed.
       |  ///
       |  /// Unlike [GroupEntry.filter], this never returns `null`. If all entries are
       |  /// filtered out, it returns an empty suite.
       |  Suite filter(bool callback(Test test)) {
      0|    var filtered = group.filter(callback);
      0|    if (filtered == null) filtered = new Group.root([], metadata: metadata);
      0|    return new Suite(filtered, platform: platform, os: os, path: path);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/term_glyph-1.0.0/lib/term_glyph.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |export 'src/generated.dart';
       |
       |import 'src/generated.dart';
       |
       |/// Returns [glyph] if Unicode glyph are allowed, and [alternative] if they
       |/// aren't.
       |String glyphOrAscii(String glyph, String alternative) =>
      0|    ascii ? alternative : glyph;
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/util/stream_queue.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// TODO(nweiz): Get rid of this when https://codereview.chromium.org/1241723003/
       |// lands.
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import "package:async/async.dart" hide ForkableStream, StreamQueue;
       |
       |import "forkable_stream.dart";
       |
       |/// An asynchronous pull-based interface for accessing stream events.
       |///
       |/// Wraps a stream and makes individual events available on request.
       |///
       |/// You can request (and reserve) one or more events from the stream,
       |/// and after all previous requests have been fulfilled, stream events
       |/// go towards fulfilling your request.
       |///
       |/// For example, if you ask for [next] two times, the returned futures
       |/// will be completed by the next two unrequested events from the stream.
       |///
       |/// The stream subscription is paused when there are no active
       |/// requests.
       |///
       |/// Some streams, including broadcast streams, will buffer
       |/// events while paused, so waiting too long between requests may
       |/// cause memory bloat somewhere else.
       |///
       |/// This is similar to, but more convenient than, a [StreamIterator].
       |/// A `StreamIterator` requires you to manually check when a new event is
       |/// available and you can only access the value of that event until you
       |/// check for the next one. A `StreamQueue` allows you to request, for example,
       |/// three events at a time, either individually, as a group using [take]
       |/// or [skip], or in any combination.
       |///
       |/// You can also ask to have the [rest] of the stream provided as
       |/// a new stream. This allows, for example, taking the first event
       |/// out of a stream and continuing to use the rest of the stream as a stream.
       |///
       |/// Example:
       |///
       |///     var events = new StreamQueue<String>(someStreamOfLines);
       |///     var first = await events.next;
       |///     while (first.startsWith('#')) {
       |///       // Skip comments.
       |///       first = await events.next;
       |///     }
       |///
       |///     if (first.startsWith(MAGIC_MARKER)) {
       |///       var headerCount =
       |///           first.parseInt(first.substring(MAGIC_MARKER.length + 1));
       |///       handleMessage(headers: await events.take(headerCount),
       |///                     body: events.rest);
       |///       return;
       |///     }
       |///     // Error handling.
       |///
       |/// When you need no further events the `StreamQueue` should be closed
       |/// using [cancel]. This releases the underlying stream subscription.
       |class StreamQueue<T> {
       |  // This class maintains two queues: one of events and one of requests.
       |  // The active request (the one in front of the queue) is called with
       |  // the current event queue when it becomes active.
       |  //
       |  // If the request returns true, it's complete and will be removed from the
       |  // request queue.
       |  // If the request returns false, it needs more events, and will be called
       |  // again when new events are available.
       |  // The request can remove events that it uses, or keep them in the event
       |  // queue until it has all that it needs.
       |  //
       |  // This model is very flexible and easily extensible.
       |  // It allows requests that don't consume events (like [hasNext]) or
       |  // potentially a request that takes either five or zero events, determined
       |  // by the content of the fifth event.
       |
       |  /// Source of events.
       |  final ForkableStream<T> _sourceStream;
       |
       |  /// Subscription on [_sourceStream] while listening for events.
       |  ///
       |  /// Set to subscription when listening, and set to `null` when the
       |  /// subscription is done (and [_isDone] is set to true).
       |  StreamSubscription<T> _subscription;
       |
       |  /// Whether we have listened on [_sourceStream] and the subscription is done.
       |  bool _isDone = false;
       |
       |  /// Whether a closing operation has been performed on the stream queue.
       |  ///
       |  /// Closing operations are [cancel] and [rest].
       |  bool _isClosed = false;
       |
       |  /// Queue of events not used by a request yet.
       |  final Queue<Result> _eventQueue = new Queue();
       |
       |  /// Queue of pending requests.
       |  ///
       |  /// Access through methods below to ensure consistency.
       |  final Queue<_EventRequest> _requestQueue = new Queue();
       |
       |  /// Create a `StreamQueue` of the events of [source].
       |  StreamQueue(Stream<T> source)
       |      : _sourceStream =
      0|            source is ForkableStream ? source : new ForkableStream(source);
       |
       |  /// Asks if the stream has any more events.
       |  ///
       |  /// Returns a future that completes with `true` if the stream has any
       |  /// more events, whether data or error.
       |  /// If the stream closes without producing any more events, the returned
       |  /// future completes with `false`.
       |  ///
       |  /// Can be used before using [next] to avoid getting an error in the
       |  /// future returned by `next` in the case where there are no more events.
       |  Future<bool> get hasNext {
      0|    if (!_isClosed) {
      0|      var hasNextRequest = new _HasNextRequest();
      0|      _addRequest(hasNextRequest);
      0|      return hasNextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests the next (yet unrequested) event from the stream.
       |  ///
       |  /// When the requested event arrives, the returned future is completed with
       |  /// the event.
       |  /// If the event is a data event, the returned future completes
       |  /// with its value.
       |  /// If the event is an error event, the returned future completes with
       |  /// its error and stack trace.
       |  /// If the stream closes before an event arrives, the returned future
       |  /// completes with a [StateError].
       |  ///
       |  /// It's possible to have several pending [next] calls (or other requests),
       |  /// and they will be completed in the order they were requested, by the
       |  /// first events that were not consumed by previous requeusts.
       |  Future<T> get next {
      0|    if (!_isClosed) {
      0|      var nextRequest = new _NextRequest<T>();
      0|      _addRequest(nextRequest);
      0|      return nextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Returns a stream of all the remaning events of the source stream.
       |  ///
       |  /// All requested [next], [skip] or [take] operations are completed
       |  /// first, and then any remaining events are provided as events of
       |  /// the returned stream.
       |  ///
       |  /// Using `rest` closes this stream queue. After getting the
       |  /// `rest` the caller may no longer request other events, like
       |  /// after calling [cancel].
       |  Stream<T> get rest {
      0|    if (_isClosed) {
      0|      throw _failClosed();
       |    }
      0|    var request = new _RestRequest<T>(this);
      0|    _isClosed = true;
      0|    _addRequest(request);
      0|    return request.stream;
       |  }
       |
       |  /// Skips the next [count] *data* events.
       |  ///
       |  /// The [count] must be non-negative.
       |  ///
       |  /// When successful, this is equivalent to using [take]
       |  /// and ignoring the result.
       |  ///
       |  /// If an error occurs before `count` data events have been skipped,
       |  /// the returned future completes with that error instead.
       |  ///
       |  /// If the stream closes before `count` data events,
       |  /// the remaining unskipped event count is returned.
       |  /// If the returned future completes with the integer `0`,
       |  /// then all events were succssfully skipped. If the value
       |  /// is greater than zero then the stream ended early.
       |  Future<int> skip(int count) {
      0|    if (count < 0) throw new RangeError.range(count, 0, null, "count");
      0|    if (!_isClosed) {
      0|      var request = new _SkipRequest(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests the next [count] data events as a list.
       |  ///
       |  /// The [count] must be non-negative.
       |  ///
       |  /// Equivalent to calling [next] `count` times and
       |  /// storing the data values in a list.
       |  ///
       |  /// If an error occurs before `count` data events has
       |  /// been collected, the returned future completes with
       |  /// that error instead.
       |  ///
       |  /// If the stream closes before `count` data events,
       |  /// the returned future completes with the list
       |  /// of data collected so far. That is, the returned
       |  /// list may have fewer than [count] elements.
       |  Future<List<T>> take(int count) {
      0|    if (count < 0) throw new RangeError.range(count, 0, null, "count");
      0|    if (!_isClosed) {
      0|      var request = new _TakeRequest<T>(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Creates a new stream queue in the same position as this one.
       |  ///
       |  /// The fork is subscribed to the same underlying stream as this queue, but
       |  /// it's otherwise wholly independent. If requests are made on one, they don't
       |  /// move the other forward; if one is closed, the other is still open.
       |  ///
       |  /// The underlying stream will only be paused when all forks have no
       |  /// outstanding requests, and only canceled when all forks are canceled.
       |  StreamQueue<T> fork() {
      0|    if (_isClosed) throw _failClosed();
       |
      0|    var request = new _ForkRequest<T>(this);
      0|    _addRequest(request);
      0|    return request.queue;
       |  }
       |
       |  /// Cancels the underlying stream subscription.
       |  ///
       |  /// If [immediate] is `false` (the default), the cancel operation waits until
       |  /// all previously requested events have been processed, then it cancels the
       |  /// subscription providing the events.
       |  ///
       |  /// If [immediate] is `true`, the subscription is instead canceled
       |  /// immediately. Any pending events complete with a 'closed'-event, as though
       |  /// the stream had closed by itself.
       |  ///
       |  /// The returned future completes with the result of calling
       |  /// `cancel`.
       |  ///
       |  /// After calling `cancel`, no further events can be requested.
       |  /// None of [next], [rest], [skip], [take] or [cancel] may be
       |  /// called again.
       |  Future cancel({bool immediate: false}) {
      0|    if (_isClosed) throw _failClosed();
      0|    _isClosed = true;
       |
      0|    if (_isDone) return new Future.value();
      0|    if (_subscription == null) _subscription = _sourceStream.listen(null);
       |
       |    if (!immediate) {
      0|      var request = new _CancelRequest(this);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
       |
      0|    var future = _subscription.cancel();
      0|    _onDone();
       |    return future;
       |  }
       |
       |  /// Returns an error for when a request is made after cancel.
       |  ///
       |  /// Returns a [StateError] with a message saying that either
       |  /// [cancel] or [rest] have already been called.
       |  Error _failClosed() {
      0|    return new StateError("Already cancelled");
       |  }
       |
       |  // Callbacks receiving the events of the source stream.
       |
       |  void _onData(T data) {
      0|    _eventQueue.add(new Result.value(data));
      0|    _checkQueues();
       |  }
       |
       |  void _onError(error, StackTrace stack) {
      0|    _eventQueue.add(new Result.error(error, stack));
      0|    _checkQueues();
       |  }
       |
       |  void _onDone() {
      0|    _subscription = null;
      0|    _isDone = true;
      0|    _closeAllRequests();
       |  }
       |
       |  // Request queue management.
       |
       |  /// Adds a new request to the queue.
       |  void _addRequest(_EventRequest request) {
      0|    if (_isDone) {
       |      assert(_requestQueue.isEmpty);
      0|      if (!request.addEvents(_eventQueue)) {
      0|        request.close(_eventQueue);
       |      }
       |      return;
       |    }
      0|    if (_requestQueue.isEmpty) {
      0|      if (request.addEvents(_eventQueue)) return;
      0|      _ensureListening();
       |    }
      0|    _requestQueue.add(request);
       |  }
       |
       |  /// Ensures that we are listening on events from [_sourceStream].
       |  ///
       |  /// Resumes subscription on [_sourceStream], or creates it if necessary.
       |  void _ensureListening() {
       |    assert(!_isDone);
      0|    if (_subscription == null) {
      0|      _subscription =
      0|          _sourceStream.listen(_onData, onError: _onError, onDone: _onDone);
       |    } else {
      0|      _subscription.resume();
       |    }
       |  }
       |
       |  /// Removes all requests and closes them.
       |  ///
       |  /// Used when the source stream is done.
       |  /// After this, no further requests will be added to the queue,
       |  /// requests are immediately served entirely by events already in the event
       |  /// queue, if any.
       |  void _closeAllRequests() {
       |    assert(_isDone);
      0|    while (_requestQueue.isNotEmpty) {
      0|      var request = _requestQueue.removeFirst();
      0|      if (!request.addEvents(_eventQueue)) {
      0|        request.close(_eventQueue);
       |      }
       |    }
       |  }
       |
       |  /// Matches events with requests.
       |  ///
       |  /// Called after receiving an event.
       |  void _checkQueues() {
      0|    while (_requestQueue.isNotEmpty) {
      0|      if (_requestQueue.first.addEvents(_eventQueue)) {
      0|        _requestQueue.removeFirst();
       |      } else {
       |        return;
       |      }
       |    }
       |
      0|    if (!_isDone) {
      0|      _subscription.pause();
       |    }
       |  }
       |
       |  /// Extracts the subscription and makes this stream queue unusable.
       |  ///
       |  /// Can only be used by the very last request.
       |  StreamSubscription<T> _dispose() {
       |    assert(_isClosed);
      0|    var subscription = _subscription;
      0|    _subscription = null;
      0|    _isDone = true;
       |    return subscription;
       |  }
       |}
       |
       |/// Request object that receives events when they arrive, until fulfilled.
       |///
       |/// Each request that cannot be fulfilled immediately is represented by
       |/// an `_EventRequest` object in the request queue.
       |///
       |/// Events from the source stream are sent to the first request in the
       |/// queue until it reports itself as [isComplete].
       |///
       |/// When the first request in the queue `isComplete`, either when becoming
       |/// the first request or after receiving an event, its [close] methods is
       |/// called.
       |///
       |/// The [close] method is also called immediately when the source stream
       |/// is done.
       |abstract class _EventRequest {
       |  /// Handle available events.
       |  ///
       |  /// The available events are provided as a queue. The `addEvents` function
       |  /// should only remove events from the front of the event queue, e.g.,
       |  /// using [removeFirst].
       |  ///
       |  /// Returns `true` if the request is completed, or `false` if it needs
       |  /// more events.
       |  /// The call may keep events in the queue until the requeust is complete,
       |  /// or it may remove them immediately.
       |  ///
       |  /// If the method returns true, the request is considered fulfilled, and
       |  /// will never be called again.
       |  ///
       |  /// This method is called when a request reaches the front of the request
       |  /// queue, and if it returns `false`, it's called again every time a new event
       |  /// becomes available, or when the stream closes.
       |  bool addEvents(Queue<Result> events);
       |
       |  /// Complete the request.
       |  ///
       |  /// This is called when the source stream is done before the request
       |  /// had a chance to receive all its events. That is, after a call
       |  /// to [addEvents] has returned `false`.
       |  /// If there are any unused events available, they are in the [events] queue.
       |  /// No further events will become available.
       |  ///
       |  /// The queue should only remove events from the front of the event queue,
       |  /// e.g., using [removeFirst].
       |  ///
       |  /// If the request kept events in the queue after an [addEvents] call,
       |  /// this is the last chance to use them.
       |  void close(Queue<Result> events);
       |}
       |
       |/// Request for a [StreamQueue.next] call.
       |///
       |/// Completes the returned future when receiving the first event,
       |/// and is then complete.
       |class _NextRequest<T> implements _EventRequest {
       |  /// Completer for the future returned by [StreamQueue.next].
       |  final _completer = new Completer<T>();
       |
      0|  _NextRequest();
       |
      0|  Future<T> get future => _completer.future;
       |
       |  bool addEvents(Queue<Result> events) {
      0|    if (events.isEmpty) return false;
      0|    events.removeFirst().complete(_completer);
       |    return true;
       |  }
       |
       |  void close(Queue<Result> events) {
       |    var errorFuture =
      0|        new Future<T>.sync(() => throw new StateError("No elements"));
      0|    _completer.complete(errorFuture);
       |  }
       |}
       |
       |/// Request for a [StreamQueue.skip] call.
       |class _SkipRequest implements _EventRequest {
       |  /// Completer for the future returned by the skip call.
       |  final _completer = new Completer<int>();
       |
       |  /// Number of remaining events to skip.
       |  ///
       |  /// The request [isComplete] when the values reaches zero.
       |  ///
       |  /// Decremented when an event is seen.
       |  /// Set to zero when an error is seen since errors abort the skip request.
       |  int _eventsToSkip;
       |
      0|  _SkipRequest(this._eventsToSkip);
       |
       |  /// The future completed when the correct number of events have been skipped.
      0|  Future<int> get future => _completer.future;
       |
       |  bool addEvents(Queue<Result> events) {
      0|    while (_eventsToSkip > 0) {
      0|      if (events.isEmpty) return false;
      0|      _eventsToSkip--;
      0|      var event = events.removeFirst();
      0|      if (event.isError) {
      0|        event.complete(_completer);
       |        return true;
       |      }
       |    }
      0|    _completer.complete(0);
       |    return true;
       |  }
       |
       |  void close(Queue<Result> events) {
      0|    _completer.complete(_eventsToSkip);
       |  }
       |}
       |
       |/// Request for a [StreamQueue.take] call.
       |class _TakeRequest<T> implements _EventRequest {
       |  /// Completer for the future returned by the take call.
       |  final _completer = new Completer<List<T>>();
       |
       |  /// List collecting events until enough have been seen.
       |  final _list = <T>[];
       |
       |  /// Number of events to capture.
       |  ///
       |  /// The request [isComplete] when the length of [_list] reaches
       |  /// this value.
       |  final int _eventsToTake;
       |
      0|  _TakeRequest(this._eventsToTake);
       |
       |  /// The future completed when the correct number of events have been captured.
      0|  Future<List<T>> get future => _completer.future;
       |
       |  bool addEvents(Queue<Result> events) {
      0|    while (_list.length < _eventsToTake) {
      0|      if (events.isEmpty) return false;
      0|      var result = events.removeFirst();
      0|      if (result.isError) {
      0|        result.complete(_completer);
       |        return true;
       |      }
      0|      _list.add(result.asValue.value);
       |    }
      0|    _completer.complete(_list);
       |    return true;
       |  }
       |
       |  void close(Queue<Result> events) {
      0|    _completer.complete(_list);
       |  }
       |}
       |
       |/// Request for a [StreamQueue.cancel] call.
       |///
       |/// The request needs no events, it just waits in the request queue
       |/// until all previous events are fulfilled, then it cancels the stream queue
       |/// source subscription.
       |class _CancelRequest implements _EventRequest {
       |  /// Completer for the future returned by the `cancel` call.
       |  final Completer _completer = new Completer();
       |
       |  /// The [StreamQueue] object that has this request queued.
       |  ///
       |  /// When the event is completed, it needs to cancel the active subscription
       |  /// of the `StreamQueue` object, if any.
       |  final StreamQueue _streamQueue;
       |
      0|  _CancelRequest(this._streamQueue);
       |
       |  /// The future completed when the cancel request is completed.
      0|  Future get future => _completer.future;
       |
       |  bool addEvents(Queue<Result> events) {
      0|    _shutdown();
       |    return true;
       |  }
       |
       |  void close(_) {
      0|    _shutdown();
       |  }
       |
       |  void _shutdown() {
      0|    if (_streamQueue._isDone) {
      0|      _completer.complete();
       |    } else {
      0|      _streamQueue._ensureListening();
      0|      _completer.complete(_streamQueue._dispose().cancel());
       |    }
       |  }
       |}
       |
       |/// Request for a [StreamQueue.rest] call.
       |///
       |/// The request is always complete, it just waits in the request queue
       |/// until all previous events are fulfilled, then it takes over the
       |/// stream events subscription and creates a stream from it.
       |class _RestRequest<T> implements _EventRequest {
       |  /// Completer for the stream returned by the `rest` call.
       |  final _completer = new StreamCompleter<T>();
       |
       |  /// The [StreamQueue] object that has this request queued.
       |  ///
       |  /// When the event is completed, it needs to cancel the active subscription
       |  /// of the `StreamQueue` object, if any.
       |  final StreamQueue<T> _streamQueue;
       |
      0|  _RestRequest(this._streamQueue);
       |
       |  /// The stream which will contain the remaining events of [_streamQueue].
      0|  Stream<T> get stream => _completer.stream;
       |
       |  bool addEvents(Queue<Result> events) {
      0|    _completeStream(events);
       |    return true;
       |  }
       |
       |  void close(Queue<Result> events) {
      0|    _completeStream(events);
       |  }
       |
       |  void _completeStream(Queue<Result> events) {
      0|    if (events.isEmpty) {
      0|      if (_streamQueue._isDone) {
      0|        _completer.setEmpty();
       |      } else {
      0|        _completer.setSourceStream(_getRestStream());
       |      }
       |    } else {
       |      // There are prefetched events which needs to be added before the
       |      // remaining stream.
      0|      var controller = new StreamController<T>();
      0|      for (var event in events) {
      0|        event.addTo(controller);
       |      }
       |      controller
      0|          .addStream(_getRestStream(), cancelOnError: false)
      0|          .whenComplete(controller.close);
      0|      _completer.setSourceStream(controller.stream);
       |    }
       |  }
       |
       |  /// Create a stream from the rest of [_streamQueue]'s subscription.
       |  Stream<T> _getRestStream() {
      0|    if (_streamQueue._isDone) {
      0|      var controller = new StreamController<T>()..close();
      0|      return controller.stream;
       |      // TODO(lrn). Use the following when 1.11 is released.
       |      // return new Stream<T>.empty();
       |    }
      0|    if (_streamQueue._subscription == null) {
      0|      return _streamQueue._sourceStream;
       |    }
      0|    var subscription = _streamQueue._dispose();
      0|    subscription.resume();
      0|    return new SubscriptionStream<T>(subscription);
       |  }
       |}
       |
       |/// Request for a [StreamQueue.hasNext] call.
       |///
       |/// Completes the [future] with `true` if it sees any event,
       |/// but doesn't consume the event.
       |/// If the request is closed without seeing an event, then
       |/// the [future] is completed with `false`.
       |class _HasNextRequest<T> implements _EventRequest {
       |  final _completer = new Completer<bool>();
       |
      0|  Future<bool> get future => _completer.future;
       |
       |  bool addEvents(Queue<Result> events) {
      0|    if (events.isNotEmpty) {
      0|      _completer.complete(true);
       |      return true;
       |    }
       |    return false;
       |  }
       |
       |  void close(_) {
      0|    _completer.complete(false);
       |  }
       |}
       |
       |/// Request for a [StreamQueue.fork] call.
       |class _ForkRequest<T> implements _EventRequest {
       |  /// Completer for the stream used by the queue by the `fork` call.
       |  StreamCompleter<T> _completer;
       |
       |  StreamQueue<T> queue;
       |
       |  /// The [StreamQueue] object that has this request queued.
       |  final StreamQueue<T> _streamQueue;
       |
      0|  _ForkRequest(this._streamQueue) {
      0|    _completer = new StreamCompleter();
      0|    queue = new StreamQueue(_completer.stream);
       |  }
       |
       |  bool addEvents(Queue<Result> events) {
      0|    _completeStream(events);
       |    return true;
       |  }
       |
       |  void close(Queue<Result> events) {
      0|    _completeStream(events);
       |  }
       |
       |  void _completeStream(Queue<Result> events) {
      0|    if (events.isEmpty) {
      0|      if (_streamQueue._isDone) {
      0|        _completer.setEmpty();
       |      } else {
      0|        _completer.setSourceStream(_streamQueue._sourceStream.fork());
       |      }
       |    } else {
       |      // There are prefetched events which need to be added before the
       |      // remaining stream.
      0|      var controller = new StreamController<T>();
      0|      for (var event in events) {
      0|        event.addTo(controller);
       |      }
       |
      0|      var fork = _streamQueue._sourceStream.fork();
       |      controller
      0|          .addStream(fork, cancelOnError: false)
      0|          .whenComplete(controller.close);
      0|      _completer.setSourceStream(controller.stream);
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/backend/platform_selector.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:boolean_selector/boolean_selector.dart';
       |import 'package:source_span/source_span.dart';
       |
       |import 'operating_system.dart';
       |import 'test_platform.dart';
       |
       |/// The set of all valid variable names.
       |final _validVariables =
       |    new Set<String>.from(["posix", "dart-vm", "browser", "js", "blink"])
       |      ..addAll(TestPlatform.all.map((platform) => platform.identifier))
       |      ..addAll(OperatingSystem.all.map((os) => os.identifier));
       |
       |/// An expression for selecting certain platforms, including operating systems
       |/// and browsers.
       |///
       |/// This uses the [boolean selector][] syntax.
       |///
       |/// [boolean selector]: https://pub.dartlang.org/packages/boolean_selector
       |class PlatformSelector {
       |  /// A selector that declares that a test can be run on all platforms.
       |  static const all = const PlatformSelector._(BooleanSelector.all);
       |
       |  /// The boolean selector used to implement this selector.
       |  final BooleanSelector _inner;
       |
       |  /// Parses [selector].
       |  ///
       |  /// This will throw a [SourceSpanFormatException] if the selector is
       |  /// malformed or if it uses an undefined variable.
       |  PlatformSelector.parse(String selector)
      0|      : _inner = new BooleanSelector.parse(selector) {
      0|    _inner.validate(_validVariables.contains);
       |  }
       |
      1|  const PlatformSelector._(this._inner);
       |
       |  /// Returns whether the selector matches the given [platform] and [os].
       |  ///
       |  /// [os] defaults to [OperatingSystem.none].
       |  bool evaluate(TestPlatform platform, {OperatingSystem os}) {
       |    os ??= OperatingSystem.none;
       |
      2|    return _inner.evaluate((variable) {
      0|      if (variable == platform.identifier) return true;
      0|      if (variable == os.identifier) return true;
       |      switch (variable) {
      0|        case "dart-vm":
      0|          return platform.isDartVM;
      0|        case "browser":
      0|          return platform.isBrowser;
      0|        case "js":
      0|          return platform.isJS;
      0|        case "blink":
      0|          return platform.isBlink;
      0|        case "posix":
      0|          return os.isPosix;
       |        default:
       |          return false;
       |      }
       |    });
       |  }
       |
       |  /// Returns a new [PlatformSelector] that matches only platforms matched by
       |  /// both [this] and [other].
       |  PlatformSelector intersection(PlatformSelector other) {
      1|    if (other == PlatformSelector.all) return this;
      0|    return new PlatformSelector._(_inner.intersection(other._inner));
       |  }
       |
      0|  String toString() => _inner.toString();
       |
       |  bool operator ==(other) =>
      4|      other is PlatformSelector && _inner == other._inner;
       |
      0|  int get hashCode => _inner.hashCode;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/pool-1.3.0/lib/pool.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import 'package:async/async.dart';
       |import 'package:stack_trace/stack_trace.dart';
       |
       |/// Manages an abstract pool of resources with a limit on how many may be in use
       |/// at once.
       |///
       |/// When a resource is needed, the user should call [request]. When the returned
       |/// future completes with a [PoolResource], the resource may be allocated. Once
       |/// the resource has been released, the user should call [PoolResource.release].
       |/// The pool will ensure that only a certain number of [PoolResource]s may be
       |/// allocated at once.
       |class Pool {
       |  /// Completers for requests beyond the first [_maxAllocatedResources].
       |  ///
       |  /// When an item is released, the next element of [_requestedResources] will
       |  /// be completed.
       |  final _requestedResources = new Queue<Completer<PoolResource>>();
       |
       |  /// Callbacks that must be called before additional resources can be
       |  /// allocated.
       |  ///
       |  /// See [PoolResource.allowRelease].
       |  final _onReleaseCallbacks = new Queue<Function>();
       |
       |  /// Completers that will be completed once `onRelease` callbacks are done
       |  /// running.
       |  ///
       |  /// These are kept in a queue to ensure that the earliest request completes
       |  /// first regardless of what order the `onRelease` callbacks complete in.
       |  final _onReleaseCompleters = new Queue<Completer<PoolResource>>();
       |
       |  /// The maximum number of resources that may be allocated at once.
       |  final int _maxAllocatedResources;
       |
       |  /// The number of resources that are currently allocated.
       |  int _allocatedResources = 0;
       |
       |  /// The timeout timer.
       |  ///
       |  /// This timer is canceled as long as the pool is below the resource limit.
       |  /// It's reset once the resource limit is reached and again every time an
       |  /// resource is released or a new resource is requested. If it fires, that
       |  /// indicates that the caller became deadlocked, likely due to files waiting
       |  /// for additional files to be read before they could be closed.
       |  ///
       |  /// This is `null` if this pool shouldn't time out.
       |  RestartableTimer _timer;
       |
       |  /// The amount of time to wait before timing out the pending resources.
       |  final Duration _timeout;
       |
       |  /// A [FutureGroup] that tracks all the `onRelease` callbacks for resources
       |  /// that have been marked releasable.
       |  ///
       |  /// This is `null` until [close] is called.
       |  FutureGroup _closeGroup;
       |
       |  /// Whether [close] has been called.
      2|  bool get isClosed => _closeMemo.hasRun;
       |
       |  /// A future that completes once the pool is closed and all its outstanding
       |  /// resources have been released.
       |  ///
       |  /// If any [PoolResource.allowRelease] callback throws an exception after the
       |  /// pool is closed, this completes with that exception.
      2|  Future get done => _closeMemo.future;
       |
       |  /// Creates a new pool with the given limit on how many resources may be
       |  /// allocated at once.
       |  ///
       |  /// If [timeout] is passed, then if that much time passes without any activity
       |  /// all pending [request] futures will throw a [TimeoutException]. This is
       |  /// intended to avoid deadlocks.
       |  Pool(this._maxAllocatedResources, {Duration timeout})
      1|      : _timeout = timeout {
       |    if (timeout != null) {
       |      // Start the timer canceled since we only want to start counting down once
       |      // we've run out of available resources.
      0|      _timer = new RestartableTimer(timeout, _onTimeout)..cancel();
       |    }
       |  }
       |
       |  /// Request a [PoolResource].
       |  ///
       |  /// If the maximum number of resources is already allocated, this will delay
       |  /// until one of them is released.
       |  Future<PoolResource> request() {
      1|    if (isClosed) {
      0|      throw new StateError("request() may not be called on a closed Pool.");
       |    }
       |
      3|    if (_allocatedResources < _maxAllocatedResources) {
      2|      _allocatedResources++;
      2|      return new Future.value(new PoolResource._(this));
      0|    } else if (_onReleaseCallbacks.isNotEmpty) {
      0|      return _runOnRelease(_onReleaseCallbacks.removeFirst());
       |    } else {
      0|      var completer = new Completer<PoolResource>();
      0|      _requestedResources.add(completer);
      0|      _resetTimer();
      0|      return completer.future;
       |    }
       |  }
       |
       |  /// Requests a resource for the duration of [callback], which may return a
       |  /// Future.
       |  ///
       |  /// The return value of [callback] is piped to the returned Future.
       |  Future/*<T>*/ withResource/*<T>*/(/*=T*/ callback()) {
      1|    if (isClosed) {
      0|      throw new StateError(
       |          "withResource() may not be called on a closed Pool.");
       |    }
       |
       |    // We can't use async/await here because we need to start the request
       |    // synchronously in case the pool is closed immediately afterwards. Async
       |    // functions have an asynchronous gap between calling and running the body,
       |    // and [close] could be called during that gap. See #3.
      2|    return request().then/*<Future<T>>*/((resource) {
      3|      return new Future/*<T>*/.sync(callback).whenComplete(resource.release);
       |    });
       |  }
       |
       |  /// Closes the pool so that no more resources are requested.
       |  ///
       |  /// Existing resource requests remain unchanged.
       |  ///
       |  /// Any resources that are marked as releasable using
       |  /// [PoolResource.allowRelease] are released immediately. Once all resources
       |  /// have been released and any `onRelease` callbacks have completed, the
       |  /// returned future completes successfully. If any `onRelease` callback throws
       |  /// an error, the returned future completes with that error.
       |  ///
       |  /// This may be called more than once; it returns the same [Future] each time.
      2|  Future close() => _closeMemo.runOnce(() {
      1|    if (_closeGroup != null) return _closeGroup.future;
       |
      1|    _resetTimer();
       |
      2|    _closeGroup = new FutureGroup();
      1|    for (var callback in _onReleaseCallbacks) {
      0|      _closeGroup.add(new Future.sync(callback));
       |    }
       |
      4|    _allocatedResources -= _onReleaseCallbacks.length;
      2|    _onReleaseCallbacks.clear();
       |
      2|    if (_allocatedResources == 0) _closeGroup.close();
      2|    return _closeGroup.future;
       |  });
       |  final _closeMemo = new AsyncMemoizer();
       |
       |  /// If there are any pending requests, this will fire the oldest one.
       |  void _onResourceReleased() {
      1|    _resetTimer();
       |
      2|    if (_requestedResources.isNotEmpty) {
      0|      var pending = _requestedResources.removeFirst();
      0|      pending.complete(new PoolResource._(this));
       |    } else {
      2|      _allocatedResources--;
      1|      if (isClosed && _allocatedResources == 0) _closeGroup.close();
       |    }
       |  }
       |
       |  /// If there are any pending requests, this will fire the oldest one after
       |  /// running [onRelease].
       |  void _onResourceReleaseAllowed(onRelease()) {
      1|    _resetTimer();
       |
      2|    if (_requestedResources.isNotEmpty) {
      0|      var pending = _requestedResources.removeFirst();
      0|      pending.complete(_runOnRelease(onRelease));
      1|    } else if (isClosed) {
      3|      _closeGroup.add(new Future.sync(onRelease));
      2|      _allocatedResources--;
      4|      if (_allocatedResources == 0) _closeGroup.close();
       |    } else {
      0|      _onReleaseCallbacks.add(
      0|          Zone.current.bindCallback(onRelease, runGuarded: false));
       |    }
       |  }
       |
       |  /// Runs [onRelease] and returns a Future that completes to a resource once an
       |  /// [onRelease] callback completes.
       |  ///
       |  /// Futures returned by [_runOnRelease] always complete in the order they were
       |  /// created, even if earlier [onRelease] callbacks take longer to run.
       |  Future<PoolResource> _runOnRelease(onRelease()) {
      0|    new Future.sync(onRelease).then((value) {
      0|      _onReleaseCompleters.removeFirst().complete(new PoolResource._(this));
      0|    }).catchError((error, stackTrace) {
      0|      _onReleaseCompleters.removeFirst().completeError(error, stackTrace);
       |    });
       |
      0|    var completer = new Completer<PoolResource>.sync();
      0|    _onReleaseCompleters.add(completer);
      0|    return completer.future;
       |  }
       |
       |  /// A resource has been requested, allocated, or released.
       |  void _resetTimer() {
      1|    if (_timer == null) return;
       |
      0|    if (_requestedResources.isEmpty) {
      0|      _timer.cancel();
       |    } else {
      0|      _timer.reset();
       |    }
       |  }
       |
       |  /// Handles [_timer] timing out by causing all pending resource completers to
       |  /// emit exceptions.
       |  void _onTimeout() {
      0|    for (var completer in _requestedResources) {
      0|      completer.completeError(
      0|          new TimeoutException("Pool deadlock: all resources have been "
       |              "allocated for too long.",
      0|              _timeout),
      0|          new Chain.current());
       |    }
      0|    _requestedResources.clear();
      0|    _timer = null;
       |  }
       |}
       |
       |/// A member of a [Pool].
       |///
       |/// A [PoolResource] is a token that indicates that a resource is allocated.
       |/// When the associated resource is released, the user should call [release].
       |class PoolResource {
       |  final Pool _pool;
       |
       |  /// Whether [this] has been released yet.
       |  bool _released = false;
       |
      1|  PoolResource._(this._pool);
       |
       |  /// Tells the parent [Pool] that the resource associated with this resource is
       |  /// no longer allocated, and that a new [PoolResource] may be allocated.
       |  void release() {
      1|    if (_released) {
      0|      throw new StateError("A PoolResource may only be released once.");
       |    }
      1|    _released = true;
      2|    _pool._onResourceReleased();
       |  }
       |
       |  /// Tells the parent [Pool] that the resource associated with this resource is
       |  /// no longer necessary, but should remain allocated until more resources are
       |  /// needed.
       |  ///
       |  /// When [Pool.request] is called and there are no remaining available
       |  /// resources, the [onRelease] callback is called. It should free the
       |  /// resource, and it may return a Future or `null`. Once that completes, the
       |  /// [Pool.request] call will complete to a new [PoolResource].
       |  ///
       |  /// This is useful when a resource's main function is complete, but it may
       |  /// produce additional information later on. For example, an isolate's task
       |  /// may be complete, but it could still emit asynchronous errors.
       |  void allowRelease(onRelease()) {
      1|    if (_released) {
      0|      throw new StateError("A PoolResource may only be released once.");
       |    }
      1|    _released = true;
      2|    _pool._onResourceReleaseAllowed(onRelease);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/unmodifiable_wrappers.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |export "dart:collection" show UnmodifiableListView, UnmodifiableMapView;
       |
       |import 'wrappers.dart';
       |import 'empty_unmodifiable_set.dart';
       |
       |/// A fixed-length list.
       |///
       |/// A `NonGrowableListView` contains a [List] object and ensures that
       |/// its length does not change.
       |/// Methods that would change the length of the list,
       |/// such as [add] and [remove], throw an [UnsupportedError].
       |/// All other methods work directly on the underlying list.
       |///
       |/// This class _does_ allow changes to the contents of the wrapped list.
       |/// You can, for example, [sort] the list.
       |/// Permitted operations defer to the wrapped list.
       |class NonGrowableListView<E> extends DelegatingList<E>
       |                             with NonGrowableListMixin<E> {
      0|  NonGrowableListView(List<E> listBase) : super(listBase);
       |}
       |
       |/// Mixin class that implements a throwing version of all list operations that
       |/// change the List's length.
       |abstract class NonGrowableListMixin<E> implements List<E> {
       |  static /*=T*/ _throw/*<T>*/() {
      0|    throw new UnsupportedError(
       |        "Cannot change the length of a fixed-length list");
       |  }
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void set length(int newLength) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  bool add(E value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void addAll(Iterable<E> iterable) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void insert(int index, E element) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void insertAll(int index, Iterable<E> iterable) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  bool remove(Object value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  E removeAt(int index) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  E removeLast() => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void removeWhere(bool test(E element)) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void retainWhere(bool test(E element)) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void removeRange(int start, int end) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void replaceRange(int start, int end, Iterable<E> iterable) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  void clear() => _throw();
       |}
       |
       |/// An unmodifiable set.
       |///
       |/// An UnmodifiableSetView contains a [Set] object and ensures
       |/// that it does not change.
       |/// Methods that would change the set,
       |/// such as [add] and [remove], throw an [UnsupportedError].
       |/// Permitted operations defer to the wrapped set.
       |class UnmodifiableSetView<E> extends DelegatingSet<E>
       |    with UnmodifiableSetMixin<E> {
      1|  UnmodifiableSetView(Set<E> setBase) : super(setBase);
       |
       |  /// An unmodifiable empty set.
       |  ///
       |  /// This is the same as `new UnmodifiableSetView(new Set())`, except that it
       |  /// can be used in const contexts.
       |  const factory UnmodifiableSetView.empty() = EmptyUnmodifiableSet<E>;
       |}
       |
       |/// Mixin class that implements a throwing version of all set operations that
       |/// change the Set.
       |abstract class UnmodifiableSetMixin<E> implements Set<E> {
       |  static /*=T*/ _throw/*<T>*/() {
      0|    throw new UnsupportedError("Cannot modify an unmodifiable Set");
       |  }
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  bool add(E value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  void addAll(Iterable<E> elements) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  bool remove(Object value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  void removeAll(Iterable elements) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  void retainAll(Iterable elements) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  void removeWhere(bool test(E element)) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  void retainWhere(bool test(E element)) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  void clear() => _throw();
       |}
       |
       |/// Mixin class that implements a throwing version of all map operations that
       |/// change the Map.
       |abstract class UnmodifiableMapMixin<K, V> implements Map<K, V> {
       |  static /*=T*/ _throw/*<T>*/() {
      0|    throw new UnsupportedError("Cannot modify an unmodifiable Map");
       |  }
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  void operator []=(K key, V value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  V putIfAbsent(K key, V ifAbsent()) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  void addAll(Map<K, V> other) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  V remove(Object key) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  void clear() => _throw();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/util/iterable_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'package:collection/collection.dart';
       |
       |/// An unmodifiable [Set] view backed by an arbitrary [Iterable].
       |///
       |/// Note that contrary to most APIs that take iterables, this does not convert
       |/// its argument to another collection before use. This means that if it's
       |/// lazily-generated, that generation will happen for every operation.
       |///
       |/// Note also that set operations that are usually expected to be `O(1)` or
       |/// `O(log(n))`, such as [contains], may be `O(n)` for many underlying iterable
       |/// types. As such, this should only be used for small iterables.
       |class IterableSet<E> extends SetMixin<E> with UnmodifiableSetMixin<E> {
       |  /// The base iterable that set operations forward to.
       |  final Iterable<E> _base;
       |
      2|  int get length => _base.length;
       |
      0|  Iterator<E> get iterator => _base.iterator;
       |
       |  /// Creates a [Set] view of [base].
      1|  IterableSet(this._base);
       |
      0|  bool contains(Object element) => _base.contains(element);
       |
       |  E lookup(Object needle) =>
      0|      _base.firstWhere((element) => element == needle, orElse: () => null);
       |
      0|  Set<E> toSet() => _base.toSet();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/live_suite.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:collection/collection.dart';
       |
       |import '../backend/live_test.dart';
       |import 'runner_suite.dart';
       |
       |/// A view of the execution of a test suite.
       |///
       |/// This is distinct from [Suite] because it represents the progress of running
       |/// a suite rather than the suite's contents. It provides events and collections
       |/// that give the caller a view into the suite's current state.
       |abstract class LiveSuite {
       |  /// The suite that's being run.
       |  RunnerSuite get suite;
       |
       |  /// Whether the suite has completed.
       |  ///
       |  /// Note that even if this returns `true`, the suite may still be running code
       |  /// asynchronously. A suite is considered complete once all of its tests are
       |  /// complete, but it's possible for a test to continue running even after it's
       |  /// been marked complete—see [LiveTest.isComplete] for details.
       |  ///
       |  /// The [isClosed] getter can be used to determine whether the suite and its
       |  /// tests are guaranteed to emit no more events.
       |  bool get isComplete;
       |
       |  /// A [Future] that completes once the suite is complete.
       |  ///
       |  /// Note that even once this completes, the suite may still be running code
       |  /// asynchronously. A suite is considered complete once all of its tests are
       |  /// complete, but it's possible for a test to continue running even after it's
       |  /// been marked complete—see [LiveTest.isComplete] for details.
       |  ///
       |  /// The [onClose] future can be used to determine when the suite and its tests
       |  /// are guaranteed to emit no more events.
       |  Future get onComplete;
       |
       |  /// Whether the suite has been closed.
       |  ///
       |  /// If this is `true`, no code is running for the suite or any of its tests.
       |  /// At this point, the caller can be sure that the suites' tests are all in
       |  /// fixed states that will not change in the future.
       |  bool get isClosed;
       |
       |  /// A [Future] that completes when the suite has been closed.
       |  ///
       |  /// Once this completes, no code is running for the suite or any of its tests.
       |  /// At this point, the caller can be sure that the suites' tests are all in
       |  /// fixed states that will not change in the future.
       |  Future get onClose;
       |
       |  /// All the currently-known tests in this suite that have run or are running.
       |  ///
       |  /// This is guaranteed to contain the same tests as the union of [passed],
       |  /// [skipped], [failed], and [active].
       |  Set<LiveTest> get liveTests {
      0|    var sets = [passed, skipped, failed];
      0|    if (active != null) sets.add(new Set.from([active]));
      0|    return new UnionSet.from(sets);
       |  }
       |
       |  /// A stream that emits each [LiveTest] in this suite as it's about to start
       |  /// running.
       |  ///
       |  /// This is guaranteed to fire before [LiveTest.onStateChange] first fires. It
       |  /// will close once all tests the user has selected are run.
       |  Stream<LiveTest> get onTestStarted;
       |
       |  /// The set of tests in this suite that have completed and been marked as
       |  /// passing.
       |  Set<LiveTest> get passed;
       |
       |  /// The set of tests in this suite that have completed and been marked as
       |  /// skipped.
       |  Set<LiveTest> get skipped;
       |
       |  /// The set of tests in this suite that have completed and been marked as
       |  /// failing or error.
       |  Set<LiveTest> get failed;
       |
       |  /// The currently running test in this suite, or `null` if no test is running.
       |  LiveTest get active;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/live_suite_controller.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart' hide Result;
       |import 'package:collection/collection.dart';
       |
       |import '../backend/state.dart';
       |import '../backend/live_test.dart';
       |import 'live_suite.dart';
       |import 'runner_suite.dart';
       |
       |/// An implementation of [LiveSuite] that's controlled by a
       |/// [LiveSuiteController].
       |class _LiveSuite extends LiveSuite {
       |  final LiveSuiteController _controller;
       |
      2|  RunnerSuite get suite => _controller._suite;
       |
      0|  bool get isComplete => _controller._isComplete;
       |
      0|  Future get onComplete => _controller._onCompleteGroup.future;
       |
      0|  bool get isClosed => _controller._onCloseCompleter.isCompleted;
       |
      0|  Future get onClose => _controller._onCloseCompleter.future;
       |
       |  Stream<LiveTest> get onTestStarted =>
      3|      _controller._onTestStartedController.stream;
       |
      3|  Set<LiveTest> get passed => new UnmodifiableSetView(_controller._passed);
       |
      3|  Set<LiveTest> get skipped => new UnmodifiableSetView(_controller._skipped);
       |
      3|  Set<LiveTest> get failed => new UnmodifiableSetView(_controller._failed);
       |
      0|  LiveTest get active => _controller._active;
       |
      1|  _LiveSuite(this._controller);
       |}
       |
       |/// A controller that drives a [LiveSuite].
       |///
       |/// This is a utility class to make it easier for [Engine] to create the
       |/// [LiveSuite]s exposed by various APIs. The [LiveSuite] is accessible through
       |/// [LiveSuiteController.liveSuite]. When a live test is run, it should be
       |/// passed to [reportLiveTest], and once tests are finished being run for this
       |/// suite, [noMoreLiveTests] should be called. Once the suite should be torn
       |/// down, [close] should be called.
       |class LiveSuiteController {
       |  /// The [LiveSuite] controlled by [this].
      1|  LiveSuite get liveSuite => _liveSuite;
       |  LiveSuite _liveSuite;
       |
       |  /// The suite that's being run.
       |  final RunnerSuite _suite;
       |
       |  /// The future group that backs [LiveSuite.onComplete].
       |  ///
       |  /// This contains all the futures from tests that are run in this suite.
       |  final _onCompleteGroup = new FutureGroup();
       |
       |  /// Whether [_onCompleteGroup]'s future has fired.
       |  var _isComplete = false;
       |
       |  /// The completer that backs [LiveSuite.onClose].
       |  ///
       |  /// This is completed when the live suite is closed.
       |  final _onCloseCompleter = new Completer();
       |
       |  /// The controller for [LiveSuite.onTestStarted].
       |  final _onTestStartedController =
       |      new StreamController<LiveTest>.broadcast(sync: true);
       |
       |  /// The set that backs [LiveTest.passed].
       |  final _passed = new Set<LiveTest>();
       |
       |  /// The set that backs [LiveTest.skipped].
       |  final _skipped = new Set<LiveTest>();
       |
       |  /// The set that backs [LiveTest.failed].
       |  final _failed = new Set<LiveTest>();
       |
       |  /// The test exposed through [LiveTest.active].
       |  LiveTest _active;
       |
       |  /// Creates a controller for a live suite representing running the tests in
       |  /// [suite].
       |  ///
       |  /// Once this is called, the controller assumes responsibility for closing the
       |  /// suite. The caller should call [LiveSuiteController.close] rather than
       |  /// calling [RunnerSuite.close] directly.
      1|  LiveSuiteController(this._suite) {
      2|    _liveSuite = new _LiveSuite(this);
       |
      3|    _onCompleteGroup.future.then((_) {
      1|      _isComplete = true;
       |    }, onError: (_) {});
       |  }
       |
       |  /// Reports the status of [liveTest] through [liveSuite].
       |  ///
       |  /// The live test is assumed to be a member of this suite. If [countSuccess]
       |  /// is `true` (the default), the test is put into [passed] if it succeeds.
       |  /// Otherwise, it's removed from [liveTests] entirely.
       |  ///
       |  /// Throws a [StateError] if called after [noMoreLiveTests].
       |  void reportLiveTest(LiveTest liveTest, {bool countSuccess: true}) {
      2|    if (_onTestStartedController.isClosed) {
      0|      throw new StateError("Can't call reportLiveTest() after noMoreTests().");
       |    }
       |
       |    assert(liveTest.suite == _suite);
       |    assert(_active == null);
       |
      1|    _active = liveTest;
       |
      2|    liveTest.onStateChange.listen((state) {
      2|      if (state.status != Status.complete) return;
      1|      _active = null;
       |
      2|      if (state.result == Result.skipped) {
      0|        _skipped.add(liveTest);
      2|      } else if (state.result != Result.success) {
      2|        _passed.remove(liveTest);
      2|        _failed.add(liveTest);
       |      } else if (countSuccess) {
      2|        _passed.add(liveTest);
       |      }
       |    });
       |
      2|    _onTestStartedController.add(liveTest);
       |
      3|    _onCompleteGroup.add(liveTest.onComplete);
       |  }
       |
       |  /// Indicates that all the live tests that are going to be provided for this
       |  /// suite have already been provided.
       |  void noMoreLiveTests() {
      2|    _onTestStartedController.close();
      2|    _onCompleteGroup.close();
       |  }
       |
       |  /// Closes the underlying suite.
      2|  Future close() => _closeMemo.runOnce(() async {
       |        try {
      3|          await _suite.close();
       |        } finally {
      2|          _onCloseCompleter.complete();
       |        }
      1|      });
       |  final _closeMemo = new AsyncMemoizer();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/runner/load_exception.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:isolate';
       |
       |import 'package:path/path.dart' as p;
       |import 'package:source_span/source_span.dart';
       |
       |import '../utils.dart';
       |
       |/// A regular expression for matching filename annotations in
       |/// [IsolateSpawnException] messages.
       |final _isolateFileRegExp =
       |    new RegExp(r"^'(file:/[^']+)': (error|warning): ", multiLine: true);
       |
       |class LoadException implements Exception {
       |  final String path;
       |
       |  final innerError;
       |
      0|  LoadException(this.path, this.innerError);
       |
       |  String toString({bool color: false}) {
      0|    var buffer = new StringBuffer();
      0|    if (color) buffer.write('\u001b[31m'); // red
      0|    buffer.write('Failed to load "$path":');
      0|    if (color) buffer.write('\u001b[0m'); // no color
       |
      0|    var innerString = getErrorMessage(innerError);
      0|    if (innerError is IsolateSpawnException) {
       |      // If this is a parse error, clean up the noisy filename annotations.
      0|      innerString = innerString.replaceAllMapped(_isolateFileRegExp, (match) {
      0|        if (p.fromUri(match[1]) == p.absolute(path)) return "";
      0|        return "${p.prettyUri(match[1])}: ";
       |      });
       |
       |      // If this is a file system error, get rid of both the preamble and the
       |      // useless stack trace.
       |
       |      // This message was used prior to 1.11.0-dev.3.0.
      0|      innerString = innerString.replaceFirst(
       |          "Unhandled exception:\n"
       |          "Uncaught Error: Load Error: ",
       |          "");
       |
       |      // This message was used after 1.11.0-dev.3.0.
      0|      innerString = innerString.replaceFirst(
       |          "Unhandled exception:\n"
       |          "Load Error for ",
       |          "");
       |
      0|      innerString = innerString.replaceFirst("FileSystemException: ", "");
      0|      innerString = innerString.split("Stack Trace:\n").first.trim();
       |    }
      0|    if (innerError is SourceSpanException) {
       |      innerString =
      0|          innerError.toString(color: color).replaceFirst(" of $path", "");
       |    }
       |
      0|    buffer.write(innerString.contains("\n") ? "\n" : " ");
      0|    buffer.write(innerString);
      0|    return buffer.toString();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/frontend/async_matcher.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../backend/invoker.dart';
       |import 'expect.dart';
       |
       |/// A matcher that does asynchronous computation.
       |///
       |/// Rather than implementing [matches], subclasses implement [matchAsync].
       |/// [AsyncMatcher.matches] ensures that the test doesn't complete until the
       |/// returned future completes, and [expect] returns a future that completes when
       |/// the returned future completes so that tests can wait for it.
       |abstract class AsyncMatcher extends Matcher {
      0|  const AsyncMatcher();
       |
       |  /// Returns `null` if this matches [item], or a [String] description of the
       |  /// failure if it doesn't match.
       |  ///
       |  /// This can return a [Future] or a synchronous value. If it returns a
       |  /// [Future], neither [expect] nor the test will complete until that [Future]
       |  /// completes.
       |  ///
       |  /// If this returns a [String] synchronously, [expect] will synchronously
       |  /// throw a [TestFailure] and [matches] will synchronusly return `false`.
       |  /*FutureOr<String>*/ matchAsync(item);
       |
       |  bool matches(item, Map matchState) {
      0|    var result = matchAsync(item);
      0|    expect(
       |        result,
      0|        anyOf([
      0|          equals(null),
      0|          new isInstanceOf<Future>(),
      0|          new isInstanceOf<String>()
       |        ]),
       |        reason: "matchAsync() may only return a String, a Future, or null.");
       |
      0|    if (result is Future) {
      0|      Invoker.current.addOutstandingCallback();
      0|      result.then((realResult) {
      0|        if (realResult != null) fail(formatFailure(this, item, realResult));
      0|        Invoker.current.removeOutstandingCallback();
       |      });
      0|    } else if (result is String) {
      0|      matchState[this] = result;
       |      return false;
       |    }
       |
       |    return true;
       |  }
       |
       |  Description describeMismatch(
       |          item, Description description, Map matchState, bool verbose) =>
      0|      new StringDescription(matchState[this]);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/stream_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import 'src/guarantee_channel.dart';
       |import 'src/close_guarantee_channel.dart';
       |import 'src/stream_channel_transformer.dart';
       |
       |export 'src/delegating_stream_channel.dart';
       |export 'src/disconnector.dart';
       |export 'src/isolate_channel.dart';
       |export 'src/json_document_transformer.dart';
       |export 'src/multi_channel.dart';
       |export 'src/stream_channel_completer.dart';
       |export 'src/stream_channel_controller.dart';
       |export 'src/stream_channel_transformer.dart';
       |
       |/// An abstract class representing a two-way communication channel.
       |///
       |/// Users should consider the [stream] emitting a "done" event to be the
       |/// canonical indicator that the channel has closed. If they wish to close the
       |/// channel, they should close the [sink]—canceling the stream subscription is
       |/// not sufficient. Protocol errors may be emitted through the stream or through
       |/// [Sink.done], depending on their underlying cause. Note that the sink may
       |/// silently drop events if the channel closes before [Sink.close] is called.
       |///
       |/// Implementations are strongly encouraged to mix in or extend
       |/// [StreamChannelMixin] to get default implementations of the various instance
       |/// methods. Adding new methods to this interface will not be considered a
       |/// breaking change if implementations are also added to [StreamChannelMixin].
       |///
       |/// Implementations must provide the following guarantees:
       |///
       |/// * The stream is single-subscription, and must follow all the guarantees of
       |///   single-subscription streams.
       |///
       |/// * Closing the sink causes the stream to close before it emits any more
       |///   events.
       |///
       |/// * After the stream closes, the sink is automatically closed. If this
       |///   happens, sink methods should silently drop their arguments until
       |///   [Sink.close] is called.
       |///
       |/// * If the stream closes before it has a listener, the sink should silently
       |///   drop events if possible.
       |///
       |/// * Canceling the stream's subscription has no effect on the sink. The channel
       |///   must still be able to respond to the other endpoint closing the channel
       |///   even after the subscription has been canceled.
       |///
       |/// * The sink *either* forwards errors to the other endpoint *or* closes as
       |///   soon as an error is added and forwards that error to the [Sink.done]
       |///   future.
       |///
       |/// These guarantees allow users to interact uniformly with all implementations,
       |/// and ensure that either endpoint closing the stream produces consistent
       |/// behavior.
       |abstract class StreamChannel<T> {
       |  /// The single-subscription stream that emits values from the other endpoint.
       |  Stream<T> get stream;
       |
       |  /// The sink for sending values to the other endpoint.
       |  StreamSink<T> get sink;
       |
       |  /// Creates a new [StreamChannel] that communicates over [stream] and [sink].
       |  ///
       |  /// Note that this stream/sink pair must provide the guarantees listed in the
       |  /// [StreamChannel] documentation. If they don't do so natively, [new
       |  /// StreamChannel.withGuarantees] should be used instead.
       |  factory StreamChannel(Stream<T> stream, StreamSink<T> sink) =>
      0|      new _StreamChannel<T>(stream, sink);
       |
       |  /// Creates a new [StreamChannel] that communicates over [stream] and [sink].
       |  ///
       |  /// Unlike [new StreamChannel], this enforces the guarantees listed in the
       |  /// [StreamChannel] documentation. This makes it somewhat less efficient than
       |  /// just wrapping a stream and a sink directly, so [new StreamChannel] should
       |  /// be used when the guarantees are provided natively.
       |  ///
       |  /// If [allowSinkErrors] is `false`, errors are not allowed to be passed to
       |  /// [sink]. If any are, the connection will close and the error will be
       |  /// forwarded to [Sink.done].
       |  factory StreamChannel.withGuarantees(Stream<T> stream, StreamSink<T> sink,
       |          {bool allowSinkErrors: true}) =>
      0|      new GuaranteeChannel(stream, sink, allowSinkErrors: allowSinkErrors);
       |
       |  /// Creates a new [StreamChannel] that communicates over [stream] and [sink].
       |  ///
       |  /// This specifically enforces the second guarantee: closing the sink causes
       |  /// the stream to close before it emits any more events. This guarantee is
       |  /// invalidated when an asynchronous gap is added between the original
       |  /// stream's event dispatch and the returned stream's, for example by
       |  /// transforming it with a [StreamTransformer]. This is a lighter-weight way
       |  /// of preserving that guarantee in particular than
       |  /// [StreamChannel.withGuarantees].
       |  factory StreamChannel.withCloseGuarantee(Stream<T> stream,
       |          StreamSink<T> sink) =>
      0|      new CloseGuaranteeChannel(stream, sink);
       |
       |  /// Connects [this] to [other], so that any values emitted by either are sent
       |  /// directly to the other.
       |  void pipe(StreamChannel<T> other);
       |
       |  /// Transforms [this] using [transformer].
       |  ///
       |  /// This is identical to calling `transformer.bind(channel)`.
       |  StreamChannel/*<S>*/ transform/*<S>*/(
       |      StreamChannelTransformer<dynamic/*=S*/, T> transformer);
       |
       |  /// Transforms only the [stream] component of [this] using [transformer].
       |  StreamChannel<T> transformStream(StreamTransformer<T, T> transformer);
       |
       |  /// Transforms only the [sink] component of [this] using [transformer].
       |  StreamChannel<T> transformSink(StreamSinkTransformer<T, T> transformer);
       |
       |  /// Returns a copy of [this] with [stream] replaced by [change]'s return
       |  /// value.
       |  StreamChannel<T> changeStream(Stream<T> change(Stream<T> stream));
       |
       |  /// Returns a copy of [this] with [sink] replaced by [change]'s return
       |  /// value.
       |  StreamChannel<T> changeSink(StreamSink<T> change(StreamSink<T> sink));
       |
       |  /// Returns a copy of [this] with the generic type coerced to [S].
       |  ///
       |  /// If any events emitted by [stream] aren't of type [S], they're converted
       |  /// into [CastError] events. Similarly, if any events are added to [sync] that
       |  /// aren't of type [S], a [CastError] is thrown.
       |  StreamChannel/*<S>*/ cast/*<S>*/();
       |}
       |
       |/// An implementation of [StreamChannel] that simply takes a stream and a sink
       |/// as parameters.
       |///
       |/// This is distinct from [StreamChannel] so that it can use
       |/// [StreamChannelMixin].
       |class _StreamChannel<T> extends StreamChannelMixin<T> {
       |  final Stream<T> stream;
       |  final StreamSink<T> sink;
       |
      0|  _StreamChannel(this.stream, this.sink);
       |}
       |
       |/// A mixin that implements the instance methods of [StreamChannel] in terms of
       |/// [stream] and [sink].
       |abstract class StreamChannelMixin<T> implements StreamChannel<T> {
       |  void pipe(StreamChannel<T> other) {
      0|    stream.pipe(other.sink);
      0|    other.stream.pipe(sink);
       |  }
       |
       |  StreamChannel/*<S>*/ transform/*<S>*/(
       |          StreamChannelTransformer<dynamic/*=S*/, T> transformer) =>
      0|      transformer.bind(this);
       |
       |  StreamChannel<T> transformStream(StreamTransformer<T, T> transformer) =>
      0|      changeStream(transformer.bind);
       |
       |  StreamChannel<T> transformSink(StreamSinkTransformer<T, T> transformer) =>
      0|      changeSink(transformer.bind);
       |
       |  StreamChannel<T> changeStream(Stream<T> change(Stream<T> stream)) =>
      0|      new StreamChannel.withCloseGuarantee(change(stream), sink);
       |
       |  StreamChannel<T> changeSink(StreamSink<T> change(StreamSink<T> sink)) =>
      0|      new StreamChannel.withCloseGuarantee(stream, change(sink));
       |
      0|  StreamChannel/*<S>*/ cast/*<S>*/() => new StreamChannel(
      0|      DelegatingStream.typed(stream), DelegatingStreamSink.typed(sink));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/util/remote_exception.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:isolate';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../frontend/expect.dart';
       |
       |/// An exception that was thrown remotely.
       |///
       |/// This could be an exception thrown in a different isolate, a different
       |/// process, or on an entirely different computer.
       |class RemoteException implements Exception {
       |  /// The original exception's message, if it had one.
       |  ///
       |  /// If the original exception was a plain string, this will contain that
       |  /// string.
       |  final String message;
       |
       |  /// The value of the original exception's `runtimeType.toString()`.
       |  final String type;
       |
       |  /// The value of the original exception's `toString()`.
       |  final String _toString;
       |
       |  /// Serializes [error] and [stackTrace] into a JSON-safe object.
       |  ///
       |  /// Other than JSON- and isolate-safety, no guarantees are made about the
       |  /// serialized format.
       |  static serialize(error, StackTrace stackTrace) {
       |    var message;
      0|    if (error is String) {
       |      message = error;
       |    } else {
       |      try {
      0|        message = error.message.toString();
      0|      } on NoSuchMethodError catch (_) {
       |        // Do nothing.
       |      }
       |    }
       |
       |    // It's possible (although unlikely) for a user-defined class to have
       |    // multiple of these supertypes. That's fine, though, since we only care
       |    // about core-library-raised IsolateSpawnExceptions anyway.
       |    var supertype;
      0|    if (error is TestFailure) {
       |      supertype = 'TestFailure';
      0|    } else if (error is IsolateSpawnException) {
       |      supertype = 'IsolateSpawnException';
       |    }
       |
      0|    return {
       |      'message': message,
      0|      'type': error.runtimeType.toString(),
       |      'supertype': supertype,
      0|      'toString': error.toString(),
      0|      'stackChain': new Chain.forTrace(stackTrace).toString()
       |    };
       |  }
       |
       |  /// Deserializes an exception serialized with [RemoteException.serialize].
       |  ///
       |  /// The returned [AsyncError] is guaranteed to have a [RemoteException] as its
       |  /// error and a [Chain] as its stack trace.
       |  static AsyncError deserialize(serialized) {
      0|    return new AsyncError(_deserializeException(serialized),
      0|        new Chain.parse(serialized['stackChain']));
       |  }
       |
       |  /// Deserializes the exception portion of [serialized].
       |  static RemoteException _deserializeException(serialized) {
      0|    var message = serialized['message'];
      0|    var type = serialized['type'];
      0|    var toString = serialized['toString'];
       |
      0|    switch (serialized['supertype']) {
      0|      case 'TestFailure':
      0|        return new _RemoteTestFailure(message, type, toString);
      0|      case 'IsolateSpawnException':
      0|        return new _RemoteIsolateSpawnException(message, type, toString);
       |      default:
      0|        return new RemoteException._(message, type, toString);
       |    }
       |  }
       |
      0|  RemoteException._(this.message, this.type, this._toString);
       |
      0|  String toString() => _toString;
       |}
       |
       |/// A subclass of [RemoteException] that implements [TestFailure].
       |///
       |/// It's important to preserve [TestFailure]-ness, because tests have different
       |/// results depending on whether an exception was a failure or an error.
       |class _RemoteTestFailure extends RemoteException implements TestFailure {
       |  _RemoteTestFailure(String message, String type, String toString)
      0|      : super._(message, type, toString);
       |}
       |
       |/// A subclass of [RemoteException] that implements [IsolateSpawnException].
       |class _RemoteIsolateSpawnException extends RemoteException
       |    implements IsolateSpawnException {
       |  _RemoteIsolateSpawnException(String message, String type, String toString)
      0|      : super._(message, type, toString);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/internal_style.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'context.dart';
       |import 'style.dart';
       |
       |/// The internal interface for the [Style] type.
       |///
       |/// Users should be able to pass around instances of [Style] like an enum, but
       |/// the members that [Context] uses should be hidden from them. Those members
       |/// are defined on this class instead.
       |abstract class InternalStyle extends Style {
       |  /// The default path separator for this style.
       |  ///
       |  /// On POSIX, this is `/`. On Windows, it's `\`.
       |  String get separator;
       |
       |  /// Returns whether [path] contains a separator.
       |  bool containsSeparator(String path);
       |
       |  /// Returns whether [codeUnit] is the character code of a separator.
       |  bool isSeparator(int codeUnit);
       |
       |  /// Returns whether this path component needs a separator after it.
       |  ///
       |  /// Windows and POSIX styles just need separators when the previous component
       |  /// doesn't already end in a separator, but the URL always needs to place a
       |  /// separator between the root and the first component, even if the root
       |  /// already ends in a separator character. For example, to join "file://" and
       |  /// "usr", an additional "/" is needed (making "file:///usr").
       |  bool needsSeparator(String path);
       |
       |  /// Returns the number of characters of the root part.
       |  ///
       |  /// Returns 0 if the path is relative and 1 if the path is root-relative.
       |  ///
       |  /// If [withDrive] is `true`, this should include the drive letter for `file:`
       |  /// URLs. Non-URL styles may ignore the parameter.
       |  int rootLength(String path, {bool withDrive: false});
       |
       |  /// Gets the root prefix of [path] if path is absolute. If [path] is relative,
       |  /// returns `null`.
       |  String getRoot(String path) {
      1|    var length = rootLength(path);
      2|    if (length > 0) return path.substring(0, length);
      1|    return isRootRelative(path) ? path[0] : null;
       |  }
       |
       |  /// Returns whether [path] is root-relative.
       |  ///
       |  /// If [path] is relative or absolute and not root-relative, returns `false`.
       |  bool isRootRelative(String path);
       |
       |  /// Returns the path represented by [uri] in this style.
       |  String pathFromUri(Uri uri);
       |
       |  /// Returns the URI that represents the relative path made of [parts].
       |  Uri relativePathToUri(String path) {
      0|    var segments = context.split(path);
       |
       |    // Ensure that a trailing slash in the path produces a trailing slash in the
       |    // URL.
      0|    if (isSeparator(path.codeUnitAt(path.length - 1))) segments.add('');
      0|    return new Uri(pathSegments: segments);
       |  }
       |
       |  /// Returns the URI that represents [path], which is assumed to be absolute.
       |  Uri absolutePathToUri(String path);
       |
       |  /// Returns whether [codeUnit1] and [codeUnit2] are considered equivalent for
       |  /// this style.
      0|  bool codeUnitsEqual(int codeUnit1, int codeUnit2) => codeUnit1 == codeUnit2;
       |
       |  /// Returns whether [path1] and [path2] are equivalent.
       |  ///
       |  /// This only needs to handle character-by-character comparison; it can assume
       |  /// the paths are normalized and contain no `..` components.
      1|  bool pathsEqual(String path1, String path2) => path1 == path2;
       |
       |  int canonicalizeCodeUnit(int codeUnit) => codeUnit;
       |
       |  String canonicalizePart(String part) => part;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/parsed_path.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'internal_style.dart';
       |import 'style.dart';
       |
       |class ParsedPath {
       |  /// The [InternalStyle] that was used to parse this path.
       |  InternalStyle style;
       |
       |  /// The absolute root portion of the path, or `null` if the path is relative.
       |  /// On POSIX systems, this will be `null` or "/". On Windows, it can be
       |  /// `null`, "//" for a UNC path, or something like "C:\" for paths with drive
       |  /// letters.
       |  String root;
       |
       |  /// Whether this path is root-relative.
       |  ///
       |  /// See [Context.isRootRelative].
       |  bool isRootRelative;
       |
       |  /// The path-separated parts of the path. All but the last will be
       |  /// directories.
       |  List<String> parts;
       |
       |  /// The path separators preceding each part.
       |  ///
       |  /// The first one will be an empty string unless the root requires a separator
       |  /// between it and the path. The last one will be an empty string unless the
       |  /// path ends with a trailing separator.
       |  List<String> separators;
       |
       |  /// The file extension of the last non-empty part, or "" if it doesn't have
       |  /// one.
      0|  String get extension => _splitExtension()[1];
       |
       |  /// `true` if this is an absolute path.
      1|  bool get isAbsolute => root != null;
       |
       |  factory ParsedPath.parse(String path, InternalStyle style) {
       |    // Remove the root prefix, if any.
      1|    var root = style.getRoot(path);
      1|    var isRootRelative = style.isRootRelative(path);
      2|    if (root != null) path = path.substring(root.length);
       |
       |    // Split the parts on path separators.
      1|    var parts = <String>[];
      1|    var separators = <String>[];
       |
       |    var start = 0;
       |
      3|    if (path.isNotEmpty && style.isSeparator(path.codeUnitAt(0))) {
      0|      separators.add(path[0]);
       |      start = 1;
       |    } else {
      1|      separators.add('');
       |    }
       |
      3|    for (var i = start; i < path.length; i++) {
      2|      if (style.isSeparator(path.codeUnitAt(i))) {
      2|        parts.add(path.substring(start, i));
      2|        separators.add(path[i]);
      1|        start = i + 1;
       |      }
       |    }
       |
       |    // Add the final part, if any.
      2|    if (start < path.length) {
      2|      parts.add(path.substring(start));
      1|      separators.add('');
       |    }
       |
      1|    return new ParsedPath._(style, root, isRootRelative, parts, separators);
       |  }
       |
       |  ParsedPath._(
      1|      this.style, this.root, this.isRootRelative, this.parts, this.separators);
       |
       |  String get basename {
      0|    var copy = this.clone();
      0|    copy.removeTrailingSeparators();
      0|    if (copy.parts.isEmpty) return root == null ? '' : root;
      0|    return copy.parts.last;
       |  }
       |
      0|  String get basenameWithoutExtension => _splitExtension()[0];
       |
       |  bool get hasTrailingSeparator =>
      0|      !parts.isEmpty && (parts.last == '' || separators.last != '');
       |
       |  void removeTrailingSeparators() {
      5|    while (!parts.isEmpty && parts.last == '') {
      0|      parts.removeLast();
      0|      separators.removeLast();
       |    }
      8|    if (separators.length > 0) separators[separators.length - 1] = '';
       |  }
       |
       |  void normalize({bool canonicalize: false}) {
       |    // Handle '.', '..', and empty parts.
       |    var leadingDoubles = 0;
      1|    var newParts = <String>[];
      2|    for (var part in parts) {
      2|      if (part == '.' || part == '') {
       |        // Do nothing. Ignore it.
      1|      } else if (part == '..') {
       |        // Pop the last part off.
      0|        if (newParts.length > 0) {
      0|          newParts.removeLast();
       |        } else {
       |          // Backed out past the beginning, so preserve the "..".
      0|          leadingDoubles++;
       |        }
       |      } else {
      1|        newParts.add(canonicalize ? style.canonicalizePart(part) : part);
       |      }
       |    }
       |
       |    // A relative path can back out from the start directory.
      1|    if (!isAbsolute) {
      0|      newParts.insertAll(0, new List.filled(leadingDoubles, '..'));
       |    }
       |
       |    // If we collapsed down to nothing, do ".".
      2|    if (newParts.length == 0 && !isAbsolute) {
      0|      newParts.add('.');
       |    }
       |
       |    // Canonicalize separators.
      1|    var newSeparators = new List<String>.generate(
      3|        newParts.length, (_) => style.separator, growable: true);
      2|    newSeparators.insert(0, isAbsolute &&
      2|        newParts.length > 0 &&
      3|        style.needsSeparator(root) ? style.separator : '');
       |
      1|    parts = newParts;
      1|    separators = newSeparators;
       |
       |    // Normalize the Windows root if needed.
      4|    if (root != null && style == Style.windows) {
      0|      if (canonicalize) root = root.toLowerCase();
      0|      root = root.replaceAll('/', '\\');
       |    }
      1|    removeTrailingSeparators();
       |  }
       |
       |  String toString() {
      1|    var builder = new StringBuffer();
      3|    if (root != null) builder.write(root);
      4|    for (var i = 0; i < parts.length; i++) {
      3|      builder.write(separators[i]);
      3|      builder.write(parts[i]);
       |    }
      3|    builder.write(separators.last);
       |
      1|    return builder.toString();
       |  }
       |
       |  /// Splits the last non-empty part of the path into a `[basename, extension`]
       |  /// pair.
       |  ///
       |  /// Returns a two-element list. The first is the name of the file without any
       |  /// extension. The second is the extension or "" if it has none.
       |  List<String> _splitExtension() {
      0|    var file = parts.lastWhere((p) => p != '', orElse: () => null);
       |
      0|    if (file == null) return ['', ''];
      0|    if (file == '..') return ['..', ''];
       |
      0|    var lastDot = file.lastIndexOf('.');
       |
       |    // If there is no dot, or it's the first character, like '.bashrc', it
       |    // doesn't count.
      0|    if (lastDot <= 0) return [file, ''];
       |
      0|    return [file.substring(0, lastDot), file.substring(lastDot)];
       |  }
       |
      0|  ParsedPath clone() => new ParsedPath._(style, root, isRootRelative,
      0|      new List.from(parts), new List.from(separators));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/chain.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:math' as math;
       |
       |import 'frame.dart';
       |import 'lazy_chain.dart';
       |import 'stack_zone_specification.dart';
       |import 'trace.dart';
       |import 'utils.dart';
       |
       |/// A function that handles errors in the zone wrapped by [Chain.capture].
       |@Deprecated("Will be removed in stack_trace 2.0.0.")
       |typedef void ChainHandler(error, Chain chain);
       |
       |/// An opaque key used to track the current [StackZoneSpecification].
       |final _specKey = new Object();
       |
       |/// A chain of stack traces.
       |///
       |/// A stack chain is a collection of one or more stack traces that collectively
       |/// represent the path from [main] through nested function calls to a particular
       |/// code location, usually where an error was thrown. Multiple stack traces are
       |/// necessary when using asynchronous functions, since the program's stack is
       |/// reset before each asynchronous callback is run.
       |///
       |/// Stack chains can be automatically tracked using [Chain.capture]. This sets
       |/// up a new [Zone] in which the current stack chain is tracked and can be
       |/// accessed using [new Chain.current]. Any errors that would be top-leveled in
       |/// the zone can be handled, along with their associated chains, with the
       |/// `onError` callback. For example:
       |///
       |///     Chain.capture(() {
       |///       // ...
       |///     }, onError: (error, stackChain) {
       |///       print("Caught error $error\n"
       |///             "$stackChain");
       |///     });
       |class Chain implements StackTrace {
       |  /// The stack traces that make up this chain.
       |  ///
       |  /// Like the frames in a stack trace, the traces are ordered from most local
       |  /// to least local. The first one is the trace where the actual exception was
       |  /// raised, the second one is where that callback was scheduled, and so on.
       |  final List<Trace> traces;
       |
       |  /// The [StackZoneSpecification] for the current zone.
      3|  static StackZoneSpecification get _currentSpec => Zone.current[_specKey];
       |
       |  /// If [when] is `true`, runs [callback] in a [Zone] in which the current
       |  /// stack chain is tracked and automatically associated with (most) errors.
       |  ///
       |  /// If [when] is `false`, this does not track stack chains. Instead, it's
       |  /// identical to [runZoned], except that it wraps any errors in [new
       |  /// Chain.forTrace]—which will only wrap the trace unless there's a different
       |  /// [Chain.capture] active. This makes it easy for the caller to only capture
       |  /// stack chains in debug mode or during development.
       |  ///
       |  /// If [onError] is passed, any error in the zone that would otherwise go
       |  /// unhandled is passed to it, along with the [Chain] associated with that
       |  /// error. Note that if [callback] produces multiple unhandled errors,
       |  /// [onError] may be called more than once. If [onError] isn't passed, the
       |  /// parent Zone's `unhandledErrorHandler` will be called with the error and
       |  /// its chain.
       |  ///
       |  /// Note that even if [onError] isn't passed, this zone will still be an error
       |  /// zone. This means that any errors that would cross the zone boundary are
       |  /// considered unhandled.
       |  ///
       |  /// If [callback] returns a value, it will be returned by [capture] as well.
       |  static /*=T*/ capture/*<T>*/(/*=T*/ callback(),
       |      {void onError(error, Chain chain), bool when: true}) {
       |    if (!when) {
       |      var newOnError;
       |      if (onError != null) {
       |        newOnError = (error, stackTrace) {
      0|          onError(
       |              error,
       |              stackTrace == null
      0|                  ? new Chain.current()
      0|                  : new Chain.forTrace(stackTrace));
       |        };
       |      }
       |
      0|      return runZoned(callback, onError: newOnError);
       |    }
       |
      1|    var spec = new StackZoneSpecification(onError);
      1|    return runZoned(() {
       |      try {
      1|        return callback();
       |      } catch (error, stackTrace) {
       |        // TODO(nweiz): Don't special-case this when issue 19566 is fixed.
      0|        return Zone.current.handleUncaughtError(error, stackTrace);
       |      }
      2|    }, zoneSpecification: spec.toSpec(), zoneValues: {
      1|      _specKey: spec,
      1|      StackZoneSpecification.disableKey: false
       |    }) as dynamic/*=T*/;
       |    // TODO(rnystrom): Remove this cast if runZoned() gets a generic type.
       |  }
       |
       |  /// If [when] is `true` and this is called within a [Chain.capture] zone, runs
       |  /// [callback] in a [Zone] in which chain capturing is disabled.
       |  ///
       |  /// If [callback] returns a value, it will be returned by [disable] as well.
       |  static /*=T*/ disable/*<T>*/(/*=T*/ callback(), {bool when: true}) {
       |    var zoneValues = when
      0|        ? {
      0|            _specKey: null,
      0|            StackZoneSpecification.disableKey: true
       |          }
       |        : null;
       |
      0|    return runZoned(callback, zoneValues: zoneValues);
       |  }
       |
       |  /// Returns [futureOrStream] unmodified.
       |  ///
       |  /// Prior to Dart 1.7, this was necessary to ensure that stack traces for
       |  /// exceptions reported with [Completer.completeError] and
       |  /// [StreamController.addError] were tracked correctly.
       |  @Deprecated("Chain.track is not necessary in Dart 1.7+.")
       |  static track(futureOrStream) => futureOrStream;
       |
       |  /// Returns the current stack chain.
       |  ///
       |  /// By default, the first frame of the first trace will be the line where
       |  /// [Chain.current] is called. If [level] is passed, the first trace will
       |  /// start that many frames up instead.
       |  ///
       |  /// If this is called outside of a [capture] zone, it just returns a
       |  /// single-trace chain.
       |  factory Chain.current([int level=0]) {
      0|    if (_currentSpec != null) return _currentSpec.currentChain(level + 1);
       |
      0|    var chain = new Chain.forTrace(StackTrace.current);
      0|    return new LazyChain(() {
       |      // JS includes a frame for the call to StackTrace.current, but the VM
       |      // doesn't, so we skip an extra frame in a JS context.
      0|      var first = new Trace(
      0|          chain.traces.first.frames.skip(level + (inJS ? 2 : 1)));
      0|      return new Chain([first]..addAll(chain.traces.skip(1)));
       |    });
       |  }
       |
       |  /// Returns the stack chain associated with [trace].
       |  ///
       |  /// The first stack trace in the returned chain will always be [trace]
       |  /// (converted to a [Trace] if necessary). If there is no chain associated
       |  /// with [trace] or if this is called outside of a [capture] zone, this just
       |  /// returns a single-trace chain containing [trace].
       |  ///
       |  /// If [trace] is already a [Chain], it will be returned as-is.
       |  factory Chain.forTrace(StackTrace trace) {
      1|    if (trace is Chain) return trace;
      3|    if (_currentSpec != null) return _currentSpec.chainFor(trace);
      0|    return new LazyChain(() => new Chain.parse(trace.toString()));
       |  }
       |
       |  /// Parses a string representation of a stack chain.
       |  ///
       |  /// If [chain] is the output of a call to [Chain.toString], it will be parsed
       |  /// as a full stack chain. Otherwise, it will be parsed as in [Trace.parse]
       |  /// and returned as a single-trace chain.
       |  factory Chain.parse(String chain) {
      0|    if (chain.isEmpty) return new Chain([]);
      0|    if (chain.contains(vmChainGap)) {
      0|      return new Chain(
      0|          chain.split(vmChainGap).map((trace) => new Trace.parseVM(trace)));
       |    }
      0|    if (!chain.contains(chainGap)) return new Chain([new Trace.parse(chain)]);
       |
      0|    return new Chain(
      0|        chain.split(chainGap).map((trace) => new Trace.parseFriendly(trace)));
       |  }
       |
       |  /// Returns a new [Chain] comprised of [traces].
       |  Chain(Iterable<Trace> traces)
      2|      : traces = new List<Trace>.unmodifiable(traces);
       |
       |  /// Returns a terser version of [this].
       |  ///
       |  /// This calls [Trace.terse] on every trace in [traces], and discards any
       |  /// trace that contain only internal frames.
       |  ///
       |  /// This won't do anything with a raw JavaScript trace, since there's no way
       |  /// to determine which frames come from which Dart libraries. However, the
       |  /// [`source_map_stack_trace`][source_map_stack_trace] package can be used to
       |  /// convert JavaScript traces into Dart-style traces.
       |  ///
       |  /// [source_map_stack_trace]: https://pub.dartlang.org/packages/source_map_stack_trace
      0|  Chain get terse => foldFrames((_) => false, terse: true);
       |
       |  /// Returns a new [Chain] based on [this] where multiple stack frames matching
       |  /// [predicate] are folded together.
       |  ///
       |  /// This means that whenever there are multiple frames in a row that match
       |  /// [predicate], only the last one is kept. In addition, traces that are
       |  /// composed entirely of frames matching [predicate] are omitted.
       |  ///
       |  /// This is useful for limiting the amount of library code that appears in a
       |  /// stack trace by only showing user code and code that's called by user code.
       |  ///
       |  /// If [terse] is true, this will also fold together frames from the core
       |  /// library or from this package, and simplify core library frames as in
       |  /// [Trace.terse].
       |  Chain foldFrames(bool predicate(Frame frame), {bool terse: false}) {
      2|    var foldedTraces = traces.map(
      1|        (trace) => trace.foldFrames(predicate, terse: terse));
      1|    var nonEmptyTraces = foldedTraces.where((trace) {
       |      // Ignore traces that contain only folded frames.
      3|      if (trace.frames.length > 1) return true;
      2|      if (trace.frames.isEmpty) return false;
       |
       |      // In terse mode, the trace may have removed an outer folded frame,
       |      // leaving a single non-folded frame. We can detect a folded frame because
       |      // it has no line information.
       |      if (!terse) return false;
      3|      return trace.frames.single.line != null;
       |    });
       |
       |    // If all the traces contain only internal processing, preserve the last
       |    // (top-most) one so that the chain isn't empty.
      1|    if (nonEmptyTraces.isEmpty && foldedTraces.isNotEmpty) {
      0|      return new Chain([foldedTraces.last]);
       |    }
       |
      1|    return new Chain(nonEmptyTraces);
       |  }
       |
       |  /// Converts [this] to a [Trace].
       |  ///
       |  /// The trace version of a chain is just the concatenation of all the traces
       |  /// in the chain.
      0|  Trace toTrace() => new Trace(traces.expand((trace) => trace.frames));
       |
       |  String toString() {
       |    // Figure out the longest path so we know how much to pad.
      2|    var longest = traces.map((trace) {
      4|      return trace.frames.map((frame) => frame.location.length)
      1|          .fold(0, math.max);
      1|    }).fold(0, math.max);
       |
       |    // Don't call out to [Trace.toString] here because that doesn't ensure that
       |    // padding is consistent across all traces.
      2|    return traces.map((trace) {
      2|      return trace.frames.map((frame) {
      4|        return '${frame.location.padRight(longest)}  ${frame.member}\n';
      1|      }).join();
      1|    }).join(chainGap);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/frame.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:path/path.dart' as path;
       |
       |import 'trace.dart';
       |import 'unparsed_frame.dart';
       |
       |// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42:21)
       |// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42)
       |// #1      Foo._bar (file:///home/nweiz/code/stuff.dart)
       |final _vmFrame = new RegExp(r'^#\d+\s+(\S.*) \((.+?)((?::\d+){0,2})\)$');
       |
       |//     at Object.stringify (native)
       |//     at VW.call$0 (http://pub.dartlang.org/stuff.dart.js:560:28)
       |//     at VW.call$0 (eval as fn
       |//         (http://pub.dartlang.org/stuff.dart.js:560:28), efn:3:28)
       |//     at http://pub.dartlang.org/stuff.dart.js:560:28
       |final _v8Frame = new RegExp(
       |    r'^\s*at (?:(\S.*?)(?: \[as [^\]]+\])? \((.*)\)|(.*))$');
       |
       |// http://pub.dartlang.org/stuff.dart.js:560:28
       |final _v8UrlLocation = new RegExp(r'^(.*):(\d+):(\d+)|native$');
       |
       |// eval as function (http://pub.dartlang.org/stuff.dart.js:560:28), efn:3:28
       |// eval as function (http://pub.dartlang.org/stuff.dart.js:560:28)
       |// eval as function (eval as otherFunction
       |//     (http://pub.dartlang.org/stuff.dart.js:560:28))
       |final _v8EvalLocation = new RegExp(
       |    r'^eval at (?:\S.*?) \((.*)\)(?:, .*?:\d+:\d+)?$');
       |
       |// .VW.call$0@http://pub.dartlang.org/stuff.dart.js:560
       |// .VW.call$0("arg")@http://pub.dartlang.org/stuff.dart.js:560
       |// .VW.call$0/name<@http://pub.dartlang.org/stuff.dart.js:560
       |// .VW.call$0@http://pub.dartlang.org/stuff.dart.js:560:36
       |// http://pub.dartlang.org/stuff.dart.js:560
       |final _firefoxSafariFrame = new RegExp(
       |    r'^'
       |    r'(?:' // Member description. Not present in some Safari frames.
       |      r'([^@(/]*)' // The actual name of the member.
       |      r'(?:\(.*\))?' // Arguments to the member, sometimes captured by Firefox.
       |      r'((?:/[^/]*)*)' // Extra characters indicating a nested closure.
       |      r'(?:\(.*\))?' // Arguments to the closure.
       |      r'@'
       |    r')?'
       |    r'(.*?)' // The frame's URL.
       |    r':'
       |    r'(\d*)' // The line number. Empty in Safari if it's unknown.
       |    r'(?::(\d*))?' // The column number. Not present in older browsers and
       |                   // empty in Safari if it's unknown.
       |    r'$');
       |
       |// foo/bar.dart 10:11 Foo._bar
       |// foo/bar.dart 10:11 (anonymous function).dart.fn
       |// http://dartlang.org/foo/bar.dart Foo._bar
       |// data:... 10:11 Foo._bar
       |final _friendlyFrame = new RegExp(
       |    r'^(\S+)(?: (\d+)(?::(\d+))?)?\s+([^\d].*)$');
       |
       |/// A regular expression that matches asynchronous member names generated by the
       |/// VM.
       |final _asyncBody = new RegExp(r'<(<anonymous closure>|[^>]+)_async_body>');
       |
       |final _initialDot = new RegExp(r"^\.");
       |
       |/// A single stack frame. Each frame points to a precise location in Dart code.
       |class Frame {
       |  /// The URI of the file in which the code is located.
       |  ///
       |  /// This URI will usually have the scheme `dart`, `file`, `http`, or `https`.
       |  final Uri uri;
       |
       |  /// The line number on which the code location is located.
       |  ///
       |  /// This can be null, indicating that the line number is unknown or
       |  /// unimportant.
       |  final int line;
       |
       |  /// The column number of the code location.
       |  ///
       |  /// This can be null, indicating that the column number is unknown or
       |  /// unimportant.
       |  final int column;
       |
       |  /// The name of the member in which the code location occurs.
       |  ///
       |  /// Anonymous closures are represented as `<fn>` in this member string.
       |  final String member;
       |
       |  /// Whether this stack frame comes from the Dart core libraries.
      3|  bool get isCore => uri.scheme == 'dart';
       |
       |  /// Returns a human-friendly description of the library that this stack frame
       |  /// comes from.
       |  ///
       |  /// This will usually be the string form of [uri], but a relative URI will be
       |  /// used if possible. Data URIs will be truncated.
       |  String get library {
      3|    if (uri.scheme == 'data') return "data:...";
      2|    return path.prettyUri(uri);
       |  }
       |
       |  /// Returns the name of the package this stack frame comes from, or `null` if
       |  /// this stack frame doesn't come from a `package:` URL.
       |  String get package {
      3|    if (uri.scheme != 'package') return null;
      4|    return uri.path.split('/').first;
       |  }
       |
       |  /// A human-friendly description of the code location.
       |  String get location {
      2|    if (line == null) return library;
      1|    if (column == null) return '$library $line';
      4|    return '$library $line:$column';
       |  }
       |
       |  /// Returns a single frame of the current stack.
       |  ///
       |  /// By default, this will return the frame above the current method. If
       |  /// [level] is `0`, it will return the current method's frame; if [level] is
       |  /// higher than `1`, it will return higher frames.
       |  factory Frame.caller([int level=1]) {
      0|    if (level < 0) {
      0|      throw new ArgumentError("Argument [level] must be greater than or equal "
       |          "to 0.");
       |    }
       |
      0|    return new Trace.current(level + 1).frames.first;
       |  }
       |
       |  /// Parses a string representation of a Dart VM stack frame.
      1|  factory Frame.parseVM(String frame) => _catchFormatException(frame, () {
       |    // The VM sometimes folds multiple stack frames together and replaces them
       |    // with "...".
      1|    if (frame == '...') {
      0|      return new Frame(new Uri(), null, null, '...');
       |    }
       |
      2|    var match = _vmFrame.firstMatch(frame);
      0|    if (match == null) return new UnparsedFrame(frame);
       |
       |    // Get the pieces out of the regexp match. Function, URI and line should
       |    // always be found. The column is optional.
      1|    var member = match[1]
      2|        .replaceAll(_asyncBody, "<async>")
      1|        .replaceAll("<anonymous closure>", "<fn>");
      2|    var uri = Uri.parse(match[2]);
       |
      2|    var lineAndColumn = match[3].split(':');
      4|    var line = lineAndColumn.length > 1 ? int.parse(lineAndColumn[1]) : null;
      4|    var column = lineAndColumn.length > 2 ? int.parse(lineAndColumn[2]) : null;
      1|    return new Frame(uri, line, column, member);
       |  });
       |
       |  /// Parses a string representation of a Chrome/V8 stack frame.
      0|  factory Frame.parseV8(String frame) => _catchFormatException(frame, () {
      0|    var match = _v8Frame.firstMatch(frame);
      0|    if (match == null) return new UnparsedFrame(frame);
       |
       |    // v8 location strings can be arbitrarily-nested, since it adds a layer of
       |    // nesting for each eval performed on that line.
       |    parseLocation(location, member) {
      0|      var evalMatch = _v8EvalLocation.firstMatch(location);
       |      while (evalMatch != null) {
      0|        location = evalMatch[1];
      0|        evalMatch = _v8EvalLocation.firstMatch(location);
       |      }
       |
      0|      if (location == 'native') {
      0|        return new Frame(Uri.parse('native'), null, null, member);
       |      }
       |
      0|      var urlMatch = _v8UrlLocation.firstMatch(location);
      0|      if (urlMatch == null) return new UnparsedFrame(frame);
       |
      0|      return new Frame(
      0|          _uriOrPathToUri(urlMatch[1]),
      0|          int.parse(urlMatch[2]),
      0|          int.parse(urlMatch[3]),
       |          member);
       |    }
       |
       |    // V8 stack frames can be in two forms.
      0|    if (match[2] != null) {
       |      // The first form looks like " at FUNCTION (LOCATION)". V8 proper lists
       |      // anonymous functions within eval as "<anonymous>", while IE10 lists them
       |      // as "Anonymous function".
      0|      return parseLocation(match[2],
      0|          match[1].replaceAll("<anonymous>", "<fn>")
      0|                  .replaceAll("Anonymous function", "<fn>")
      0|                  .replaceAll("(anonymous function)", "<fn>"));
       |    } else {
       |      // The second form looks like " at LOCATION", and is used for anonymous
       |      // functions.
      0|      return parseLocation(match[3], "<fn>");
       |    }
       |  });
       |
       |  /// Parses a string representation of a JavaScriptCore stack trace.
      0|  factory Frame.parseJSCore(String frame) => new Frame.parseV8(frame);
       |
       |  /// Parses a string representation of an IE stack frame.
       |  ///
       |  /// IE10+ frames look just like V8 frames. Prior to IE10, stack traces can't
       |  /// be retrieved.
      0|  factory Frame.parseIE(String frame) => new Frame.parseV8(frame);
       |
       |  /// Parses a string representation of a Firefox stack frame.
      0|  factory Frame.parseFirefox(String frame) => _catchFormatException(frame, () {
      0|    var match = _firefoxSafariFrame.firstMatch(frame);
      0|    if (match == null) return new UnparsedFrame(frame);
       |
       |    // Normally this is a URI, but in a jsshell trace it can be a path.
      0|    var uri = _uriOrPathToUri(match[3]);
       |
       |    var member;
      0|    if (match[1] != null) {
      0|      member = match[1];
      0|      member +=
      0|          new List.filled('/'.allMatches(match[2]).length, ".<fn>").join();
      0|      if (member == '') member = '<fn>';
       |
       |      // Some Firefox members have initial dots. We remove them for consistency
       |      // with other platforms.
      0|      member = member.replaceFirst(_initialDot, '');
       |    } else {
       |      member = '<fn>';
       |    }
       |
      0|    var line = match[4] == '' ? null : int.parse(match[4]);
      0|    var column = match[5] == null || match[5] == '' ?
      0|        null : int.parse(match[5]);
      0|    return new Frame(uri, line, column, member);
       |  });
       |
       |  /// Parses a string representation of a Safari 6.0 stack frame.
       |  @Deprecated("Use Frame.parseSafari instead.")
      0|  factory Frame.parseSafari6_0(String frame) => new Frame.parseFirefox(frame);
       |
       |  /// Parses a string representation of a Safari 6.1+ stack frame.
       |  @Deprecated("Use Frame.parseSafari instead.")
      0|  factory Frame.parseSafari6_1(String frame) => new Frame.parseFirefox(frame);
       |
       |  /// Parses a string representation of a Safari stack frame.
      0|  factory Frame.parseSafari(String frame) => new Frame.parseFirefox(frame);
       |
       |  /// Parses this package's string representation of a stack frame.
      0|  factory Frame.parseFriendly(String frame) => _catchFormatException(frame, () {
      0|    var match = _friendlyFrame.firstMatch(frame);
       |    if (match == null) {
      0|      throw new FormatException(
      0|          "Couldn't parse package:stack_trace stack trace line '$frame'.");
       |    }
       |    // Fake truncated data urls generated by the friendly stack trace format
       |    // cause Uri.parse to throw an exception so we have to special case them.
      0|    var uri = match[1] == 'data:...'
      0|        ? new Uri.dataFromString('')
      0|        : Uri.parse(match[1]);
       |    // If there's no scheme, this is a relative URI. We should interpret it as
       |    // relative to the current working directory.
      0|    if (uri.scheme == '') {
      0|      uri = path.toUri(path.absolute(path.fromUri(uri)));
       |    }
       |
      0|    var line = match[2] == null ? null : int.parse(match[2]);
      0|    var column = match[3] == null ? null : int.parse(match[3]);
      0|    return new Frame(uri, line, column, match[4]);
       |  });
       |
       |  /// A regular expression matching an absolute URI.
       |  static final _uriRegExp = new RegExp(r'^[a-zA-Z][-+.a-zA-Z\d]*://');
       |
       |  /// A regular expression matching a Windows path.
       |  static final _windowsRegExp = new RegExp(r'^([a-zA-Z]:[\\/]|\\\\)');
       |
       |  /// Converts [uriOrPath], which can be a URI, a Windows path, or a Posix path,
       |  /// to a URI (absolute if possible).
       |  static Uri _uriOrPathToUri(String uriOrPath) {
      0|    if (uriOrPath.contains(_uriRegExp)) {
      0|      return Uri.parse(uriOrPath);
      0|    } else if (uriOrPath.contains(_windowsRegExp)) {
      0|      return new Uri.file(uriOrPath, windows: true);
      0|    } else if (uriOrPath.startsWith('/')) {
      0|      return new Uri.file(uriOrPath, windows: false);
       |    }
       |
       |    // As far as I've seen, Firefox and V8 both always report absolute paths in
       |    // their stack frames. However, if we do get a relative path, we should
       |    // handle it gracefully.
      0|    if (uriOrPath.contains('\\')) return path.windows.toUri(uriOrPath);
      0|    return Uri.parse(uriOrPath);
       |  }
       |
       |  /// Runs [body] and returns its result.
       |  ///
       |  /// If [body] throws a [FormatException], returns an [UnparsedFrame] with
       |  /// [text] instead.
       |  static Frame _catchFormatException(String text, Frame body()) {
       |    try {
      1|      return body();
      0|    } on FormatException catch (_) {
      0|      return new UnparsedFrame(text);
       |    }
       |  }
       |
      1|  Frame(this.uri, this.line, this.column, this.member);
       |
      0|  String toString() => '$location in $member';
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/trace.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |
       |import 'chain.dart';
       |import 'frame.dart';
       |import 'lazy_trace.dart';
       |import 'unparsed_frame.dart';
       |import 'utils.dart';
       |import 'vm_trace.dart';
       |
       |final _terseRegExp = new RegExp(r"(-patch)?([/\\].*)?$");
       |
       |/// A RegExp to match V8's stack traces.
       |///
       |/// V8's traces start with a line that's either just "Error" or else is a
       |/// description of the exception that occurred. That description can be multiple
       |/// lines, so we just look for any line other than the first that begins with
       |/// three or four spaces and "at".
       |final _v8Trace = new RegExp(r"\n    ?at ");
       |
       |/// A RegExp to match indidual lines of V8's stack traces.
       |///
       |/// This is intended to filter out the leading exception details of the trace
       |/// though it is possible for the message to match this as well.
       |final _v8TraceLine = new RegExp(r"    ?at ");
       |
       |/// A RegExp to match Firefox and Safari's stack traces.
       |///
       |/// Firefox and Safari have very similar stack trace formats, so we use the same
       |/// logic for parsing them.
       |///
       |/// Firefox's trace frames start with the name of the function in which the
       |/// error occurred, possibly including its parameters inside `()`. For example,
       |/// `.VW.call$0("arg")@http://pub.dartlang.org/stuff.dart.js:560`.
       |///
       |/// Safari traces occasionally don't include the initial method name followed by
       |/// "@", and they always have both the line and column number (or just a
       |/// trailing colon if no column number is available). They can also contain
       |/// empty lines or lines consisting only of `[native code]`.
       |final _firefoxSafariTrace = new RegExp(
       |    r"^"
       |    r"(" // Member description. Not present in some Safari frames.
       |      r"([.0-9A-Za-z_$/<]|\(.*\))*" // Member name and arguments.
       |      r"@"
       |    r")?"
       |    r"[^\s]*" // Frame URL.
       |    r":\d*" // Line or column number. Some older frames only have a line number.
       |    r"$", multiLine: true);
       |
       |/// A RegExp to match this package's stack traces.
       |final _friendlyTrace = new RegExp(r"^[^\s<][^\s]*( \d+(:\d+)?)?[ \t]+[^\s]+$",
       |    multiLine: true);
       |
       |/// A stack trace, comprised of a list of stack frames.
       |class Trace implements StackTrace {
       |  /// The stack frames that comprise this stack trace.
       |  final List<Frame> frames;
       |
       |  /// Returns a human-readable representation of [stackTrace]. If [terse] is
       |  /// set, this folds together multiple stack frames from the Dart core
       |  /// libraries, so that only the core library method directly called from user
       |  /// code is visible (see [Trace.terse]).
       |  static String format(StackTrace stackTrace, {bool terse: true}) {
      0|    var trace = new Trace.from(stackTrace);
      0|    if (terse) trace = trace.terse;
      0|    return trace.toString();
       |  }
       |
       |  /// Returns the current stack trace.
       |  ///
       |  /// By default, the first frame of this trace will be the line where
       |  /// [Trace.current] is called. If [level] is passed, the trace will start that
       |  /// many frames up instead.
       |  factory Trace.current([int level=0]) {
      0|    if (level < 0) {
      0|      throw new ArgumentError("Argument [level] must be greater than or equal "
       |          "to 0.");
       |    }
       |
      0|    var trace = new Trace.from(StackTrace.current);
      0|    return new LazyTrace(() {
       |      // JS includes a frame for the call to StackTrace.current, but the VM
       |      // doesn't, so we skip an extra frame in a JS context.
      0|      return new Trace(trace.frames.skip(level + (inJS ? 2 : 1)));
       |    });
       |  }
       |
       |  /// Returns a new stack trace containing the same data as [trace].
       |  ///
       |  /// If [trace] is a native [StackTrace], its data will be parsed out; if it's
       |  /// a [Trace], it will be returned as-is.
       |  factory Trace.from(StackTrace trace) {
       |    // Normally explicitly validating null arguments is bad Dart style, but here
       |    // the natural failure will only occur when the LazyTrace is materialized,
       |    // and we want to provide an error that's more local to the actual problem.
       |    if (trace == null) {
      0|      throw new ArgumentError("Cannot create a Trace from null.");
       |    }
       |
      1|    if (trace is Trace) return trace;
      1|    if (trace is Chain) return trace.toTrace();
      3|    return new LazyTrace(() => new Trace.parse(trace.toString()));
       |  }
       |
       |  /// Parses a string representation of a stack trace.
       |  ///
       |  /// [trace] should be formatted in the same way as a Dart VM or browser stack
       |  /// trace. If it's formatted as a stack chain, this will return the equivalent
       |  /// of [Chain.toTrace].
       |  factory Trace.parse(String trace) {
       |    try {
      1|      if (trace.isEmpty) return new Trace(<Frame>[]);
      2|      if (trace.contains(_v8Trace)) return new Trace.parseV8(trace);
      1|      if (trace.contains("\tat ")) return new Trace.parseJSCore(trace);
      2|      if (trace.contains(_firefoxSafariTrace)) {
      0|        return new Trace.parseFirefox(trace);
       |      }
      1|      if (trace.contains(chainGap)) return new Chain.parse(trace).toTrace();
      2|      if (trace.contains(_friendlyTrace)) {
      0|        return new Trace.parseFriendly(trace);
       |      }
       |
       |      // Default to parsing the stack trace as a VM trace. This is also hit on
       |      // IE and Safari, where the stack trace is just an empty string (issue
       |      // 11257).
      1|      return new Trace.parseVM(trace);
      0|    } on FormatException catch (error) {
      0|      throw new FormatException('${error.message}\nStack trace:\n$trace');
       |    }
       |  }
       |
       |  /// Parses a string representation of a Dart VM stack trace.
       |  Trace.parseVM(String trace)
      2|      : this(_parseVM(trace));
       |
       |  static List<Frame> _parseVM(String trace) {
       |    // Ignore [vmChainGap]. This matches the behavior of
       |    // `Chain.parse().toTrace()`.
      3|    var lines = trace.trim().replaceAll(vmChainGap, '').split("\n");
      3|    var frames = lines.take(lines.length - 1)
      2|        .map((line) => new Frame.parseVM(line))
      1|        .toList();
       |
       |    // TODO(nweiz): Remove this when issue 23614 is fixed.
      2|    if (!lines.last.endsWith(".da")) {
      3|      frames.add(new Frame.parseVM(lines.last));
       |    }
       |
       |    return frames;
       |  }
       |
       |  /// Parses a string representation of a Chrome/V8 stack trace.
       |  Trace.parseV8(String trace)
      0|      : this(trace.split("\n").skip(1)
       |          // It's possible that an Exception's description contains a line that
       |          // looks like a V8 trace line, which will screw this up.
       |          // Unfortunately, that's impossible to detect.
      0|          .skipWhile((line) => !line.startsWith(_v8TraceLine))
      0|          .map((line) => new Frame.parseV8(line)));
       |
       |  /// Parses a string representation of a JavaScriptCore stack trace.
       |  Trace.parseJSCore(String trace)
      0|      : this(trace.split("\n")
      0|            .where((line) => line != "\tat ")
      0|            .map((line) => new Frame.parseV8(line)));
       |
       |  /// Parses a string representation of an Internet Explorer stack trace.
       |  ///
       |  /// IE10+ traces look just like V8 traces. Prior to IE10, stack traces can't
       |  /// be retrieved.
       |  Trace.parseIE(String trace)
      0|      : this.parseV8(trace);
       |
       |  /// Parses a string representation of a Firefox stack trace.
       |  Trace.parseFirefox(String trace)
      0|      : this(trace.trim().split("\n")
      0|          .where((line) => line.isNotEmpty && line != '[native code]')
      0|          .map((line) => new Frame.parseFirefox(line)));
       |
       |  /// Parses a string representation of a Safari stack trace.
       |  Trace.parseSafari(String trace)
      0|      : this.parseFirefox(trace);
       |
       |  /// Parses a string representation of a Safari 6.1+ stack trace.
       |  @Deprecated("Use Trace.parseSafari instead.")
       |  Trace.parseSafari6_1(String trace)
      0|      : this.parseSafari(trace);
       |
       |  /// Parses a string representation of a Safari 6.0 stack trace.
       |  @Deprecated("Use Trace.parseSafari instead.")
       |  Trace.parseSafari6_0(String trace)
      0|      : this(trace.trim().split("\n")
      0|          .where((line) => line != '[native code]')
      0|          .map((line) => new Frame.parseFirefox(line)));
       |
       |  /// Parses this package's string representation of a stack trace.
       |  ///
       |  /// This also parses string representations of [Chain]s. They parse to the
       |  /// same trace that [Chain.toTrace] would return.
       |  Trace.parseFriendly(String trace)
      0|      : this(trace.isEmpty
      0|            ? []
      0|            : trace.trim().split("\n")
       |                // Filter out asynchronous gaps from [Chain]s.
      0|                .where((line) => !line.startsWith('====='))
      0|                .map((line) => new Frame.parseFriendly(line)));
       |
       |  /// Returns a new [Trace] comprised of [frames].
       |  Trace(Iterable<Frame> frames)
      2|      : frames = new List<Frame>.unmodifiable(frames);
       |
       |  /// Returns a VM-style [StackTrace] object.
       |  ///
       |  /// The return value's [toString] method will always return a string
       |  /// representation in the Dart VM's stack trace format, regardless of what
       |  /// platform is being used.
      0|  StackTrace get vmTrace => new VMTrace(frames);
       |
       |  /// Returns a terser version of [this].
       |  ///
       |  /// This is accomplished by folding together multiple stack frames from the
       |  /// core library or from this package, as in [foldFrames]. Remaining core
       |  /// library frames have their libraries, "-patch" suffixes, and line numbers
       |  /// removed. If the outermost frame of the stack trace is a core library
       |  /// frame, it's removed entirely.
       |  ///
       |  /// This won't do anything with a raw JavaScript trace, since there's no way
       |  /// to determine which frames come from which Dart libraries. However, the
       |  /// [`source_map_stack_trace`][source_map_stack_trace] package can be used to
       |  /// convert JavaScript traces into Dart-style traces.
       |  ///
       |  /// [source_map_stack_trace]: https://pub.dartlang.org/packages/source_map_stack_trace
       |  ///
       |  /// For custom folding, see [foldFrames].
      0|  Trace get terse => foldFrames((_) => false, terse: true);
       |
       |  /// Returns a new [Trace] based on [this] where multiple stack frames matching
       |  /// [predicate] are folded together.
       |  ///
       |  /// This means that whenever there are multiple frames in a row that match
       |  /// [predicate], only the last one is kept. This is useful for limiting the
       |  /// amount of library code that appears in a stack trace by only showing user
       |  /// code and code that's called by user code.
       |  ///
       |  /// If [terse] is true, this will also fold together frames from the core
       |  /// library or from this package, simplify core library frames, and
       |  /// potentially remove the outermost frame as in [Trace.terse].
       |  Trace foldFrames(bool predicate(Frame frame), {bool terse: false}) {
       |    if (terse) {
       |      var oldPredicate = predicate;
       |      predicate = (frame) {
      1|        if (oldPredicate(frame)) return true;
       |
      1|        if (frame.isCore) return true;
      2|        if (frame.package == 'stack_trace') return true;
       |
       |        // Ignore async stack frames without any line or column information.
       |        // These come from the VM's async/await implementation and represent
       |        // internal frames. They only ever show up in stack chains and are
       |        // always surrounded by other traces that are actually useful, so we can
       |        // just get rid of them.
       |        // TODO(nweiz): Get rid of this logic some time after issue 22009 is
       |        // fixed.
      2|        if (!frame.member.contains('<async>')) return false;
      0|        return frame.line == null;
       |      };
       |    }
       |
      1|    var newFrames = <Frame>[];
      3|    for (var frame in frames.reversed) {
      2|      if (frame is UnparsedFrame || !predicate(frame)) {
      1|        newFrames.add(frame);
      3|      } else if (newFrames.isEmpty || !predicate(newFrames.last)) {
      2|        newFrames.add(new Frame(
      4|            frame.uri, frame.line, frame.column, frame.member));
       |      }
       |    }
       |
       |    if (terse) {
      1|      newFrames = newFrames.map((frame) {
      2|        if (frame is UnparsedFrame || !predicate(frame)) return frame;
      3|        var library = frame.library.replaceAll(_terseRegExp, '');
      3|        return new Frame(Uri.parse(library), null, null, frame.member);
      1|      }).toList();
       |
      4|      if (newFrames.length > 1 && predicate(newFrames.first)) {
      1|        newFrames.removeAt(0);
       |      }
       |    }
       |
      2|    return new Trace(newFrames.reversed);
       |  }
       |
       |  /// Returns a human-readable string representation of [this].
       |  String toString() {
       |    // Figure out the longest path so we know how much to pad.
      0|    var longest = frames.map((frame) => frame.location.length)
      0|        .fold(0, math.max);
       |
       |    // Print out the stack trace nicely formatted.
      0|    return frames.map((frame) {
      0|      if (frame is UnparsedFrame) return "$frame\n";
      0|      return '${frame.location.padRight(longest)}  ${frame.member}\n';
      0|    }).join();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/unparsed_frame.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'frame.dart';
       |
       |/// A frame that failed to parse.
       |///
       |/// The [member] property contains the original frame's contents.
       |class UnparsedFrame implements Frame {
       |  final Uri uri = new Uri(path: "unparsed");
       |  final int line = null;
       |  final int column = null;
       |  final bool isCore = false;
       |  final String library = "unparsed";
       |  final String package = null;
       |  final String location = "unparsed";
       |
       |  final String member;
       |
      0|  UnparsedFrame(this.member);
       |
      0|  String toString() => member;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/style/posix.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../characters.dart' as chars;
       |import '../parsed_path.dart';
       |import '../internal_style.dart';
       |
       |/// The style for POSIX paths.
       |class PosixStyle extends InternalStyle {
      1|  PosixStyle();
       |
       |  final name = 'posix';
       |  final separator = '/';
       |  final separators = const ['/'];
       |
       |  // Deprecated properties.
       |
       |  final separatorPattern = new RegExp(r'/');
       |  final needsSeparatorPattern = new RegExp(r'[^/]$');
       |  final rootPattern = new RegExp(r'^/');
       |  final relativeRootPattern = null;
       |
      0|  bool containsSeparator(String path) => path.contains('/');
       |
      1|  bool isSeparator(int codeUnit) => codeUnit == chars.SLASH;
       |
       |  bool needsSeparator(String path) =>
      5|      path.isNotEmpty && !isSeparator(path.codeUnitAt(path.length - 1));
       |
       |  int rootLength(String path, {bool withDrive: false}) {
      3|    if (path.isNotEmpty && isSeparator(path.codeUnitAt(0))) return 1;
       |    return 0;
       |  }
       |
       |  bool isRootRelative(String path) => false;
       |
       |  String getRelativeRoot(String path) => null;
       |
       |  String pathFromUri(Uri uri) {
      4|    if (uri.scheme == '' || uri.scheme == 'file') {
      2|      return Uri.decodeComponent(uri.path);
       |    }
      0|    throw new ArgumentError("Uri $uri must have scheme 'file:'.");
       |  }
       |
       |  Uri absolutePathToUri(String path) {
      0|    var parsed = new ParsedPath.parse(path, this);
      0|    if (parsed.parts.isEmpty) {
       |      // If the path is a bare root (e.g. "/"), [components] will
       |      // currently be empty. We add two empty components so the URL constructor
       |      // produces "file:///", with a trailing slash.
      0|      parsed.parts.addAll(["", ""]);
      0|    } else if (parsed.hasTrailingSeparator) {
       |      // If the path has a trailing slash, add a single empty component so the
       |      // URI has a trailing slash as well.
      0|      parsed.parts.add("");
       |    }
       |
      0|    return new Uri(scheme: 'file', pathSegments: parsed.parts);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/style/url.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../characters.dart' as chars;
       |import '../internal_style.dart';
       |import '../utils.dart';
       |
       |/// The style for URL paths.
       |class UrlStyle extends InternalStyle {
      1|  UrlStyle();
       |
       |  final name = 'url';
       |  final separator = '/';
       |  final separators = const ['/'];
       |
       |  // Deprecated properties.
       |
       |  final separatorPattern = new RegExp(r'/');
       |  final needsSeparatorPattern =
       |      new RegExp(r"(^[a-zA-Z][-+.a-zA-Z\d]*://|[^/])$");
       |  final rootPattern = new RegExp(r"[a-zA-Z][-+.a-zA-Z\d]*://[^/]*");
       |  final relativeRootPattern = new RegExp(r"^/");
       |
      0|  bool containsSeparator(String path) => path.contains('/');
       |
      0|  bool isSeparator(int codeUnit) => codeUnit == chars.SLASH;
       |
       |  bool needsSeparator(String path) {
      0|    if (path.isEmpty) return false;
       |
       |    // A URL that doesn't end in "/" always needs a separator.
      0|    if (!isSeparator(path.codeUnitAt(path.length - 1))) return true;
       |
       |    // A URI that's just "scheme://" needs an extra separator, despite ending
       |    // with "/".
      0|    return path.endsWith("://") && rootLength(path) == path.length;
       |  }
       |
       |  int rootLength(String path, {bool withDrive: false}) {
      0|    if (path.isEmpty) return 0;
      0|    if (isSeparator(path.codeUnitAt(0))) return 1;
       |
      0|    var index = path.indexOf("/");
      0|    if (index > 0 && path.startsWith('://', index - 1)) {
       |      // The root part is up until the next '/', or the full path. Skip
       |      // '://' and search for '/' after that.
      0|      index = path.indexOf('/', index + 2);
      0|      if (index <= 0) return path.length;
       |
       |      // file: URLs sometimes consider Windows drive letters part of the root.
       |      // See https://url.spec.whatwg.org/#file-slash-state.
      0|      if (!withDrive || path.length < index + 3) return index;
      0|      if (!path.startsWith('file://')) return index;
      0|      if (!isDriveLetter(path, index + 1)) return index;
      0|      return path.length == index + 3 ? index + 3 : index + 4;
       |    }
       |    return 0;
       |  }
       |
       |  bool isRootRelative(String path) =>
      0|      path.isNotEmpty && isSeparator(path.codeUnitAt(0));
       |
      0|  String getRelativeRoot(String path) => isRootRelative(path) ? '/' : null;
       |
      0|  String pathFromUri(Uri uri) => uri.toString();
       |
      0|  Uri relativePathToUri(String path) => Uri.parse(path);
      0|  Uri absolutePathToUri(String path) => Uri.parse(path);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/style/windows.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../characters.dart' as chars;
       |import '../internal_style.dart';
       |import '../parsed_path.dart';
       |import '../utils.dart';
       |
       |// `0b100000` can be bitwise-ORed with uppercase ASCII letters to get their
       |// lowercase equivalents.
       |const _asciiCaseBit = 0x20;
       |
       |/// The style for Windows paths.
       |class WindowsStyle extends InternalStyle {
      1|  WindowsStyle();
       |
       |  final name = 'windows';
       |  final separator = '\\';
       |  final separators = const ['/', '\\'];
       |
       |  // Deprecated properties.
       |
       |  final separatorPattern = new RegExp(r'[/\\]');
       |  final needsSeparatorPattern = new RegExp(r'[^/\\]$');
       |  final rootPattern = new RegExp(r'^(\\\\[^\\]+\\[^\\/]+|[a-zA-Z]:[/\\])');
       |  final relativeRootPattern = new RegExp(r"^[/\\](?![/\\])");
       |
      0|  bool containsSeparator(String path) => path.contains('/');
       |
       |  bool isSeparator(int codeUnit) =>
      0|      codeUnit == chars.SLASH || codeUnit == chars.BACKSLASH;
       |
       |  bool needsSeparator(String path) {
      0|    if (path.isEmpty) return false;
      0|    return !isSeparator(path.codeUnitAt(path.length - 1));
       |  }
       |
       |  int rootLength(String path, {bool withDrive: false}) {
      0|    if (path.isEmpty) return 0;
      0|    if (path.codeUnitAt(0) == chars.SLASH) return 1;
      0|    if (path.codeUnitAt(0) == chars.BACKSLASH) {
      0|      if (path.length < 2 || path.codeUnitAt(1) != chars.BACKSLASH) return 1;
       |      // The path is a network share. Search for up to two '\'s, as they are
       |      // the server and share - and part of the root part.
      0|      var index = path.indexOf('\\', 2);
      0|      if (index > 0) {
      0|        index = path.indexOf('\\', index + 1);
      0|        if (index > 0) return index;
       |      }
      0|      return path.length;
       |    }
       |    // If the path is of the form 'C:/' or 'C:\', with C being any letter, it's
       |    // a root part.
      0|    if (path.length < 3) return 0;
       |    // Check for the letter.
      0|    if (!isAlphabetic(path.codeUnitAt(0))) return 0;
       |    // Check for the ':'.
      0|    if (path.codeUnitAt(1) != chars.COLON) return 0;
       |    // Check for either '/' or '\'.
      0|    if (!isSeparator(path.codeUnitAt(2))) return 0;
       |    return 3;
       |  }
       |
      0|  bool isRootRelative(String path) => rootLength(path) == 1;
       |
       |  String getRelativeRoot(String path) {
      0|    var length = rootLength(path);
      0|    if (length == 1) return path[0];
       |    return null;
       |  }
       |
       |  String pathFromUri(Uri uri) {
      0|    if (uri.scheme != '' && uri.scheme != 'file') {
      0|      throw new ArgumentError("Uri $uri must have scheme 'file:'.");
       |    }
       |
      0|    var path = uri.path;
      0|    if (uri.host == '') {
       |      // Drive-letter paths look like "file:///C:/path/to/file". The
       |      // replaceFirst removes the extra initial slash. Otherwise, leave the
       |      // slash to match IE's interpretation of "/foo" as a root-relative path.
      0|      if (path.length >= 3 &&
      0|          path.startsWith('/') &&
      0|          isDriveLetter(path, 1)) {
      0|        path = path.replaceFirst("/", "");
       |      }
       |    } else {
       |      // Network paths look like "file://hostname/path/to/file".
      0|      path = '\\\\${uri.host}$path';
       |    }
      0|    return Uri.decodeComponent(path.replaceAll("/", "\\"));
       |  }
       |
       |  Uri absolutePathToUri(String path) {
      0|    var parsed = new ParsedPath.parse(path, this);
      0|    if (parsed.root.startsWith(r'\\')) {
       |      // Network paths become "file://server/share/path/to/file".
       |
       |      // The root is of the form "\\server\share". We want "server" to be the
       |      // URI host, and "share" to be the first element of the path.
      0|      var rootParts = parsed.root.split('\\').where((part) => part != '');
      0|      parsed.parts.insert(0, rootParts.last);
       |
      0|      if (parsed.hasTrailingSeparator) {
       |        // If the path has a trailing slash, add a single empty component so the
       |        // URI has a trailing slash as well.
      0|        parsed.parts.add("");
       |      }
       |
      0|      return new Uri(
      0|          scheme: 'file', host: rootParts.first, pathSegments: parsed.parts);
       |    } else {
       |      // Drive-letter paths become "file:///C:/path/to/file".
       |
       |      // If the path is a bare root (e.g. "C:\"), [parsed.parts] will currently
       |      // be empty. We add an empty component so the URL constructor produces
       |      // "file:///C:/", with a trailing slash. We also add an empty component if
       |      // the URL otherwise has a trailing slash.
      0|      if (parsed.parts.length == 0 || parsed.hasTrailingSeparator) {
      0|        parsed.parts.add("");
       |      }
       |
       |      // Get rid of the trailing "\" in "C:\" because the URI constructor will
       |      // add a separator on its own.
      0|      parsed.parts.insert(
      0|          0, parsed.root.replaceAll("/", "").replaceAll("\\", ""));
       |
      0|      return new Uri(scheme: 'file', pathSegments: parsed.parts);
       |    }
       |  }
       |
       |  bool codeUnitsEqual(int codeUnit1, int codeUnit2) {
      0|    if (codeUnit1 == codeUnit2) return true;
       |
       |    /// Forward slashes and backslashes are equivalent on Windows.
      0|    if (codeUnit1 == chars.SLASH) return codeUnit2 == chars.BACKSLASH;
      0|    if (codeUnit1 == chars.BACKSLASH) return codeUnit2 == chars.SLASH;
       |
       |    // If this check fails, the code units are definitely different. If it
       |    // succeeds *and* either codeUnit is an ASCII letter, they're equivalent.
      0|    if (codeUnit1 ^ codeUnit2 != _asciiCaseBit) return false;
       |
       |    // Now we just need to verify that one of the code units is an ASCII letter.
      0|    var upperCase1 = codeUnit1 | _asciiCaseBit;
      0|    return upperCase1 >= chars.LOWER_A && upperCase1 <= chars.LOWER_Z;
       |  }
       |
       |  bool pathsEqual(String path1, String path2) {
       |    if (identical(path1, path2)) return true;
      0|    if (path1.length != path2.length) return false;
      0|    for (var i = 0; i < path1.length; i++) {
      0|      if (!codeUnitsEqual(path1.codeUnitAt(i), path2.codeUnitAt(i))) {
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
       |  int canonicalizeCodeUnit(int codeUnit) {
      0|    if (codeUnit == chars.SLASH) return chars.BACKSLASH;
      0|    if (codeUnit < chars.UPPER_A) return codeUnit;
      0|    if (codeUnit > chars.UPPER_Z) return codeUnit;
      0|    return codeUnit | _asciiCaseBit;
       |  }
       |
      0|  String canonicalizePart(String part) => part.toLowerCase();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.1/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Validates the arguments passed to [StringScanner.error].
       |void validateErrorArgs(String string, Match match, int position, int length) {
       |  if (match != null && (position != null || length != null)) {
      0|    throw new ArgumentError("Can't pass both match and position/length.");
       |  }
       |
       |  if (position != null) {
      0|    if (position < 0) {
      0|      throw new RangeError("position must be greater than or equal to 0.");
      0|    } else if (position > string.length) {
      0|      throw new RangeError("position must be less than or equal to the "
       |          "string length.");
       |    }
       |  }
       |
      0|  if (length != null && length < 0) {
      0|    throw new RangeError("length must be greater than or equal to 0.");
       |  }
       |
      0|  if (position != null && length != null && position + length > string.length) {
      0|    throw new RangeError("position plus length must not go beyond the end of "
       |        "the string.");
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.1/lib/src/eager_span_scanner.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:charcode/ascii.dart';
       |
       |import 'line_scanner.dart';
       |import 'span_scanner.dart';
       |
       |// TODO(nweiz): Currently this duplicates code in line_scanner.dart. Once
       |// sdk#23770 is fully complete, we should move the shared code into a mixin.
       |
       |/// A regular expression matching newlines across platforms.
       |final _newlineRegExp = new RegExp(r"\r\n?|\n");
       |
       |/// A [SpanScanner] that tracks the line and column eagerly, like [LineScanner].
       |class EagerSpanScanner extends SpanScanner {
      0|  int get line => _line;
       |  int _line = 0;
       |
      0|  int get column => _column;
       |  int _column = 0;
       |
       |  LineScannerState get state =>
      0|      new _EagerSpanScannerState(this, position, line, column);
       |
      0|  bool get _betweenCRLF => peekChar(-1) == $cr && peekChar() == $lf;
       |
       |  set state(LineScannerState state) {
      0|    if (state is! _EagerSpanScannerState ||
      0|        !identical((state as _EagerSpanScannerState)._scanner, this)) {
      0|      throw new ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    super.position = state.position;
      0|    _line = state.line;
      0|    _column = state.column;
       |  }
       |
       |  set position(int newPosition) {
      0|    var oldPosition = position;
      0|    super.position = newPosition;
       |
      0|    if (newPosition > oldPosition) {
      0|      var newlines = _newlinesIn(string.substring(oldPosition, newPosition));
      0|      _line += newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column += newPosition - oldPosition;
       |      } else {
      0|        _column = newPosition - newlines.last.end;
       |      }
       |    } else {
      0|      var newlines = _newlinesIn(string.substring(newPosition, oldPosition));
      0|      if (_betweenCRLF) newlines.removeLast();
       |
      0|      _line -= newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column -= oldPosition - newPosition;
       |      } else {
      0|        _column = newPosition -
      0|            string.lastIndexOf(_newlineRegExp, newPosition) - 1;
       |      }
       |    }
       |  }
       |
       |  EagerSpanScanner(String string, {sourceUrl, int position})
      0|      : super(string, sourceUrl: sourceUrl, position: position);
       |
       |  bool scanChar(int character) {
      0|    if (!super.scanChar(character)) return false;
      0|    _adjustLineAndColumn(character);
       |    return true;
       |  }
       |
       |  int readChar() {
      0|    var character = super.readChar();
      0|    _adjustLineAndColumn(character);
       |    return character;
       |  }
       |
       |  /// Adjusts [_line] and [_column] after having consumed [character].
       |  void _adjustLineAndColumn(int character) {
      0|    if (character == $lf || (character == $cr && peekChar() != $lf)) {
      0|      _line += 1;
      0|      _column = 0;
       |    } else {
      0|      _column += 1;
       |    }
       |  }
       |
       |  bool scan(Pattern pattern) {
      0|    if (!super.scan(pattern)) return false;
       |
      0|    var newlines = _newlinesIn(lastMatch[0]);
      0|    _line += newlines.length;
      0|    if (newlines.isEmpty) {
      0|      _column += lastMatch[0].length;
       |    } else {
      0|      _column = lastMatch[0].length - newlines.last.end;
       |    }
       |
       |    return true;
       |  }
       |
       |  /// Returns a list of [Match]es describing all the newlines in [text], which
       |  /// is assumed to end at [position].
       |  List<Match> _newlinesIn(String text) {
      0|    var newlines = _newlineRegExp.allMatches(text).toList();
      0|    if (_betweenCRLF) newlines.removeLast();
       |    return newlines;
       |  }
       |}
       |
       |/// A class representing the state of an [EagerSpanScanner].
       |class _EagerSpanScannerState implements LineScannerState {
       |  final EagerSpanScanner _scanner;
       |  final int position;
       |  final int line;
       |  final int column;
       |
      0|  _EagerSpanScannerState(this._scanner, this.position, this.line, this.column);
       |}
       |
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.1/lib/src/relative_span_scanner.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'exception.dart';
       |import 'line_scanner.dart';
       |import 'span_scanner.dart';
       |import 'string_scanner.dart';
       |import 'utils.dart';
       |
       |/// A [SpanScanner] that scans within an existing [FileSpan].
       |///
       |/// This re-implements chunks of [SpanScanner] rather than using a dummy span or
       |/// inheritance because scanning is often a performance-critical operation, so
       |/// it's important to avoid adding extra overhead when relative scanning isn't
       |/// needed.
       |class RelativeSpanScanner extends StringScanner implements SpanScanner {
       |  /// The source of the scanner.
       |  ///
       |  /// This caches line break information and is used to generate [Span]s.
       |  final SourceFile _sourceFile;
       |
       |  /// The start location of the span within which this scanner is scanning.
       |  ///
       |  /// This is used to convert between span-relative and file-relative fields.
       |  final FileLocation _startLocation;
       |
      0|  int get line => _sourceFile.getLine(_startLocation.offset + position) -
      0|      _startLocation.line;
       |
       |  int get column {
      0|    var line = _sourceFile.getLine(_startLocation.offset + position);
      0|    var column = _sourceFile.getColumn(_startLocation.offset + position,
       |        line: line);
      0|    return line == _startLocation.line
      0|        ? column - _startLocation.column
       |        : column;
       |  }
       |
      0|  LineScannerState get state => new _SpanScannerState(this, position);
       |
       |  set state(LineScannerState state) {
      0|    if (state is! _SpanScannerState ||
      0|        !identical((state as _SpanScannerState)._scanner, this)) {
      0|      throw new ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    this.position = state.position;
       |  }
       |
      0|  FileSpan get lastSpan => _lastSpan;
       |  FileSpan _lastSpan;
       |
       |  FileLocation get location =>
      0|      _sourceFile.location(_startLocation.offset + position);
       |
      0|  FileSpan get emptySpan => location.pointSpan();
       |
       |  RelativeSpanScanner(FileSpan span)
      0|      : _sourceFile = span.file,
      0|        _startLocation = span.start,
      0|        super(span.text, sourceUrl: span.sourceUrl);
       |
       |  FileSpan spanFrom(LineScannerState startState, [LineScannerState endState]) {
      0|    var endPosition = endState == null ? position : endState.position;
      0|    return _sourceFile.span(
      0|        _startLocation.offset + startState.position,
      0|        _startLocation.offset + endPosition);
       |  }
       |
       |  bool matches(Pattern pattern) {
      0|    if (!super.matches(pattern)) {
      0|      _lastSpan = null;
       |      return false;
       |    }
       |
      0|    _lastSpan = _sourceFile.span(
      0|        _startLocation.offset + position,
      0|        _startLocation.offset + lastMatch.end);
       |    return true;
       |  }
       |
       |  void error(String message, {Match match, int position, int length}) {
      0|    validateErrorArgs(string, match, position, length);
       |
      0|    if (match == null && position == null && length == null) match = lastMatch;
       |    if (position == null) {
      0|      position = match == null ? this.position : match.start;
       |    }
      0|    if (length == null) length = match == null ? 1 : match.end - match.start;
       |
      0|    var span = _sourceFile.span(
      0|        _startLocation.offset + position,
      0|        _startLocation.offset + position + length);
      0|    throw new StringScannerException(message, span, string);
       |  }
       |}
       |
       |/// A class representing the state of a [SpanScanner].
       |class _SpanScannerState implements LineScannerState {
       |  /// The [SpanScanner] that created this.
       |  final RelativeSpanScanner _scanner;
       |
       |  final int position;
      0|  int get line => _scanner._sourceFile.getLine(position);
      0|  int get column => _scanner._sourceFile.getColumn(position);
       |
      0|  _SpanScannerState(this._scanner, this.position);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/async_cache.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |/// Runs asynchronous functions and caches the result for a period of time.
       |///
       |/// This class exists to cover the pattern of having potentially expensive code
       |/// such as file I/O, network access, or isolate computation that's unlikely to
       |/// change quickly run fewer times. For example:
       |///
       |/// ```dart
       |/// final _usersCache = new AsyncCache<List<String>>(const Duration(hours: 1));
       |///
       |/// /// Uses the cache if it exists, otherwise calls the closure:
       |/// Future<List<String>> get onlineUsers => _usersCache.fetch(() {
       |///   // Actually fetch online users here.
       |/// });
       |/// ```
       |///
       |/// This class's timing can be mocked using [`fake_async`][fake_async].
       |///
       |/// [fake_async]: https://pub.dartlang.org/packages/fake_async
       |class AsyncCache<T> {
       |  /// How long cached values stay fresh.
       |  final Duration _duration;
       |
       |  /// Cached results of a previous [fetchStream] call.
       |  StreamSplitter<T> _cachedStreamSplitter;
       |
       |  /// Cached results of a previous [fetch] call.
       |  Future<T> _cachedValueFuture;
       |
       |  /// Fires when the cache should be considered stale.
       |  Timer _stale;
       |
       |  /// Creates a cache that invalidates after an in-flight request is complete.
       |  ///
       |  /// An ephemeral cache guarantees that a callback function will only be
       |  /// executed at most once concurrently. This is useful for requests for which
       |  /// data is updated frequently but stale data is acceptable.
       |  factory AsyncCache.ephemeral() =>
      0|      new AsyncCache(Duration.ZERO);
       |
       |  /// Creates a cache that invalidates its contents after [duration] has passed.
       |  ///
       |  /// The [duration] starts counting after the Future returned by [fetch]
       |  /// completes, or after the Stream returned by [fetchStream] emits a done
       |  /// event.
      0|  AsyncCache(this._duration);
       |
       |  /// Returns a cached value from a previous call to [fetch], or runs [callback]
       |  /// to compute a new one.
       |  ///
       |  /// If [fetch] has been called recently enough, returns its previous return
       |  /// value. Otherwise, runs [callback] and returns its new return value.
       |  Future<T> fetch(Future<T> callback()) async {
      0|    if (_cachedStreamSplitter != null) {
      0|      throw new StateError('Previously used to cache via `fetchStream`');
       |    }
      0|    if (_cachedValueFuture == null) {
      0|      _cachedValueFuture = callback();
      0|      await _cachedValueFuture;
      0|      _startStaleTimer();
       |    }
      0|    return _cachedValueFuture;
       |  }
       |
       |  /// Returns a cached stream from a previous call to [fetchStream], or runs
       |  /// [callback] to compute a new stream.
       |  ///
       |  /// If [fetchStream] has been called recently enough, returns a copy of its
       |  /// previous return value. Otherwise, runs [callback] and returns its new
       |  /// return value.
       |  Stream<T> fetchStream(Stream<T> callback()) {
      0|    if (_cachedValueFuture != null) {
      0|      throw new StateError('Previously used to cache via `fetch`');
       |    }
      0|    if (_cachedStreamSplitter == null) {
      0|      _cachedStreamSplitter = new StreamSplitter(callback()
      0|          .transform(new StreamTransformer.fromHandlers(handleDone: (sink) {
      0|        _startStaleTimer();
      0|        sink.close();
       |      })));
       |    }
      0|    return _cachedStreamSplitter.split();
       |  }
       |
       |  /// Removes any cached value.
       |  void invalidate() {
      0|    _cachedValueFuture = null;
      0|    _cachedStreamSplitter?.close();
      0|    _cachedStreamSplitter = null;
      0|    _stale?.cancel();
      0|    _stale = null;
       |  }
       |
       |  void _startStaleTimer() {
      0|    _stale = new Timer(_duration, invalidate);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/async_memoizer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A class for running an asynchronous function exactly once and caching its
       |/// result.
       |///
       |/// An `AsyncMemoizer` is used when some function may be run multiple times in
       |/// order to get its result, but it only actually needs to be run once for its
       |/// effect. To memoize the result of an async function, you can create a
       |/// memoizer outside the function (for example as an instance field if you want
       |/// to memoize the result of a method), and then wrap the function's body in a
       |/// call to [runOnce].
       |///
       |/// This is useful for methods like `close()` and getters that need to do
       |/// asynchronous work. For example:
       |///
       |/// ```dart
       |/// class SomeResource {
       |///   final _closeMemo = new AsyncMemoizer();
       |///
       |///   Future close() => _closeMemo.runOnce(() {
       |///     // ...
       |///   });
       |/// }
       |/// ```
       |class AsyncMemoizer<T> {
       |  /// The future containing the method's result.
       |  ///
       |  /// This can be accessed at any time, and will fire once [runOnce] is called.
      2|  Future<T> get future => _completer.future;
       |  final _completer = new Completer<T>();
       |
       |  /// Whether [runOnce] has been called yet.
      2|  bool get hasRun => _completer.isCompleted;
       |
       |  /// Runs the function, [computation], if it hasn't been run before.
       |  ///
       |  /// If [runOnce] has already been called, this returns the original result.
       |  Future<T> runOnce(FutureOr<T> computation()) {
      4|    if (!hasRun) _completer.complete(new Future.sync(computation));
      1|    return future;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/byte_collector.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:async";
       |import "dart:typed_data";
       |import "cancelable_operation.dart";
       |
       |/// Collects an asynchronous sequence of byte lists into a single list of bytes.
       |///
       |/// If the [source] stream emits an error event,
       |/// the collection fails and the returned future completes with the same error.
       |///
       |/// If any of the input data are not valid bytes, they will be truncated to
       |/// an eight-bit unsigned value in the resulting list.
       |Future<Uint8List> collectBytes(Stream<List<int>> source) {
      0|  return _collectBytes(source, (_, result) => result);
       |}
       |
       |/// Collects an asynchronous sequence of byte lists into a single list of bytes.
       |///
       |/// Returns a [CancelableOperation] that provides the result future and a way
       |/// to cancel the collection early.
       |///
       |/// If the [source] stream emits an error event,
       |/// the collection fails and the returned future completes with the same error.
       |///
       |/// If any of the input data are not valid bytes, they will be truncated to
       |/// an eight-bit unsigned value in the resulting list.
       |CancelableOperation<Uint8List> collectBytesCancelable(
       |    Stream<List<int>> source) {
      0|  return _collectBytes(source, (subscription, result) =>
      0|      new CancelableOperation.fromFuture(result, onCancel: subscription.cancel)
       |  );
       |}
       |
       |/// Generalization over [collectBytes] and [collectBytesCancelable].
       |///
       |/// Performs all the same operations, but the final result is created
       |/// by the [result] function, which has access to the stream subscription
       |/// so it can cancel the operation.
       |T _collectBytes<T>(
       |    Stream<List<int>> source,
       |    T result(StreamSubscription<List<int>> subscription,
       |        Future<Uint8List> result)) {
      0|  var byteLists = <List<int>>[];
       |  var length = 0;
      0|  var completer = new Completer<Uint8List>.sync();
      0|  var subscription = source.listen(
       |      (bytes) {
      0|        byteLists.add(bytes);
      0|        length += bytes.length;
       |      },
      0|      onError: completer.completeError,
       |      onDone: () {
      0|        completer.complete(_collect(length, byteLists));
       |      },
       |      cancelOnError: true);
      0|  return result(subscription, completer.future);
       |}
       |
       |// Join a lists of bytes with a known total length into a single [Uint8List].
       |Uint8List _collect(int length, List<List<int>> byteLists) {
      0|  var result = new Uint8List(length);
       |  int i = 0;
      0|  for (var byteList in byteLists) {
      0|    var end = i + byteList.length;
      0|    result.setRange(i, end, byteList);
       |    i = end;
       |  }
       |  return result;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/cancelable_operation.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import 'utils.dart';
       |
       |/// An asynchronous operation that can be cancelled.
       |///
       |/// The value of this operation is exposed as [value]. When this operation is
       |/// cancelled, [value] won't complete either successfully or with an error. If
       |/// [value] has already completed, cancelling the operation does nothing.
       |class CancelableOperation<T> {
       |  /// The completer that produced this operation.
       |  ///
       |  /// This is canceled when [cancel] is called.
       |  final CancelableCompleter<T> _completer;
       |
      0|  CancelableOperation._(this._completer);
       |
       |  /// Creates a [CancelableOperation] wrapping [inner].
       |  ///
       |  /// When this operation is canceled, [onCancel] will be called and any value
       |  /// or error produced by [inner] will be discarded. If [onCancel] returns a
       |  /// [Future], it will be forwarded to [cancel].
       |  ///
       |  /// [onCancel] will be called synchronously when the operation is canceled.
       |  /// It's guaranteed to only be called once.
       |  factory CancelableOperation.fromFuture(Future<T> inner,
       |      {FutureOr onCancel()}) {
      0|    var completer = new CancelableCompleter<T>(onCancel: onCancel);
      0|    completer.complete(inner);
      0|    return completer.operation;
       |  }
       |
       |  /// The value returned by the operation.
      0|  Future<T> get value => _completer._inner.future;
       |
       |  /// Creates a [Stream] containing the result of this operation.
       |  ///
       |  /// This is like `value.asStream()`, but if a subscription to the stream is
       |  /// canceled, this is as well.
       |  Stream<T> asStream() {
      0|    var controller = new StreamController<T>(
      0|        sync: true, onCancel: _completer._cancel);
       |
      0|    value.then((value) {
      0|      controller.add(value);
      0|      controller.close();
       |    }, onError: (error, stackTrace) {
      0|      controller.addError(error, stackTrace);
      0|      controller.close();
       |    });
      0|    return controller.stream;
       |  }
       |
       |  /// Creates a [Future] that completes when this operation completes *or* when
       |  /// it's cancelled.
       |  ///
       |  /// If this operation completes, this completes to the same result as [value].
       |  /// If this operation is cancelled, the returned future waits for the future
       |  /// returned by [cancel], then completes to [cancellationValue].
       |  Future valueOrCancellation([T cancellationValue]) {
      0|    var completer = new Completer<T>.sync();
      0|    value.then((result) => completer.complete(result),
      0|        onError: completer.completeError);
       |
      0|    _completer._cancelMemo.future.then((_) {
      0|      completer.complete(cancellationValue);
      0|    }, onError: completer.completeError);
       |
      0|    return completer.future;
       |  }
       |
       |  /// Cancels this operation.
       |  ///
       |  /// This returns the [Future] returned by the [CancelableCompleter]'s
       |  /// `onCancel` callback. Unlike [Stream.cancel], it never returns `null`.
      0|  Future cancel() => _completer._cancel();
       |}
       |
       |/// A completer for a [CancelableOperation].
       |class CancelableCompleter<T> {
       |  /// The completer for the wrapped future.
       |  final Completer<T> _inner;
       |
       |  /// The callback to call if the future is canceled.
       |  final FutureOrCallback _onCancel;
       |
       |  /// Creates a new completer for a [CancelableOperation].
       |  ///
       |  /// When the future operation canceled, as long as the completer hasn't yet
       |  /// completed, [onCancel] is called. If [onCancel] returns a [Future], it's
       |  /// forwarded to [CancelableOperation.cancel].
       |  ///
       |  /// [onCancel] will be called synchronously when the operation is canceled.
       |  /// It's guaranteed to only be called once.
       |  CancelableCompleter({FutureOr onCancel()})
       |      : _onCancel = onCancel,
      0|        _inner = new Completer<T>() {
      0|    _operation = new CancelableOperation<T>._(this);
       |  }
       |
       |  /// The operation controlled by this completer.
      0|  CancelableOperation<T> get operation => _operation;
       |  CancelableOperation<T> _operation;
       |
       |  /// Whether the completer has completed.
      0|  bool get isCompleted => _isCompleted;
       |  bool _isCompleted = false;
       |
       |  /// Whether the completer was canceled before being completed.
      0|  bool get isCanceled => _isCanceled;
       |  bool _isCanceled = false;
       |
       |  /// The memoizer for [_cancel].
       |  final _cancelMemo = new AsyncMemoizer();
       |
       |  /// Completes [operation] to [value].
       |  ///
       |  /// If [value] is a [Future], this will complete to the result of that
       |  /// [Future] once it completes.
       |  void complete([value]) {
      0|    if (_isCompleted) throw new StateError("Operation already completed");
      0|    _isCompleted = true;
       |
      0|    if (value is! Future) {
      0|      if (_isCanceled) return;
      0|      _inner.complete(value);
       |      return;
       |    }
       |
      0|    if (_isCanceled) {
       |      // Make sure errors from [value] aren't top-leveled.
      0|      value.catchError((_) {});
       |      return;
       |    }
       |
      0|    value.then((result) {
      0|      if (_isCanceled) return;
      0|      _inner.complete(result);
       |    }, onError: (error, stackTrace) {
      0|      if (_isCanceled) return;
      0|      _inner.completeError(error, stackTrace);
       |    });
       |  }
       |
       |  /// Completes [operation] to [error].
       |  void completeError(Object error, [StackTrace stackTrace]) {
      0|    if (_isCompleted) throw new StateError("Operation already completed");
      0|    _isCompleted = true;
       |
      0|    if (_isCanceled) return;
      0|    _inner.completeError(error, stackTrace);
       |  }
       |
       |  /// Cancel the completer.
       |  Future _cancel() {
      0|    if (_inner.isCompleted) return new Future.value();
       |
      0|    return _cancelMemo.runOnce(() {
      0|      _isCanceled = true;
      0|      if (_onCancel != null) return _onCancel();
       |    });
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/delegate/event_sink.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Simple delegating wrapper around an [EventSink].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [EventSink] methods of a subclass.
       |class DelegatingEventSink<T> implements EventSink<T> {
       |  final EventSink _sink;
       |
       |  /// Create a delegating sink forwarding calls to [sink].
      0|  DelegatingEventSink(EventSink<T> sink) : _sink = sink;
       |
      0|  DelegatingEventSink._(this._sink);
       |
       |  /// Creates a wrapper that coerces the type of [sink].
       |  ///
       |  /// Unlike [new DelegatingEventSink], this only requires its argument to be an
       |  /// instance of `EventSink`, not `EventSink<T>`. This means that calls to
       |  /// [add] may throw a [CastError] if the argument type doesn't match the
       |  /// reified type of [sink].
       |  static EventSink<T> typed<T>(EventSink sink) =>
      0|      sink is EventSink<T> ? sink : new DelegatingEventSink._(sink);
       |
       |  void add(T data) {
      0|    _sink.add(data);
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _sink.addError(error, stackTrace);
       |  }
       |
       |  void close() {
      0|    _sink.close();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/delegate/future.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../typed/future.dart';
       |
       |/// A wrapper that forwards calls to a [Future].
       |class DelegatingFuture<T> implements Future<T> {
       |  /// The wrapped [Future].
       |  final Future<T> _future;
       |
      0|  DelegatingFuture(this._future);
       |
       |  /// Creates a wrapper which throws if [future]'s value isn't an instance of
       |  /// `T`.
       |  ///
       |  /// This soundly converts a [Future] to a `Future<T>`, regardless of its
       |  /// original generic type, by asserting that its value is an instance of `T`
       |  /// whenever it's provided. If it's not, the future throws a [CastError].
       |  static Future<T> typed<T>(Future future) =>
      0|      future is Future<T> ? future : new TypeSafeFuture<T>(future);
       |
      0|  Stream<T> asStream() => _future.asStream();
       |
       |  Future<T> catchError(Function onError, {bool test(Object error)}) =>
      0|    _future.catchError(onError, test: test);
       |
       |  Future<S> then<S>(FutureOr<S> onValue(T value), {Function onError}) =>
      0|    _future.then(onValue, onError: onError);
       |
      0|  Future<T> whenComplete(action()) => _future.whenComplete(action);
       |
       |  Future<T> timeout(Duration timeLimit, {onTimeout()}) =>
      0|    _future.timeout(timeLimit, onTimeout: onTimeout);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/delegate/sink.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Simple delegating wrapper around a [Sink].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [Sink] methods of a subclass.
       |class DelegatingSink<T> implements Sink<T> {
       |  final Sink _sink;
       |
       |  /// Create a delegating sink forwarding calls to [sink].
      1|  DelegatingSink(Sink<T> sink) : _sink = sink;
       |
      0|  DelegatingSink._(this._sink);
       |
       |  /// Creates a wrapper that coerces the type of [sink].
       |  ///
       |  /// Unlike [new DelegatingSink], this only requires its argument to be an
       |  /// instance of `Sink`, not `Sink<T>`. This means that calls to [add] may
       |  /// throw a [CastError] if the argument type doesn't match the reified type of
       |  /// [sink].
       |  static Sink<T> typed<T>(Sink sink) =>
      0|      sink is Sink<T> ? sink : new DelegatingSink._(sink);
       |
       |  void add(T data) {
      2|    _sink.add(data);
       |  }
       |
       |  void close() {
      2|    _sink.close();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/delegate/stream.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../typed/stream.dart';
       |
       |/// Simple delegating wrapper around a [Stream].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [Stream] methods of a subclass.
       |///
       |/// Note that this is identical to [StreamView] in `dart:async`. It's provided
       |/// under this name for consistency with other `Delegating*` classes.
       |class DelegatingStream<T> extends StreamView<T> {
      0|  DelegatingStream(Stream<T> stream) : super(stream);
       |
       |  /// Creates a wrapper which throws if [stream]'s events aren't instances of
       |  /// `T`.
       |  ///
       |  /// This soundly converts a [Stream] to a `Stream<T>`, regardless of its
       |  /// original generic type, by asserting that its events are instances of `T`
       |  /// whenever they're provided. If they're not, the stream throws a
       |  /// [CastError].
       |  static Stream<T> typed<T>(Stream stream) =>
      0|      stream is Stream<T> ? stream : new TypeSafeStream<T>(stream);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/delegate/stream_consumer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Simple delegating wrapper around a [StreamConsumer].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [StreamConsumer] methods of a subclass.
       |class DelegatingStreamConsumer<T> implements StreamConsumer<T> {
       |  final StreamConsumer _consumer;
       |
       |  /// Create a delegating consumer forwarding calls to [consumer].
      0|  DelegatingStreamConsumer(StreamConsumer<T> consumer) : _consumer = consumer;
       |
      0|  DelegatingStreamConsumer._(this._consumer);
       |
       |  /// Creates a wrapper that coerces the type of [consumer].
       |  ///
       |  /// Unlike [new StreamConsumer], this only requires its argument to be an
       |  /// instance of `StreamConsumer`, not `StreamConsumer<T>`. This means that
       |  /// calls to [addStream] may throw a [CastError] if the argument type doesn't
       |  /// match the reified type of [consumer].
       |  static StreamConsumer<T> typed<T>(StreamConsumer consumer) =>
      0|      consumer is StreamConsumer<T>
       |          ? consumer
      0|          : new DelegatingStreamConsumer._(consumer);
       |
      0|  Future addStream(Stream<T> stream) => _consumer.addStream(stream);
       |
      0|  Future close() => _consumer.close();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/delegate/stream_sink.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Simple delegating wrapper around a [StreamSink].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [StreamSink] methods of a subclass.
       |class DelegatingStreamSink<T> implements StreamSink<T> {
       |  final StreamSink _sink;
       |
      0|  Future get done => _sink.done;
       |
       |  /// Create delegating sink forwarding calls to [sink].
      0|  DelegatingStreamSink(StreamSink<T> sink) : _sink = sink;
       |
      0|  DelegatingStreamSink._(this._sink);
       |
       |  /// Creates a wrapper that coerces the type of [sink].
       |  ///
       |  /// Unlike [new StreamSink], this only requires its argument to be an instance
       |  /// of `StreamSink`, not `StreamSink<T>`. This means that calls to [add] may
       |  /// throw a [CastError] if the argument type doesn't match the reified type of
       |  /// [sink].
       |  static StreamSink<T> typed<T>(StreamSink sink) =>
      0|      sink is StreamSink<T> ? sink : new DelegatingStreamSink._(sink);
       |
       |  void add(T data) {
      0|    _sink.add(data);
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _sink.addError(error, stackTrace);
       |  }
       |
      0|  Future addStream(Stream<T> stream) => _sink.addStream(stream);
       |
      0|  Future close() => _sink.close();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/delegate/stream_subscription.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../typed/stream_subscription.dart';
       |
       |/// Simple delegating wrapper around a [StreamSubscription].
       |///
       |/// Subclasses can override individual methods.
       |class DelegatingStreamSubscription<T> implements StreamSubscription<T> {
       |  final StreamSubscription _source;
       |
       |  /// Create delegating subscription forwarding calls to [sourceSubscription].
       |  DelegatingStreamSubscription(StreamSubscription<T> sourceSubscription)
      0|      : _source = sourceSubscription;
       |
       |  /// Creates a wrapper which throws if [subscription]'s events aren't instances
       |  /// of `T`.
       |  ///
       |  /// This soundly converts a [StreamSubscription] to a `StreamSubscription<T>`,
       |  /// regardless of its original generic type, by asserting that its events are
       |  /// instances of `T` whenever they're provided. If they're not, the
       |  /// subscription throws a [CastError].
       |  static StreamSubscription<T> typed<T>(
       |          StreamSubscription subscription) =>
      0|      subscription is StreamSubscription<T>
       |          ? subscription
      0|          : new TypeSafeStreamSubscription<T>(subscription);
       |
       |  void onData(void handleData(T data)) {
      0|    _source.onData(handleData);
       |  }
       |
       |  void onError(Function handleError) {
      0|    _source.onError(handleError);
       |  }
       |
       |  void onDone(void handleDone()) {
      0|    _source.onDone(handleDone);
       |  }
       |
       |  void pause([Future resumeFuture]) {
      0|    _source.pause(resumeFuture);
       |  }
       |
       |  void resume() {
      0|    _source.resume();
       |  }
       |
      0|  Future cancel() => _source.cancel();
       |
       |  Future<E> asFuture<E>([E futureValue]) =>
      0|      _source.asFuture(futureValue);
       |
      0|  bool get isPaused => _source.isPaused;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/future_group.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A collection of futures waits until all added [Future]s complete.
       |///
       |/// Futures are added to the group with [add]. Once you're finished adding
       |/// futures, signal that by calling [close]. Then, once all added futures have
       |/// completed, [future] will complete with a list of values from the futures in
       |/// the group, in the order they were added.
       |///
       |/// If any added future completes with an error, [future] will emit that error
       |/// and the group will be closed, regardless of the state of other futures in
       |/// the group.
       |///
       |/// This is similar to [Future.wait] with `eagerError` set to `true`, except
       |/// that a [FutureGroup] can have futures added gradually over time rather than
       |/// needing them all at once.
       |class FutureGroup<T> implements Sink<Future<T>> {
       |  /// The number of futures that have yet to complete.
       |  var _pending = 0;
       |
       |  /// Whether [close] has been called.
       |  var _closed = false;
       |
       |  /// The future that fires once [close] has been called and all futures in the
       |  /// group have completed.
       |  ///
       |  /// This will also complete with an error if any of the futures in the group
       |  /// fails, regardless of whether [close] was called.
      2|  Future<List<T>> get future => _completer.future;
       |  final _completer = new Completer<List<T>>();
       |
       |  /// Whether this group has no pending futures.
      0|  bool get isIdle => _pending == 0;
       |
       |  /// A broadcast stream that emits a `null` event whenever the last pending
       |  /// future in this group completes.
       |  ///
       |  /// Once this group isn't waiting on any futures *and* [close] has been
       |  /// called, this stream will close.
       |  Stream get onIdle {
      0|    if (_onIdleController == null) {
      0|      _onIdleController = new StreamController.broadcast(sync: true);
       |    }
      0|    return _onIdleController.stream;
       |  }
       |  StreamController _onIdleController;
       |
       |  /// The values emitted by the futures that have been added to the group, in
       |  /// the order they were added.
       |  ///
       |  /// The slots for futures that haven't completed yet are `null`.
       |  final _values = new List<T>();
       |
       |  /// Wait for [task] to complete.
       |  void add(Future<T> task) {
      1|    if (_closed) throw new StateError("The FutureGroup is closed.");
       |
       |    // Ensure that future values are put into [values] in the same order they're
       |    // added to the group by pre-allocating a slot for them and recording its
       |    // index.
      2|    var index = _values.length;
      2|    _values.add(null);
       |
      2|    _pending++;
      1|    task.then((value) {
      2|      if (_completer.isCompleted) return null;
       |
      2|      _pending--;
      2|      _values[index] = value;
       |
      2|      if (_pending != 0) return null;
      1|      if (_onIdleController != null) _onIdleController.add(null);
       |
      1|      if (!_closed) return null;
      1|      if (_onIdleController != null) _onIdleController.close();
      3|      _completer.complete(_values);
      1|    }).catchError((error, stackTrace) {
      0|      if (_completer.isCompleted) return null;
      0|      _completer.completeError(error, stackTrace);
       |    });
       |  }
       |
       |  /// Signals to the group that the caller is done adding futures, and so
       |  /// [future] should fire once all added futures have completed.
       |  void close() {
      1|    _closed = true;
      2|    if (_pending != 0) return;
      2|    if (_completer.isCompleted) return;
      3|    _completer.complete(_values);
       |  }
       |}
       |
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/lazy_stream.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:async";
       |
       |import "delegate/stream.dart";
       |import "stream_completer.dart";
       |import "utils.dart";
       |
       |/// A [Stream] wrapper that forwards to another [Stream] that's initialized
       |/// lazily.
       |///
       |/// This class allows a concrete `Stream` to be created only once it has a
       |/// listener. It's useful to wrapping APIs that do expensive computation to
       |/// produce a `Stream`.
       |class LazyStream<T> extends Stream<T> {
       |  /// The callback that's called to create the inner stream.
       |  FutureOrCallback<Stream<T>> _callback;
       |
       |  /// Creates a single-subscription `Stream` that calls [callback] when it gets
       |  /// a listener and forwards to the returned stream.
      0|  LazyStream(FutureOr<Stream<T>> callback()) : _callback = callback {
       |    // Explicitly check for null because we null out [_callback] internally.
      0|    if (_callback == null) throw new ArgumentError.notNull('callback');
       |  }
       |
       |  StreamSubscription<T> listen(void onData(T event),
       |                               {Function onError,
       |                                void onDone(),
       |                                bool cancelOnError}) {
      0|    if (_callback == null) {
      0|      throw new StateError("Stream has already been listened to.");
       |    }
       |
       |    // Null out the callback before we invoke it to ensure that even while
       |    // running it, this can't be called twice.
      0|    var callback = _callback;
      0|    _callback = null;
      0|    var result = callback();
       |
       |    Stream<T> stream;
      0|    if (result is Future<Stream<T>>) {
      0|      stream = StreamCompleter.fromFuture(result.then((stream) {
      0|        return DelegatingStream.typed<T>(stream);
       |      }));
       |    } else {
      0|      stream = DelegatingStream.typed<T>(result as Stream);
       |    }
       |
      0|    return stream.listen(onData,
       |        onError: onError, onDone: onDone, cancelOnError: cancelOnError);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/null_stream_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A [StreamSink] that discards all events.
       |///
       |/// The sink silently drops events until [close] is called, at which point it
       |/// throws [StateError]s when events are added. This is the same behavior as a
       |/// sink whose remote end has closed, such as when a [WebSocket] connection has
       |/// been closed.
       |///
       |/// This can be used when a sink is needed but no events are actually intended
       |/// to be added. The [new NullStreamSink.error] constructor can be used to
       |/// represent errors when creating a sink, since [StreamSink.done] exposes sink
       |/// errors. For example:
       |///
       |/// ```dart
       |/// StreamSink<List<int>> openForWrite(String filename) {
       |///   try {
       |///     return new RandomAccessSink(new File(filename).openSync());
       |///   } on IOException catch (error, stackTrace) {
       |///     return new NullStreamSink.error(error, stackTrace);
       |///   }
       |/// }
       |/// ```
       |class NullStreamSink<T> implements StreamSink<T> {
       |  final Future done;
       |
       |  /// Whether the sink has been closed.
       |  var _closed = false;
       |
       |  /// Whether an [addStream] call is pending.
       |  ///
       |  /// We don't actually add any events from streams, but it does return the
       |  /// [StreamSubscription.cancel] future so to be [StreamSink]-complaint we
       |  /// reject events until that completes.
       |  var _addingStream = false;
       |
       |  /// Creates a null sink.
       |  ///
       |  /// If [done] is passed, it's used as the [Sink.done] future. Otherwise, a
       |  /// completed future is used.
      0|  NullStreamSink({Future done}) : done = done ?? new Future.value();
       |
       |  /// Creates a null sink whose [done] future emits [error].
       |  ///
       |  /// Note that this error will not be considered uncaught.
       |  NullStreamSink.error(error, [StackTrace stackTrace])
      0|      : done = new Future.error(error, stackTrace)
       |          // Don't top-level the error. This gives the user a change to call
       |          // [close] or [done], and matches the behavior of a remote endpoint
       |          // experiencing an error.
      0|          ..catchError((_) {});
       |
       |  void add(T data) {
      0|    _checkEventAllowed();
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _checkEventAllowed();
       |  }
       |
       |  Future addStream(Stream<T> stream) {
      0|    _checkEventAllowed();
       |
      0|    _addingStream = true;
      0|    var future = stream.listen(null).cancel() ?? new Future.value();
      0|    return future.whenComplete(() {
      0|      _addingStream = false;
       |    });
       |  }
       |
       |  /// Throws a [StateError] if [close] has been called or an [addStream] call is
       |  /// pending.
       |  void _checkEventAllowed() {
      0|    if (_closed) throw new StateError("Cannot add to a closed sink.");
      0|    if (_addingStream) {
      0|      throw new StateError("Cannot add to a sink while adding a stream.");
       |    }
       |  }
       |
       |  Future close() {
      0|    _closed = true;
      0|    return done;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/restartable_timer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A non-periodic timer that can be restarted any number of times.
       |///
       |/// Once restarted (via [reset]), the timer counts down from its original
       |/// duration again.
       |class RestartableTimer implements Timer {
       |  /// The duration of the timer.
       |  final Duration _duration;
       |
       |  /// The callback to call when the timer fires.
       |  final ZoneCallback _callback;
       |
       |  /// The timer for the current or most recent countdown.
       |  ///
       |  /// This timer is canceled and overwritten every time this [RestartableTimer]
       |  /// is reset.
       |  Timer _timer;
       |
       |  /// Creates a new timer.
       |  ///
       |  /// The [callback] function is invoked after the given [duration]. Unlike a
       |  /// normal non-periodic [Timer], [callback] may be called more than once.
      0|  RestartableTimer(this._duration, this._callback) {
      0|    _timer = new Timer(_duration, _callback);
       |  }
       |
      0|  bool get isActive => _timer.isActive;
       |
       |  /// Restarts the timer so that it counts down from its original duration
       |  /// again.
       |  ///
       |  /// This restarts the timer even if it has already fired or has been canceled.
       |  void reset() {
      0|    _timer.cancel();
      0|    _timer = new Timer(_duration, _callback);
       |  }
       |
       |  void cancel() {
      0|    _timer.cancel();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'result/capture_transformer.dart';
       |import 'result/error.dart';
       |import 'result/release_transformer.dart';
       |import 'result/value.dart';
       |import 'stream_sink_transformer.dart';
       |
       |/// The result of a computation.
       |///
       |/// Capturing a result (either a returned value or a thrown error) means
       |/// converting it into a [Result] - either a [ValueResult] or an [ErrorResult].
       |///
       |/// This value can release itself by writing itself either to a [EventSink] or a
       |/// [Completer], or by becoming a [Future].
       |abstract class Result<T> {
       |  /// A stream transformer that captures a stream of events into [Result]s.
       |  ///
       |  /// The result of the transformation is a stream of [Result] values and no
       |  /// error events. This is the transformer used by [captureStream].
       |  static const StreamTransformer<Object, Result> captureStreamTransformer =
       |      const CaptureStreamTransformer();
       |
       |  /// A stream transformer that releases a stream of result events.
       |  ///
       |  /// The result of the transformation is a stream of values and error events.
       |  /// This is the transformer used by [releaseStream].
       |  static const StreamTransformer<Object, Result> releaseStreamTransformer =
       |      const ReleaseStreamTransformer();
       |
       |  /// A sink transformer that captures events into [Result]s.
       |  ///
       |  /// The result of the transformation is a sink that only forwards [Result]
       |  /// values and no error events.
       |  static const StreamSinkTransformer<Object, Result> captureSinkTransformer =
       |      const StreamSinkTransformer.fromStreamTransformer(
       |          const CaptureStreamTransformer());
       |
       |  /// A sink transformer that releases result events.
       |  ///
       |  /// The result of the transformation is a sink that forwards of values and
       |  /// error events.
       |  static const StreamSinkTransformer<Object, Result> releaseSinkTransformer =
       |      const StreamSinkTransformer.fromStreamTransformer(
       |          const ReleaseStreamTransformer());
       |
       |  /// Create a `Result` with the result of calling [computation].
       |  ///
       |  /// This generates either a [ValueResult] with the value returned by
       |  /// calling `computation`, or an [ErrorResult] with an error thrown by
       |  /// the call.
       |  factory Result(T computation()) {
       |    try {
      0|      return new ValueResult(computation());
       |    } catch (e, s) {
      0|      return new ErrorResult(e, s);
       |    }
       |  }
       |
       |  /// Create a `Result` holding a value.
       |  ///
       |  /// Alias for [ValueResult.ValueResult].
       |  factory Result.value(T value) = ValueResult<T>;
       |
       |  /// Create a `Result` holding an error.
       |  ///
       |  /// Alias for [ErrorResult.ErrorResult].
       |  factory Result.error(Object error, [StackTrace stackTrace]) =>
      0|      new ErrorResult(error, stackTrace);
       |
       |  /// Capture the result of a future into a `Result` future.
       |  ///
       |  /// The resulting future will never have an error.
       |  /// Errors have been converted to an [ErrorResult] value.
       |  static Future<Result<T>> capture<T>(Future<T> future) {
      0|    return future.then((value) => new ValueResult(value),
       |        onError: (error, stackTrace) =>
      0|            new ErrorResult<T>(error, stackTrace));
       |  }
       |
       |  /// Release the result of a captured future.
       |  ///
       |  /// Converts the [Result] value of the given [future] to a value or error
       |  /// completion of the returned future.
       |  ///
       |  /// If [future] completes with an error, the returned future completes with
       |  /// the same error.
       |  static Future<T> release<T>(Future<Result<T>> future) =>
      0|      future.then<T>((result) => result.asFuture);
       |
       |  /// Capture the results of a stream into a stream of [Result] values.
       |  ///
       |  /// The returned stream will not have any error events.
       |  /// Errors from the source stream have been converted to [ErrorResult]s.
       |  static Stream<Result<T>> captureStream<T>(Stream<T> source) =>
      0|      source.transform(new CaptureStreamTransformer<T>());
       |
       |  /// Release a stream of [result] values into a stream of the results.
       |  ///
       |  /// `Result` values of the source stream become value or error events in
       |  /// the returned stream as appropriate.
       |  /// Errors from the source stream become errors in the returned stream.
       |  static Stream<T> releaseStream<T>(Stream<Result<T>> source) =>
      0|      source.transform(new ReleaseStreamTransformer<T>());
       |
       |  /// Converts a result of a result to a single result.
       |  ///
       |  /// If the result is an error, or it is a `Result` value
       |  /// which is then an error, then a result with that error is returned.
       |  /// Otherwise both levels of results are value results, and a single
       |  /// result with the value is returned.
       |  static Result<T> flatten<T>(Result<Result<T>> result) {
      0|    if (result.isValue) return result.asValue.value;
      0|    return new ErrorResult<T>(
      0|        result.asError.error, result.asError.stackTrace);
       |  }
       |
       |  /// Whether this result is a value result.
       |  ///
       |  /// Always the opposite of [isError].
       |  bool get isValue;
       |
       |  /// Whether this result is an error result.
       |  ///
       |  /// Always the opposite of [isValue].
       |  bool get isError;
       |
       |  /// If this is a value result, return itself.
       |  ///
       |  /// Otherwise return `null`.
       |  ValueResult<T> get asValue;
       |
       |  /// If this is an error result, return itself.
       |  ///
       |  /// Otherwise return `null`.
       |  ErrorResult<T> get asError;
       |
       |  /// Complete a completer with this result.
       |  void complete(Completer<T> completer);
       |
       |  /// Add this result to an [EventSink].
       |  ///
       |  /// Calls the sink's `add` or `addError` method as appropriate.
       |  void addTo(EventSink<T> sink);
       |
       |  /// Creates a future completed with this result as a value or an error.
       |  Future<T> get asFuture;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result/capture_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../result.dart';
       |import 'capture_sink.dart';
       |
       |/// A stream transformer that captures a stream of events into [Result]s.
       |///
       |/// The result of the transformation is a stream of [Result] values and no
       |/// error events. This is the transformer used by [captureStream].
       |@Deprecated("Will be removed in async 2.0.0.")
       |class CaptureStreamTransformer<T> implements StreamTransformer<T, Result<T>> {
      1|  const CaptureStreamTransformer();
       |
       |  Stream<Result<T>> bind(Stream<T> source) {
      0|    return new Stream<Result<T>>.eventTransformed(source, _createSink);
       |  }
       |
       |  static EventSink _createSink(EventSink<Result> sink) {
      0|    return new CaptureSink(sink);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result/error.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../result.dart';
       |import 'value.dart';
       |
       |/// A result representing a thrown error.
       |class ErrorResult<T> implements Result<T> {
       |  final error;
       |  final StackTrace stackTrace;
       |
       |  bool get isValue => false;
       |  bool get isError => true;
       |  ValueResult<T> get asValue => null;
       |  ErrorResult<T> get asError => this;
       |
      0|  ErrorResult(this.error, this.stackTrace);
       |
       |  void complete(Completer completer) {
      0|    completer.completeError(error, stackTrace);
       |  }
       |
       |  void addTo(EventSink sink) {
      0|    sink.addError(error, stackTrace);
       |  }
       |
      0|  Future<T> get asFuture => new Future.error(error, stackTrace);
       |
       |  /// Calls an error handler with the error and stacktrace.
       |  ///
       |  /// An async error handler function is either a function expecting two
       |  /// arguments, which will be called with the error and the stack trace, or it
       |  /// has to be a function expecting only one argument, which will be called
       |  /// with only the error.
       |  void handle(Function errorHandler) {
      0|    if (errorHandler is ZoneBinaryCallback) {
      0|      errorHandler(error, stackTrace);
       |    } else {
      0|      errorHandler(error);
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result/future.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../delegate/future.dart';
       |import '../result.dart';
       |
       |/// A [Future] wrapper that provides synchronous access to the result of the
       |/// wrapped [Future] once it's completed.
       |class ResultFuture<T> extends DelegatingFuture<T> {
       |  /// Whether the future has fired and [result] is available.
      0|  bool get isComplete => result != null;
       |
       |  /// The result of the wrapped [Future], if it's completed.
       |  ///
       |  /// If it hasn't completed yet, this will be `null`.
      0|  Result<T> get result => _result;
       |  Result<T> _result;
       |
       |  factory ResultFuture(Future<T> future) {
       |    ResultFuture<T> resultFuture;
      0|    resultFuture = new ResultFuture._(() async {
      0|      var result = await Result.capture(future);
      0|      resultFuture._result = result;
      0|      return await result.asFuture;
      0|    }());
       |    return resultFuture;
       |  }
       |
       |  ResultFuture._(Future<T> future)
      0|      : super(future);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result/release_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../result.dart';
       |import 'release_sink.dart';
       |
       |/// Use [Result.releaseTransformer] instead.
       |@Deprecated("Will be removed in async 2.0.0.")
       |class ReleaseStreamTransformer<T> implements StreamTransformer<Result<T>, T> {
      0|  const ReleaseStreamTransformer();
       |
       |  Stream<T> bind(Stream<Result<T>> source) {
      0|    return new Stream<T>.eventTransformed(source, _createSink);
       |  }
       |
       |  static EventSink<Result> _createSink(EventSink sink) {
      0|    return new ReleaseSink(sink);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result/value.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../result.dart';
       |import 'error.dart';
       |
       |/// A result representing a returned value.
       |class ValueResult<T> implements Result<T> {
       |  final T value;
       |
       |  bool get isValue => true;
       |  bool get isError => false;
       |  ValueResult<T> get asValue => this;
       |  ErrorResult<T> get asError => null;
       |
      0|  ValueResult(this.value);
       |
       |  void complete(Completer<T> completer) {
      0|    completer.complete(value);
       |  }
       |
       |  void addTo(EventSink<T> sink) {
      0|    sink.add(value);
       |  }
       |
      0|  Future<T> get asFuture => new Future.value(value);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/single_subscription_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A transformer that converts a broadcast stream into a single-subscription
       |/// stream.
       |///
       |/// This buffers the broadcast stream's events, which means that it starts
       |/// listening to a stream as soon as it's bound.
       |///
       |/// This also casts the source stream's events to type `T`. If the cast fails,
       |/// the result stream will emit a [CastError]. This behavior is deprecated, and
       |/// should not be relied upon.
       |class SingleSubscriptionTransformer<S, T> implements StreamTransformer<S, T> {
      0|  const SingleSubscriptionTransformer();
       |
       |  Stream<T> bind(Stream<S> stream) {
       |    var subscription;
      0|    var controller = new StreamController<T>(sync: true,
      0|        onCancel: () => subscription.cancel());
      0|    subscription = stream.listen((value) {
       |      // TODO(nweiz): When we release a new major version, get rid of the second
       |      // type parameter and avoid this conversion.
       |      try {
      0|        controller.add(value as T);
      0|      } on CastError catch (error, stackTrace) {
      0|        controller.addError(error, stackTrace);
       |      }
      0|    }, onError: controller.addError, onDone: controller.close);
      0|    return controller.stream;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_completer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:async";
       |
       |/// A single-subscription [stream] where the contents are provided later.
       |///
       |/// It is generally recommended that you never create a `Future<Stream>`
       |/// because you can just directly create a stream that doesn't do anything
       |/// until it's ready to do so.
       |/// This class can be used to create such a stream.
       |///
       |/// The [stream] is a normal stream that you can listen to immediately,
       |/// but until either [setSourceStream] or [setEmpty] is called,
       |/// the stream won't produce any events.
       |///
       |/// The same effect can be achieved by using a [StreamController]
       |/// and adding the stream using `addStream` when both
       |/// the controller's stream is listened to and the source stream is ready.
       |/// This class attempts to shortcut some of the overhead when possible.
       |/// For example, if the [stream] is only listened to
       |/// after the source stream has been set,
       |/// the listen is performed directly on the source stream.
       |class StreamCompleter<T> {
       |  /// The stream doing the actual work, is returned by [stream].
       |  final _stream = new _CompleterStream<T>();
       |
       |  /// Convert a `Future<Stream>` to a `Stream`.
       |  ///
       |  /// This creates a stream using a stream completer,
       |  /// and sets the source stream to the result of the future when the
       |  /// future completes.
       |  ///
       |  /// If the future completes with an error, the returned stream will
       |  /// instead contain just that error.
       |  static Stream<T> fromFuture<T>(Future<Stream<T>> streamFuture) {
      0|    var completer = new StreamCompleter<T>();
      0|    streamFuture.then(completer.setSourceStream,
      0|        onError: completer.setError);
      0|    return completer.stream;
       |  }
       |
       |  /// The stream of this completer.
       |  ///
       |  /// This stream is always a single-subscription stream.
       |  ///
       |  /// When a source stream is provided, its events will be forwarded to
       |  /// listeners on this stream.
       |  ///
       |  /// The stream can be listened either before or after a source stream
       |  /// is set.
      0|  Stream<T> get stream => _stream;
       |
       |  /// Set a stream as the source of events for the [StreamCompleter]'s
       |  /// [stream].
       |  ///
       |  /// The completer's `stream` will act exactly as [sourceStream].
       |  ///
       |  /// If the source stream is set before [stream] is listened to,
       |  /// the listen call on [stream] is forwarded directly to [sourceStream].
       |  ///
       |  /// If [stream] is listened to before setting the source stream,
       |  /// an intermediate subscription is created. It looks like a completely
       |  /// normal subscription, and can be paused or canceled, but it won't
       |  /// produce any events until a source stream is provided.
       |  ///
       |  /// If the `stream` subscription is canceled before a source stream is set,
       |  /// the source stream will be listened to and immediately canceled again.
       |  ///
       |  /// Otherwise, when the source stream is then set,
       |  /// it is immediately listened to, and its events are forwarded to the
       |  /// existing subscription.
       |  ///
       |  /// Any one of [setSourceStream], [setEmpty], and [setError] may be called at
       |  /// most once. Trying to call any of them again will fail.
       |  void setSourceStream(Stream<T> sourceStream) {
      0|    if (_stream._isSourceStreamSet) {
      0|      throw new StateError("Source stream already set");
       |    }
      0|    _stream._setSourceStream(sourceStream);
       |  }
       |
       |  /// Equivalent to setting an empty stream using [setSourceStream].
       |  ///
       |  /// Any one of [setSourceStream], [setEmpty], and [setError] may be called at
       |  /// most once. Trying to call any of them again will fail.
       |  void setEmpty() {
      0|    if (_stream._isSourceStreamSet) {
      0|      throw new StateError("Source stream already set");
       |    }
      0|    _stream._setEmpty();
       |  }
       |
       |  /// Completes this to a stream that emits [error] and then closes.
       |  ///
       |  /// This is useful when the process of creating the data for the stream fails.
       |  ///
       |  /// Any one of [setSourceStream], [setEmpty], and [setError] may be called at
       |  /// most once. Trying to call any of them again will fail.
       |  void setError(error, [StackTrace stackTrace]) {
      0|    setSourceStream(new Stream.fromFuture(new Future.error(error, stackTrace)));
       |  }
       |}
       |
       |/// Stream completed by [StreamCompleter].
       |class _CompleterStream<T> extends Stream<T> {
       |  /// Controller for an intermediate stream.
       |  ///
       |  /// Created if the user listens on this stream before the source stream
       |  /// is set, or if using [_setEmpty] so there is no source stream.
       |  StreamController<T> _controller;
       |
       |  /// Source stream for the events provided by this stream.
       |  ///
       |  /// Set when the completer sets the source stream using [_setSourceStream]
       |  /// or [_setEmpty].
       |  Stream<T> _sourceStream;
       |
       |  StreamSubscription<T> listen(onData(T data),
       |                               {Function onError,
       |                                void onDone(),
       |                                bool cancelOnError}) {
      0|    if (_controller == null) {
      0|      if (_sourceStream != null && !_sourceStream.isBroadcast) {
       |        // If the source stream is itself single subscription,
       |        // just listen to it directly instead of creating a controller.
      0|        return _sourceStream.listen(onData, onError: onError, onDone: onDone,
       |                                    cancelOnError: cancelOnError);
       |      }
      0|      _createController();
      0|      if (_sourceStream != null) {
      0|        _linkStreamToController();
       |      }
       |    }
      0|    return _controller.stream.listen(onData, onError: onError, onDone: onDone,
       |                                     cancelOnError: cancelOnError);
       |  }
       |
       |  /// Whether a source stream has been set.
       |  ///
       |  /// Used to throw an error if trying to set a source stream twice.
      0|  bool get _isSourceStreamSet => _sourceStream != null;
       |
       |  /// Sets the source stream providing the events for this stream.
       |  ///
       |  /// If set before the user listens, listen calls will be directed directly
       |  /// to the source stream. If the user listenes earlier, and intermediate
       |  /// stream is created using a stream controller, and the source stream is
       |  /// linked into that stream later.
       |  void _setSourceStream(Stream<T> sourceStream) {
       |    assert(_sourceStream == null);
      0|    _sourceStream = sourceStream;
      0|    if (_controller != null) {
       |      // User has already listened, so provide the data through controller.
      0|      _linkStreamToController();
       |    }
       |  }
       |
       |  /// Links source stream to controller when both are available.
       |  void _linkStreamToController() {
       |    assert(_controller != null);
       |    assert(_sourceStream != null);
      0|    _controller.addStream(_sourceStream, cancelOnError: false)
      0|               .whenComplete(_controller.close);
       |  }
       |
       |  /// Sets an empty source stream.
       |  ///
       |  /// Uses [_controller] for the stream, then closes the controller
       |  /// immediately.
       |  void _setEmpty() {
       |    assert(_sourceStream == null);
      0|    if (_controller == null) {
      0|      _createController();
       |    }
      0|    _sourceStream = _controller.stream;  // Mark stream as set.
      0|    _controller.close();
       |  }
       |
       |  // Creates the [_controller].
       |  void _createController() {
       |    assert(_controller == null);
      0|    _controller = new StreamController<T>(sync: true);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_group.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A collection of streams whose events are unified and sent through a central
       |/// stream.
       |///
       |/// Both errors and data events are forwarded through [stream]. The streams in
       |/// the group won't be listened to until [stream] has a listener. **Note that
       |/// this means that events emitted by broadcast streams will be dropped until
       |/// [stream] has a listener.**
       |///
       |/// If the `StreamGroup` is constructed using [new StreamGroup], [stream] will
       |/// be single-subscription. In this case, if [stream] is paused or canceled, all
       |/// streams in the group will likewise be paused or canceled, respectively.
       |///
       |/// If the `StreamGroup` is constructed using [new StreamGroup.broadcast],
       |/// [stream] will be a broadcast stream. In this case, the streams in the group
       |/// will never be paused and single-subscription streams in the group will never
       |/// be canceled. **Note that single-subscription streams in a broadcast group
       |/// may drop events if a listener is added and later removed.** Broadcast
       |/// streams in the group will be canceled once [stream] has no listeners, and
       |/// will be listened to again once [stream] has listeners.
       |///
       |/// [stream] won't close until [close] is called on the group *and* every stream
       |/// in the group closes.
       |class StreamGroup<T> implements Sink<Stream<T>> {
       |  /// The stream through which all events from streams in the group are emitted.
      2|  Stream<T> get stream => _controller.stream;
       |  StreamController<T> _controller;
       |
       |  /// Whether the group is closed, meaning that no more streams may be added.
       |  var _closed = false;
       |
       |  /// The current state of the group.
       |  ///
       |  /// See [_StreamGroupState] for detailed descriptions of each state.
       |  var _state = _StreamGroupState.dormant;
       |
       |  /// Streams that have been added to the group, and their subscriptions if they
       |  /// have been subscribed to.
       |  ///
       |  /// The subscriptions will be null until the group has a listener registered.
       |  /// If it's a broadcast group and it goes dormant again, broadcast stream
       |  /// subscriptions will be canceled and set to null again. Single-subscriber
       |  /// stream subscriptions will be left intact, since they can't be
       |  /// re-subscribed.
       |  final _subscriptions = new Map<Stream<T>, StreamSubscription<T>>();
       |
       |  /// Merges the events from [streams] into a single (single-subscriber) stream.
       |  ///
       |  /// This is equivalent to adding [streams] to a group, closing that group, and
       |  /// returning its stream.
       |  static Stream<T> merge<T>(Iterable<Stream<T>> streams) {
      0|    var group = new StreamGroup<T>();
      0|    streams.forEach(group.add);
      0|    group.close();
      0|    return group.stream;
       |  }
       |
       |  /// Creates a new stream group where [stream] is single-subscriber.
      0|  StreamGroup() {
      0|    _controller = new StreamController<T>(
      0|        onListen: _onListen,
      0|        onPause: _onPause,
      0|        onResume: _onResume,
      0|        onCancel: _onCancel,
       |        sync: true);
       |  }
       |
       |  /// Creates a new stream group where [stream] is a broadcast stream.
      1|  StreamGroup.broadcast() {
      2|    _controller = new StreamController<T>.broadcast(
      1|        onListen: _onListen,
      1|        onCancel: _onCancelBroadcast,
       |        sync: true);
       |  }
       |
       |  /// Adds [stream] as a member of this group.
       |  ///
       |  /// Any events from [stream] will be emitted through [this.stream]. If this
       |  /// group has a listener, [stream] will be listened to immediately; otherwise
       |  /// it will only be listened to once this group gets a listener.
       |  ///
       |  /// If this is a single-subscription group and its subscription has been
       |  /// canceled, [stream] will be canceled as soon as its added. If this returns
       |  /// a [Future], it will be returned from [add]. Otherwise, [add] returns
       |  /// `null`.
       |  ///
       |  /// Throws a [StateError] if this group is closed.
       |  Future add(Stream<T> stream) {
      1|    if (_closed) {
      0|      throw new StateError("Can't add a Stream to a closed StreamGroup.");
       |    }
       |
      2|    if (_state == _StreamGroupState.dormant) {
      0|      _subscriptions.putIfAbsent(stream, () => null);
      2|    } else if (_state == _StreamGroupState.canceled) {
       |      // Listen to the stream and cancel it immediately so that no one else can
       |      // listen, for consistency. If the stream has an onCancel listener this
       |      // will also fire that, which may help it clean up resources.
      0|      return stream.listen(null).cancel();
       |    } else {
      3|      _subscriptions.putIfAbsent(stream, () => _listenToStream(stream));
       |    }
       |
       |    return null;
       |  }
       |
       |  /// Removes [stream] as a member of this group.
       |  ///
       |  /// No further events from [stream] will be emitted through this group. If
       |  /// [stream] has been listened to, its subscription will be canceled.
       |  ///
       |  /// If [stream] has been listened to, this *synchronously* cancels its
       |  /// subscription. This means that any events from [stream] that haven't yet
       |  /// been emitted through this group will not be.
       |  ///
       |  /// If [stream]'s subscription is canceled, this returns
       |  /// [StreamSubscription.cancel]'s return value. Otherwise, it returns `null`.
       |  Future remove(Stream<T> stream) {
      2|    var subscription = _subscriptions.remove(stream);
      1|    var future = subscription == null ? null : subscription.cancel();
      1|    if (_closed && _subscriptions.isEmpty) _controller.close();
       |    return future;
       |  }
       |
       |  /// A callback called when [stream] is listened to.
       |  ///
       |  /// This is called for both single-subscription and broadcast groups.
       |  void _onListen() {
      1|    _state = _StreamGroupState.listening;
      2|    _subscriptions.forEach((stream, subscription) {
       |      // If this is a broadcast group and this isn't the first time it's been
       |      // listened to, there may still be some subscriptions to
       |      // single-subscription streams.
       |      if (subscription != null) return;
      0|      _subscriptions[stream] = _listenToStream(stream);
       |    });
       |  }
       |
       |  /// A callback called when [stream] is paused.
       |  void _onPause() {
      0|    _state = _StreamGroupState.paused;
      0|    for (var subscription in _subscriptions.values) {
      0|      subscription.pause();
       |    }
       |  }
       |
       |  /// A callback called when [stream] is resumed.
       |  void _onResume() {
      0|    _state = _StreamGroupState.listening;
      0|    for (var subscription in _subscriptions.values) {
      0|      subscription.resume();
       |    }
       |  }
       |
       |  /// A callback called when [stream] is canceled.
       |  ///
       |  /// This is only called for single-subscription groups.
       |  Future _onCancel() {
      0|    _state = _StreamGroupState.canceled;
       |
      0|    var futures = _subscriptions.values
      0|        .map((subscription) => subscription.cancel())
      0|        .where((future) => future != null)
      0|        .toList();
       |
      0|    _subscriptions.clear();
      0|    return futures.isEmpty ? null : Future.wait(futures);
       |  }
       |
       |  /// A callback called when [stream]'s last listener is canceled.
       |  ///
       |  /// This is only called for broadcast groups.
       |  void _onCancelBroadcast() {
      1|    _state = _StreamGroupState.dormant;
       |
      2|    _subscriptions.forEach((stream, subscription) {
       |      // Cancel the broadcast streams, since we can re-listen to those later,
       |      // but allow the single-subscription streams to keep firing. Their events
       |      // will still be added to [_controller], but then they'll be dropped since
       |      // it has no listeners.
      0|      if (!stream.isBroadcast) return;
      0|      subscription.cancel();
      0|      _subscriptions[stream] = null;
       |    });
       |  }
       |
       |  /// Starts actively forwarding events from [stream] to [_controller].
       |  ///
       |  /// This will pause the resulting subscription if [this] is paused.
       |  StreamSubscription<T> _listenToStream(Stream<T> stream) {
      1|    var subscription = stream.listen(
      2|        _controller.add,
      2|        onError: _controller.addError,
      1|        onDone: () => remove(stream));
      2|    if (_state == _StreamGroupState.paused) subscription.pause();
       |    return subscription;
       |  }
       |
       |  /// Closes the group, indicating that no more streams will be added.
       |  ///
       |  /// If there are no streams in the group, [stream] is closed immediately.
       |  /// Otherwise, [stream] will close once all streams in the group close.
       |  ///
       |  /// Returns a [Future] that completes once [stream] has actually been closed.
       |  Future close() {
      1|    if (_closed) return _controller.done;
       |
      1|    _closed = true;
      4|    if (_subscriptions.isEmpty) _controller.close();
       |
      2|    return _controller.done;
       |  }
       |}
       |
       |/// An enum of possible states of a [StreamGroup].
       |class _StreamGroupState {
       |  /// The group has no listeners.
       |  ///
       |  /// New streams added to the group will be listened once the group has a
       |  /// listener.
       |  static const dormant = const _StreamGroupState("dormant");
       |
       |  /// The group has one or more listeners and is actively firing events.
       |  ///
       |  /// New streams added to the group will be immediately listeners.
       |  static const listening = const _StreamGroupState("listening");
       |
       |  /// The group is paused and no more events will be fired until it resumes.
       |  ///
       |  /// New streams added to the group will be listened to, but then paused. They
       |  /// will be resumed once the group itself is resumed.
       |  ///
       |  /// This state is only used by single-subscriber groups.
       |  static const paused = const _StreamGroupState("paused");
       |
       |  /// The group is canceled and no more events will be fired ever.
       |  ///
       |  /// New streams added to the group will be listened to, canceled, and
       |  /// discarded.
       |  ///
       |  /// This state is only used by single-subscriber groups.
       |  static const canceled = const _StreamGroupState("canceled");
       |
       |  /// The name of the state.
       |  ///
       |  /// Used for debugging.
       |  final String name;
       |
      1|  const _StreamGroupState(this.name);
       |
      0|  String toString() => name;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_queue.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import 'package:collection/collection.dart';
       |
       |import "cancelable_operation.dart";
       |import "result.dart";
       |import "subscription_stream.dart";
       |import "stream_completer.dart";
       |import "stream_splitter.dart";
       |
       |/// An asynchronous pull-based interface for accessing stream events.
       |///
       |/// Wraps a stream and makes individual events available on request.
       |///
       |/// You can request (and reserve) one or more events from the stream,
       |/// and after all previous requests have been fulfilled, stream events
       |/// go towards fulfilling your request.
       |///
       |/// For example, if you ask for [next] two times, the returned futures
       |/// will be completed by the next two unrequested events from the stream.
       |///
       |/// The stream subscription is paused when there are no active
       |/// requests.
       |///
       |/// Some streams, including broadcast streams, will buffer
       |/// events while paused, so waiting too long between requests may
       |/// cause memory bloat somewhere else.
       |///
       |/// This is similar to, but more convenient than, a [StreamIterator].
       |/// A `StreamIterator` requires you to manually check when a new event is
       |/// available and you can only access the value of that event until you
       |/// check for the next one. A `StreamQueue` allows you to request, for example,
       |/// three events at a time, either individually, as a group using [take]
       |/// or [skip], or in any combination.
       |///
       |/// You can also ask to have the [rest] of the stream provided as
       |/// a new stream. This allows, for example, taking the first event
       |/// out of a stream and continuing to use the rest of the stream as a stream.
       |///
       |/// Example:
       |///
       |///     var events = new StreamQueue<String>(someStreamOfLines);
       |///     var first = await events.next;
       |///     while (first.startsWith('#')) {
       |///       // Skip comments.
       |///       first = await events.next;
       |///     }
       |///
       |///     if (first.startsWith(MAGIC_MARKER)) {
       |///       var headerCount =
       |///           first.parseInt(first.substring(MAGIC_MARKER.length + 1));
       |///       handleMessage(headers: await events.take(headerCount),
       |///                     body: events.rest);
       |///       return;
       |///     }
       |///     // Error handling.
       |///
       |/// When you need no further events the `StreamQueue` should be closed
       |/// using [cancel]. This releases the underlying stream subscription.
       |abstract class StreamQueue<T> {
       |  // This class maintains two queues: one of events and one of requests.
       |  // The active request (the one in front of the queue) is called with
       |  // the current event queue when it becomes active, every time a
       |  // new event arrives, and when the event source closes.
       |  //
       |  // If the request returns `true`, it's complete and will be removed from the
       |  // request queue.
       |  // If the request returns `false`, it needs more events, and will be called
       |  // again when new events are available. It may trigger a call itself by
       |  // calling [_updateRequests].
       |  // The request can remove events that it uses, or keep them in the event
       |  // queue until it has all that it needs.
       |  //
       |  // This model is very flexible and easily extensible.
       |  // It allows requests that don't consume events (like [hasNext]) or
       |  // potentially a request that takes either five or zero events, determined
       |  // by the content of the fifth event.
       |
       |  /// Whether the event source is done.
       |  bool _isDone = false;
       |
       |  /// Whether a closing operation has been performed on the stream queue.
       |  ///
       |  /// Closing operations are [cancel] and [rest].
       |  bool _isClosed = false;
       |
       |  /// The number of events dispatched by this queue.
       |  ///
       |  /// This counts error events. It doesn't count done events, or events
       |  /// dispatched to a stream returned by [rest].
      0|  int get eventsDispatched => _eventsReceived - _eventQueue.length;
       |
       |  /// The number of events received by this queue.
       |  var _eventsReceived = 0;
       |
       |  /// Queue of events not used by a request yet.
       |  final QueueList<Result> _eventQueue = new QueueList();
       |
       |  /// Queue of pending requests.
       |  ///
       |  /// Access through methods below to ensure consistency.
       |  final Queue<_EventRequest> _requestQueue = new Queue();
       |
       |  /// Create a `StreamQueue` of the events of [source].
       |  factory StreamQueue(Stream<T> source) = _StreamQueue<T>;
       |
      0|  StreamQueue._();
       |
       |  /// Asks if the stream has any more events.
       |  ///
       |  /// Returns a future that completes with `true` if the stream has any
       |  /// more events, whether data or error.
       |  /// If the stream closes without producing any more events, the returned
       |  /// future completes with `false`.
       |  ///
       |  /// Can be used before using [next] to avoid getting an error in the
       |  /// future returned by `next` in the case where there are no more events.
       |  /// Another alternative is to use `take(1)` which returns either zero or
       |  /// one events.
       |  Future<bool> get hasNext {
      0|    if (!_isClosed) {
      0|      var hasNextRequest = new _HasNextRequest();
      0|      _addRequest(hasNextRequest);
      0|      return hasNextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |
       |  /// Look at the next [count] data events without consuming them.
       |  ///
       |  /// Works like [take] except that the events are left in the queue.
       |  /// If one of the next [count] events is an error, the returned future
       |  /// completes with this error, and the error is still left in the queue.
       |  Future<List<T>> lookAhead(int count) {
      0|    if (count < 0) throw new RangeError.range(count, 0, null, "count");
      0|    if (!_isClosed) {
      0|      var request = new _LookAheadRequest<T>(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests the next (yet unrequested) event from the stream.
       |  ///
       |  /// When the requested event arrives, the returned future is completed with
       |  /// the event.
       |  /// If the event is a data event, the returned future completes
       |  /// with its value.
       |  /// If the event is an error event, the returned future completes with
       |  /// its error and stack trace.
       |  /// If the stream closes before an event arrives, the returned future
       |  /// completes with a [StateError].
       |  ///
       |  /// It's possible to have several pending [next] calls (or other requests),
       |  /// and they will be completed in the order they were requested, by the
       |  /// first events that were not consumed by previous requeusts.
       |  Future<T> get next {
      0|    if (!_isClosed) {
      0|      var nextRequest = new _NextRequest<T>();
      0|      _addRequest(nextRequest);
      0|      return nextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Looks at the next (yet unrequested) event from the stream.
       |  ///
       |  /// Like [next] except that the event is not consumed.
       |  /// If the next event is an error event, it stays in the queue.
       |  Future<T> get peek {
      0|    if (!_isClosed) {
      0|      var nextRequest = new _PeekRequest<T>();
      0|      _addRequest(nextRequest);
      0|      return nextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Returns a stream of all the remaning events of the source stream.
       |  ///
       |  /// All requested [next], [skip] or [take] operations are completed
       |  /// first, and then any remaining events are provided as events of
       |  /// the returned stream.
       |  ///
       |  /// Using `rest` closes this stream queue. After getting the
       |  /// `rest` the caller may no longer request other events, like
       |  /// after calling [cancel].
       |  Stream<T> get rest {
      0|    if (_isClosed) {
      0|      throw _failClosed();
       |    }
      0|    var request = new _RestRequest<T>(this);
      0|    _isClosed = true;
      0|    _addRequest(request);
      0|    return request.stream;
       |  }
       |
       |  /// Skips the next [count] *data* events.
       |  ///
       |  /// The [count] must be non-negative.
       |  ///
       |  /// When successful, this is equivalent to using [take]
       |  /// and ignoring the result.
       |  ///
       |  /// If an error occurs before `count` data events have been skipped,
       |  /// the returned future completes with that error instead.
       |  ///
       |  /// If the stream closes before `count` data events,
       |  /// the remaining unskipped event count is returned.
       |  /// If the returned future completes with the integer `0`,
       |  /// then all events were succssfully skipped. If the value
       |  /// is greater than zero then the stream ended early.
       |  Future<int> skip(int count) {
      0|    if (count < 0) throw new RangeError.range(count, 0, null, "count");
      0|    if (!_isClosed) {
      0|      var request = new _SkipRequest(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests the next [count] data events as a list.
       |  ///
       |  /// The [count] must be non-negative.
       |  ///
       |  /// Equivalent to calling [next] `count` times and
       |  /// storing the data values in a list.
       |  ///
       |  /// If an error occurs before `count` data events has
       |  /// been collected, the returned future completes with
       |  /// that error instead.
       |  ///
       |  /// If the stream closes before `count` data events,
       |  /// the returned future completes with the list
       |  /// of data collected so far. That is, the returned
       |  /// list may have fewer than [count] elements.
       |  Future<List<T>> take(int count) {
      0|    if (count < 0) throw new RangeError.range(count, 0, null, "count");
      0|    if (!_isClosed) {
      0|      var request = new _TakeRequest<T>(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests a transaction that can conditionally consume events.
       |  ///
       |  /// The transaction can create copies of this queue at the current position
       |  /// using [StreamQueueTransaction.newQueue]. Each of these queues is
       |  /// independent of one another and of the parent queue. The transaction
       |  /// finishes when one of two methods is called:
       |  ///
       |  /// * [StreamQueueTransaction.commit] updates the parent queue's position to
       |  ///   match that of one of the copies.
       |  ///
       |  /// * [StreamQueueTransaction.reject] causes the parent queue to continue as
       |  ///   though [startTransaction] hadn't been called.
       |  ///
       |  /// Until the transaction finishes, this queue won't emit any events.
       |  ///
       |  /// See also [withTransaction] and [cancelable].
       |  ///
       |  /// ```dart
       |  /// /// Consumes all empty lines from the beginning of [lines].
       |  /// Future consumeEmptyLines(StreamQueue<String> lines) async {
       |  ///   while (await lines.hasNext) {
       |  ///     var transaction = lines.startTransaction();
       |  ///     var queue = transaction.newQueue();
       |  ///     if ((await queue.next).isNotEmpty) {
       |  ///       transaction.reject();
       |  ///       return;
       |  ///     } else {
       |  ///       transaction.commit(queue);
       |  ///     }
       |  ///   }
       |  /// }
       |  /// ```
       |  StreamQueueTransaction<T> startTransaction() {
      0|    if (_isClosed) throw _failClosed();
       |
      0|    var request = new _TransactionRequest(this);
      0|    _addRequest(request);
      0|    return request.transaction;
       |  }
       |
       |  /// Passes a copy of this queue to [callback], and updates this queue to match
       |  /// the copy's position if [callback] returns `true`.
       |  ///
       |  /// This queue won't emit any events until [callback] returns. If it returns
       |  /// `false`, this queue continues as though [withTransaction] hadn't been
       |  /// called. If it throws an error, this updates this queue to match the copy's
       |  /// position and throws the error from the returned `Future`.
       |  ///
       |  /// Returns the same value as [callback].
       |  ///
       |  /// See also [startTransaction] and [cancelable].
       |  ///
       |  /// ```dart
       |  /// /// Consumes all empty lines from the beginning of [lines].
       |  /// Future consumeEmptyLines(StreamQueue<String> lines) async {
       |  ///   while (await lines.hasNext) {
       |  ///     // Consume a line if it's empty, otherwise return.
       |  ///     if (!await lines.withTransaction(
       |  ///         (queue) async => (await queue.next).isEmpty)) {
       |  ///       return;
       |  ///     }
       |  ///   }
       |  /// }
       |  /// ```
       |  Future<bool> withTransaction(Future<bool> callback(StreamQueue<T> queue)) {
      0|    var transaction = startTransaction();
       |
       |    /// Avoid async/await to ensure that [startTransaction] is called
       |    /// synchronously and so ends up in the right place in the request queue.
      0|    var queue = transaction.newQueue();
      0|    return callback(queue).then((result) {
       |      if (result) {
      0|        transaction.commit(queue);
       |      } else {
      0|        transaction.reject();
       |      }
       |      return result;
       |    }, onError: (error) {
      0|      transaction.commit(queue);
       |      throw error;
       |    });
       |  }
       |
       |  /// Passes a copy of this queue to [callback], and updates this queue to match
       |  /// the copy's position once [callback] completes.
       |  ///
       |  /// If the returned [CancelableOperation] is canceled, this queue instead
       |  /// continues as though [cancelable] hadn't been called. Otherwise, it emits
       |  /// the same value or error as [callback].
       |  ///
       |  /// See also [startTransaction] and [withTransaction].
       |  ///
       |  /// ```dart
       |  /// final _stdinQueue = new StreamQueue(stdin);
       |  ///
       |  /// /// Returns an operation that completes when the user sends a line to
       |  /// /// standard input.
       |  /// ///
       |  /// /// If the operation is canceled, stops waiting for user input.
       |  /// CancelableOperation<String> nextStdinLine() =>
       |  ///     _stdinQueue.cancelable((queue) => queue.next);
       |  /// ```
       |  CancelableOperation<S> cancelable<S>(
       |      Future<S> callback(StreamQueue<T> queue)) {
      0|    var transaction = startTransaction();
      0|    var completer = new CancelableCompleter<S>(onCancel: () {
      0|      transaction.reject();
       |    });
       |
      0|    var queue = transaction.newQueue();
      0|    completer.complete(callback(queue).whenComplete(() {
      0|      if (!completer.isCanceled) transaction.commit(queue);
       |    }));
       |
      0|    return completer.operation;
       |  }
       |
       |  /// Cancels the underlying event source.
       |  ///
       |  /// If [immediate] is `false` (the default), the cancel operation waits until
       |  /// all previously requested events have been processed, then it cancels the
       |  /// subscription providing the events.
       |  ///
       |  /// If [immediate] is `true`, the source is instead canceled
       |  /// immediately. Any pending events are completed as though the underlying
       |  /// stream had closed.
       |  ///
       |  /// The returned future completes with the result of calling
       |  /// `cancel`.
       |  ///
       |  /// After calling `cancel`, no further events can be requested.
       |  /// None of [lookAhead], [next], [peek], [rest], [skip], [take] or [cancel]
       |  /// may be called again.
       |  Future cancel({bool immediate: false}) {
      0|    if (_isClosed) throw _failClosed();
      0|    _isClosed = true;
       |
       |    if (!immediate) {
      0|      var request = new _CancelRequest(this);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
       |
      0|    if (_isDone && _eventQueue.isEmpty) return new Future.value();
      0|    return _cancel();
       |  }
       |
       |  // ------------------------------------------------------------------
       |  // Methods that may be called from the request implementations to
       |  // control the even stream.
       |
       |  /// Matches events with requests.
       |  ///
       |  /// Called after receiving an event or when the event source closes.
       |  ///
       |  /// May be called by requests which have returned `false` (saying they
       |  /// are not yet done) so they can be checked again before any new
       |  /// events arrive.
       |  /// Any request returing `false` from `update` when `isDone` is `true`
       |  /// *must* call `_updateRequests` when they are ready to continue
       |  /// (since no further events will trigger the call).
       |  void _updateRequests() {
      0|    while (_requestQueue.isNotEmpty) {
      0|      if (_requestQueue.first.update(_eventQueue, _isDone)) {
      0|        _requestQueue.removeFirst();
       |      } else {
       |        return;
       |      }
       |    }
       |
      0|    if (!_isDone) {
      0|      _pause();
       |    }
       |  }
       |
       |  /// Extracts a stream from the event source and makes this stream queue
       |  /// unusable.
       |  ///
       |  /// Can only be used by the very last request (the stream queue must
       |  /// be closed by that request).
       |  /// Only used by [rest].
       |  Stream<T> _extractStream();
       |
       |  /// Requests that the event source pauses events.
       |  ///
       |  /// This is called automatically when the request queue is empty.
       |  ///
       |  /// The event source is restarted by the next call to [_ensureListening].
       |  void _pause();
       |
       |  /// Ensures that we are listening on events from the event source.
       |  ///
       |  /// Starts listening for the first time or resumes after a [_pause].
       |  ///
       |  /// Is called automatically if a request requires more events.
       |  void _ensureListening();
       |
       |  /// Cancels the underlying event source.
       |  Future _cancel();
       |
       |  // ------------------------------------------------------------------
       |  // Methods called by the event source to add events or say that it's
       |  // done.
       |
       |  /// Called when the event source adds a new data or error event.
       |  /// Always calls [_updateRequests] after adding.
       |  void _addResult(Result result) {
      0|    _eventsReceived++;
      0|    _eventQueue.add(result);
      0|    _updateRequests();
       |  }
       |
       |  /// Called when the event source is done.
       |  /// Always calls [_updateRequests] after adding.
       |  void _close() {
      0|    _isDone = true;
      0|    _updateRequests();
       |  }
       |
       |  // ------------------------------------------------------------------
       |  // Internal helper methods.
       |
       |  /// Returns an error for when a request is made after cancel.
       |  ///
       |  /// Returns a [StateError] with a message saying that either
       |  /// [cancel] or [rest] have already been called.
       |  Error _failClosed() {
      0|    return new StateError("Already cancelled");
       |  }
       |
       |  /// Adds a new request to the queue.
       |  ///
       |  /// If the request queue is empty and the request can be completed
       |  /// immediately, it skips the queue.
       |  void _addRequest(_EventRequest request) {
      0|    if (_requestQueue.isEmpty) {
      0|      if (request.update(_eventQueue, _isDone)) return;
      0|      _ensureListening();
       |    }
      0|    _requestQueue.add(request);
       |  }
       |}
       |
       |
       |/// The default implementation of [StreamQueue].
       |///
       |/// This queue gets its events from a stream which is listened
       |/// to when a request needs events.
       |class _StreamQueue<T> extends StreamQueue<T> {
       |  /// Source of events.
       |  final Stream<T> _sourceStream;
       |
       |  /// Subscription on [_sourceStream] while listening for events.
       |  ///
       |  /// Set to subscription when listening, and set to `null` when the
       |  /// subscription is done (and [_isDone] is set to true).
       |  StreamSubscription<T> _subscription;
       |
      0|  _StreamQueue(this._sourceStream) : super._();
       |
       |  Future _cancel() {
      0|    if (_isDone) return null;
      0|    if (_subscription == null) _subscription = _sourceStream.listen(null);
      0|    var future = _subscription.cancel();
      0|    _close();
       |    return future;
       |  }
       |
       |  void _ensureListening() {
      0|    if (_isDone) return;
      0|    if (_subscription == null) {
      0|      _subscription =
      0|          _sourceStream.listen(
       |              (data) {
      0|                _addResult(new Result.value(data));
       |              },
       |              onError: (error, StackTrace stackTrace) {
      0|                _addResult(new Result.error(error, stackTrace));
       |              },
       |              onDone: () {
      0|                _subscription = null;
      0|                this._close();
       |              });
       |    } else {
      0|      _subscription.resume();
       |    }
       |  }
       |
       |  void _pause() {
      0|    _subscription.pause();
       |  }
       |
       |  Stream<T> _extractStream() {
       |    assert(_isClosed);
      0|    if (_isDone) {
      0|      return new Stream<T>.empty();
       |    }
      0|    _isDone = true;
       |
      0|    if (_subscription == null) {
      0|      return _sourceStream;
       |    }
       |
      0|    var subscription = _subscription;
      0|    _subscription = null;
       |
      0|    var wasPaused = subscription.isPaused;
      0|    var result = new SubscriptionStream<T>(subscription);
       |    // Resume after creating stream because that pauses the subscription too.
       |    // This way there won't be a short resumption in the middle.
      0|    if (wasPaused) subscription.resume();
       |    return result;
       |  }
       |}
       |
       |/// A transaction on a [StreamQueue], created by [StreamQueue.startTransaction].
       |///
       |/// Copies of the parent queue may be created using [newQueue]. Calling [commit]
       |/// moves the parent queue to a copy's position, and calling [reject] causes it
       |/// to continue as though [StreamQueue.startTransaction] was never called.
       |class StreamQueueTransaction<T> {
       |  /// The parent queue on which this transaction is active.
       |  final StreamQueue<T> _parent;
       |
       |  /// The splitter that produces copies of the parent queue's stream.
       |  final StreamSplitter<T> _splitter;
       |
       |  /// Queues created using [newQueue].
       |  final _queues = new Set<StreamQueue>();
       |
       |  /// Whether [commit] has been called.
       |  var _committed = false;
       |
       |  /// Whether [reject] has been called.
       |  var _rejected = false;
       |
       |  StreamQueueTransaction._(this._parent, Stream<T> source)
      0|      : _splitter = new StreamSplitter(source);
       |
       |  /// Creates a new copy of the parent queue.
       |  ///
       |  /// This copy starts at the parent queue's position when
       |  /// [StreamQueue.startTransaction] was called. Its position can be committed
       |  /// to the parent queue using [commit].
       |  StreamQueue<T> newQueue() {
      0|    var queue = new StreamQueue(_splitter.split());
      0|    _queues.add(queue);
       |    return queue;
       |  }
       |
       |  /// Commits a queue created using [newQueue].
       |  ///
       |  /// The parent queue's position is updated to be the same as [queue]'s.
       |  /// Further requests on all queues created by this transaction, including
       |  /// [queue], will complete as though [cancel] were called with `immediate:
       |  /// true`.
       |  ///
       |  /// Throws a [StateError] if [commit] or [reject] have already been called, or
       |  /// if there are pending requests on [queue].
       |  void commit(StreamQueue<T> queue) {
      0|    _assertActive();
      0|    if (!_queues.contains(queue)) {
      0|      throw new ArgumentError("Queue doesn't belong to this transaction.");
      0|    } else if (queue._requestQueue.isNotEmpty) {
      0|      throw new StateError("A queue with pending requests can't be committed.");
       |    }
      0|    _committed = true;
       |
       |    // Remove all events from the parent queue that were consumed by the
       |    // child queue.
      0|    for (var j = 0; j < queue.eventsDispatched; j++) {
      0|      _parent._eventQueue.removeFirst();
       |    }
       |
      0|    _done();
       |  }
       |
       |  /// Rejects this transaction without updating the parent queue.
       |  ///
       |  /// The parent will continue as though [StreamQueue.startTransaction] hadn't
       |  /// been called. Further requests on all queues created by this transaction
       |  /// will complete as though [cancel] were called with `immediate: true`.
       |  ///
       |  /// Throws a [StateError] if [commit] or [reject] have already been called.
       |  void reject() {
      0|    _assertActive();
      0|    _rejected = true;
      0|    _done();
       |  }
       |
       |  // Cancels all [_queues], removes the [_TransactionRequest] from [_parent]'s
       |  // request queue, and runs the next request.
       |  void _done() {
      0|    _splitter.close();
      0|    for (var queue in _queues) {
      0|      queue._cancel();
       |    }
       |
       |    assert((_parent._requestQueue.first as _TransactionRequest)
       |        .transaction == this);
      0|    _parent._requestQueue.removeFirst();
      0|    _parent._updateRequests();
       |  }
       |
       |  /// Throws a [StateError] if [accept] or [reject] has already been called.
       |  void _assertActive() {
      0|    if (_committed) {
      0|      throw new StateError("This transaction has already been accepted.");
      0|    } else if (_rejected) {
      0|      throw new StateError("This transaction has already been rejected.");
       |    }
       |  }
       |}
       |
       |/// Request object that receives events when they arrive, until fulfilled.
       |///
       |/// Each request that cannot be fulfilled immediately is represented by
       |/// an `_EventRequest` object in the request queue.
       |///
       |/// Events from the source stream are sent to the first request in the
       |/// queue until it reports itself as [isComplete].
       |///
       |/// When the first request in the queue `isComplete`, either when becoming
       |/// the first request or after receiving an event, its [close] methods is
       |/// called.
       |///
       |/// The [close] method is also called immediately when the source stream
       |/// is done.
       |abstract class _EventRequest<T> {
       |  /// Handle available events.
       |  ///
       |  /// The available events are provided as a queue. The `update` function
       |  /// should only remove events from the front of the event queue, e.g.,
       |  /// using [removeFirst].
       |  ///
       |  /// Returns `true` if the request is completed, or `false` if it needs
       |  /// more events.
       |  /// The call may keep events in the queue until the requeust is complete,
       |  /// or it may remove them immediately.
       |  ///
       |  /// If the method returns true, the request is considered fulfilled, and
       |  /// will never be called again.
       |  ///
       |  /// This method is called when a request reaches the front of the request
       |  /// queue, and if it returns `false`, it's called again every time a new event
       |  /// becomes available, or when the stream closes.
       |  /// If the function returns `false` when the stream has already closed
       |  /// ([isDone] is true), then the request must call
       |  /// [StreamQueue._updateRequests] itself when it's ready to continue.
       |  bool update(QueueList<Result<T>> events, bool isDone);
       |}
       |
       |/// Request for a [StreamQueue.next] call.
       |///
       |/// Completes the returned future when receiving the first event,
       |/// and is then complete.
       |class _NextRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by [StreamQueue.next].
       |  final _completer = new Completer<T>();
       |
      0|  _NextRequest();
       |
      0|  Future<T> get future => _completer.future;
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isNotEmpty) {
      0|      events.removeFirst().complete(_completer);
       |      return true;
       |    }
       |    if (isDone) {
      0|      _completer.completeError(new StateError("No elements"),
      0|                               StackTrace.current);
       |      return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |
       |/// Request for a [StreamQueue.peek] call.
       |///
       |/// Completes the returned future when receiving the first event,
       |/// and is then complete, but doesn't consume the event.
       |class _PeekRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by [StreamQueue.next].
       |  final _completer = new Completer<T>();
       |
      0|  _PeekRequest();
       |
      0|  Future<T> get future => _completer.future;
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isNotEmpty) {
      0|      events.first.complete(_completer);
       |      return true;
       |    }
       |    if (isDone) {
      0|      _completer.completeError(new StateError("No elements"),
      0|                               StackTrace.current);
       |      return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |
       |/// Request for a [StreamQueue.skip] call.
       |class _SkipRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by the skip call.
       |  final _completer = new Completer<int>();
       |
       |  /// Number of remaining events to skip.
       |  ///
       |  /// The request [isComplete] when the values reaches zero.
       |  ///
       |  /// Decremented when an event is seen.
       |  /// Set to zero when an error is seen since errors abort the skip request.
       |  int _eventsToSkip;
       |
      0|  _SkipRequest(this._eventsToSkip);
       |
       |  /// The future completed when the correct number of events have been skipped.
      0|  Future<int> get future => _completer.future;
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_eventsToSkip > 0) {
      0|      if (events.isEmpty) {
       |        if (isDone) break;
       |        return false;
       |      }
      0|      _eventsToSkip--;
       |
      0|      var event = events.removeFirst();
      0|      if (event.isError) {
      0|        _completer.completeError(event.asError.error, event.asError.stackTrace);
       |        return true;
       |      }
       |    }
      0|    _completer.complete(_eventsToSkip);
       |    return true;
       |  }
       |}
       |
       |/// Common superclass for [_TakeRequest] and [_LookAheadRequest].
       |abstract class _ListRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by the take call.
       |  final _completer = new Completer<List<T>>();
       |
       |  /// List collecting events until enough have been seen.
       |  final _list = <T>[];
       |
       |  /// Number of events to capture.
       |  ///
       |  /// The request [isComplete] when the length of [_list] reaches
       |  /// this value.
       |  final int _eventsToTake;
       |
      0|  _ListRequest(this._eventsToTake);
       |
       |  /// The future completed when the correct number of events have been captured.
      0|  Future<List<T>> get future => _completer.future;
       |}
       |
       |
       |/// Request for a [StreamQueue.take] call.
       |class _TakeRequest<T> extends _ListRequest<T> {
      0|  _TakeRequest(int eventsToTake) : super(eventsToTake);
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_list.length < _eventsToTake) {
      0|      if (events.isEmpty) {
       |        if (isDone) break;
       |        return false;
       |      }
       |
      0|      var event = events.removeFirst();
      0|      if (event.isError) {
      0|        event.asError.complete(_completer);
       |        return true;
       |      }
      0|      _list.add(event.asValue.value);
       |    }
      0|    _completer.complete(_list);
       |    return true;
       |  }
       |}
       |
       |
       |/// Request for a [StreamQueue.lookAhead] call.
       |class _LookAheadRequest<T> extends _ListRequest<T> {
      0|  _LookAheadRequest(int eventsToTake) : super(eventsToTake);
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_list.length < _eventsToTake) {
      0|      if (events.length == _list.length) {
       |        if (isDone) break;
       |        return false;
       |      }
      0|      var event = events.elementAt(_list.length);
      0|      if (event.isError) {
      0|        event.asError.complete(_completer);
       |        return true;
       |      }
      0|      _list.add(event.asValue.value);
       |    }
      0|    _completer.complete(_list);
       |    return true;
       |  }
       |}
       |
       |
       |/// Request for a [StreamQueue.cancel] call.
       |///
       |/// The request needs no events, it just waits in the request queue
       |/// until all previous events are fulfilled, then it cancels the stream queue
       |/// source subscription.
       |class _CancelRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by the `cancel` call.
       |  final _completer = new Completer();
       |  ///
       |  /// When the event is completed, it needs to cancel the active subscription
       |  /// of the `StreamQueue` object, if any.
       |  final StreamQueue _streamQueue;
       |
      0|  _CancelRequest(this._streamQueue);
       |
       |  /// The future completed when the cancel request is completed.
      0|  Future get future => _completer.future;
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (_streamQueue._isDone) {
      0|      _completer.complete();
       |    } else {
      0|      _streamQueue._ensureListening();
      0|      _completer.complete(_streamQueue._extractStream().listen(null).cancel());
       |    }
       |    return true;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.rest] call.
       |///
       |/// The request is always complete, it just waits in the request queue
       |/// until all previous events are fulfilled, then it takes over the
       |/// stream events subscription and creates a stream from it.
       |class _RestRequest<T> implements _EventRequest<T> {
       |  /// Completer for the stream returned by the `rest` call.
       |  final _completer = new StreamCompleter<T>();
       |
       |  /// The [StreamQueue] object that has this request queued.
       |  ///
       |  /// When the event is completed, it needs to cancel the active subscription
       |  /// of the `StreamQueue` object, if any.
       |  final StreamQueue<T> _streamQueue;
       |
      0|  _RestRequest(this._streamQueue);
       |
       |  /// The stream which will contain the remaining events of [_streamQueue].
      0|  Stream<T> get stream => _completer.stream;
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isEmpty) {
      0|      if (_streamQueue._isDone) {
      0|        _completer.setEmpty();
       |      } else {
      0|        _completer.setSourceStream(_streamQueue._extractStream());
       |      }
       |    } else {
       |      // There are prefetched events which needs to be added before the
       |      // remaining stream.
      0|      var controller = new StreamController<T>();
      0|      for (var event in events) {
      0|        event.addTo(controller);
       |      }
      0|      controller.addStream(_streamQueue._extractStream(), cancelOnError: false)
      0|                .whenComplete(controller.close);
      0|      _completer.setSourceStream(controller.stream);
       |    }
       |    return true;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.hasNext] call.
       |///
       |/// Completes the [future] with `true` if it sees any event,
       |/// but doesn't consume the event.
       |/// If the request is closed without seeing an event, then
       |/// the [future] is completed with `false`.
       |class _HasNextRequest<T> implements _EventRequest<T> {
       |  final _completer = new Completer<bool>();
       |
      0|  Future<bool> get future => _completer.future;
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isNotEmpty) {
      0|      _completer.complete(true);
       |      return true;
       |    }
       |    if (isDone) {
      0|      _completer.complete(false);
       |      return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.startTransaction] call.
       |///
       |/// This request isn't complete until the user calls
       |/// [StreamQueueTransaction.commit] or [StreamQueueTransaction.reject], at which
       |/// point it manually removes itself from the request queue and calls
       |/// [StreamQueue._updateRequests].
       |class _TransactionRequest<T> implements _EventRequest<T> {
       |  /// The transaction created by this request.
      0|  StreamQueueTransaction<T> get transaction => _transaction;
       |  StreamQueueTransaction<T> _transaction;
       |
       |  /// The controller that passes events to [transaction].
       |  final _controller = new StreamController<T>(sync: true);
       |
       |  /// The number of events passed to [_controller] so far.
       |  var _eventsSent = 0;
       |
      0|  _TransactionRequest(StreamQueue<T> parent) {
      0|    _transaction = new StreamQueueTransaction._(parent, _controller.stream);
       |  }
       |
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_eventsSent < events.length) {
      0|      events[_eventsSent++].addTo(_controller);
       |    }
      0|    if (isDone && !_controller.isClosed) _controller.close();
       |    return false;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_sink_completer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'null_stream_sink.dart';
       |
       |/// A [sink] where the destination is provided later.
       |///
       |/// The [sink] is a normal sink that you can add events to to immediately, but
       |/// until [setDestinationSink] is called, the events will be buffered.
       |///
       |/// The same effect can be achieved by using a [StreamController] and adding it
       |/// to the sink using [Sink.addStream] when the destination sink is ready. This
       |/// class attempts to shortcut some of the overhead when possible. For example,
       |/// if the [sink] only has events added after the destination sink has been set,
       |/// those events are added directly to the sink.
       |class StreamSinkCompleter<T> {
       |  /// The sink for this completer.
       |  ///
       |  /// When a destination sink is provided, events that have been passed to the
       |  /// sink will be forwarded to the destination.
       |  ///
       |  /// Events can be added to the sink either before or after a destination sink
       |  /// is set.
       |  final StreamSink<T> sink = new _CompleterSink<T>();
       |
       |  /// Returns [sink] typed as a [_CompleterSink].
      0|  _CompleterSink<T> get _sink => sink;
       |
       |  /// Convert a `Future<StreamSink>` to a `StreamSink`.
       |  ///
       |  /// This creates a sink using a sink completer, and sets the destination sink
       |  /// to the result of the future when the future completes.
       |  ///
       |  /// If the future completes with an error, the returned sink will instead
       |  /// be closed. Its [Sink.done] future will contain the error.
       |  static StreamSink<T> fromFuture<T>(
       |      Future<StreamSink<T>> sinkFuture) {
      0|    var completer = new StreamSinkCompleter<T>();
      0|    sinkFuture.then(completer.setDestinationSink,
      0|        onError: completer.setError);
      0|    return completer.sink;
       |  }
       |
       |  /// Sets a sink as the destination for events from the [StreamSinkCompleter]'s
       |  /// [sink].
       |  ///
       |  /// The completer's [sink] will act exactly as [destinationSink].
       |  ///
       |  /// If the destination sink is set before events are added to [sink], further
       |  /// events are forwarded directly to [destinationSink].
       |  ///
       |  /// If events are added to [sink] before setting the destination sink, they're
       |  /// buffered until the destination is available.
       |  ///
       |  /// A destination sink may be set at most once.
       |  ///
       |  /// Either of [setDestinationSink] or [setError] may be called at most once.
       |  /// Trying to call either of them again will fail.
       |  void setDestinationSink(StreamSink<T> destinationSink) {
      0|    if (_sink._destinationSink != null) {
      0|      throw new StateError("Destination sink already set");
       |    }
      0|    _sink._setDestinationSink(destinationSink);
       |  }
       |
       |  /// Completes this to a closed sink whose [Sink.done] future emits [error].
       |  ///
       |  /// This is useful when the process of loading the sink fails.
       |  ///
       |  /// Either of [setDestinationSink] or [setError] may be called at most once.
       |  /// Trying to call either of them again will fail.
       |  void setError(error, [StackTrace stackTrace]) {
      0|    setDestinationSink(new NullStreamSink.error(error, stackTrace));
       |  }
       |}
       |
       |/// [StreamSink] completed by [StreamSinkCompleter].
       |class _CompleterSink<T> implements StreamSink<T> {
       |  /// Controller for an intermediate sink.
       |  ///
       |  /// Created if the user adds events to this sink before the destination sink
       |  /// is set.
       |  StreamController<T> _controller;
       |
       |  /// Completer for [done].
       |  ///
       |  /// Created if the user requests the [done] future before the destination sink
       |  /// is set.
       |  Completer _doneCompleter;
       |
       |  /// Destination sink for the events added to this sink.
       |  ///
       |  /// Set when [StreamSinkCompleter.setDestinationSink] is called.
       |  StreamSink<T> _destinationSink;
       |
       |  /// Whether events should be sent directly to [_destinationSink], as opposed
       |  /// to going through [_controller].
      0|  bool get _canSendDirectly => _controller == null && _destinationSink != null;
       |
       |  Future get done {
      0|    if (_doneCompleter != null) return _doneCompleter.future;
      0|    if (_destinationSink == null) {
      0|      _doneCompleter = new Completer.sync();
      0|      return _doneCompleter.future;
       |    }
      0|    return _destinationSink.done;
       |  }
       |
       |  void add(T event) {
      0|    if (_canSendDirectly) {
      0|      _destinationSink.add(event);
       |    } else {
      0|      _ensureController();
      0|      _controller.add(event);
       |    }
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_canSendDirectly) {
      0|      _destinationSink.addError(error, stackTrace);
       |    } else {
      0|      _ensureController();
      0|      _controller.addError(error, stackTrace);
       |    }
       |  }
       |
       |  Future addStream(Stream<T> stream) {
      0|    if (_canSendDirectly) return _destinationSink.addStream(stream);
       |
      0|    _ensureController();
      0|    return _controller.addStream(stream, cancelOnError: false);
       |  }
       |
       |  Future close() {
      0|    if (_canSendDirectly) {
      0|      _destinationSink.close();
       |    } else {
      0|      _ensureController();
      0|      _controller.close();
       |    }
      0|    return done;
       |  }
       |
       |  /// Create [_controller] if it doesn't yet exist.
       |  void _ensureController() {
      0|    if (_controller == null) _controller = new StreamController(sync: true);
       |  }
       |
       |  /// Sets the destination sink to which events from this sink will be provided.
       |  ///
       |  /// If set before the user adds events, events will be added directly to the
       |  /// destination sink. If the user adds events earlier, an intermediate sink is
       |  /// created using a stream controller, and the destination sink is linked to
       |  /// it later.
       |  void _setDestinationSink(StreamSink<T> sink) {
       |    assert(_destinationSink == null);
      0|    _destinationSink = sink;
       |
       |    // If the user has already added data, it's buffered in the controller, so
       |    // we add it to the sink.
      0|    if (_controller != null) {
       |      // Catch any error that may come from [addStream] or [sink.close]. They'll
       |      // be reported through [done] anyway.
       |      sink
      0|          .addStream(_controller.stream)
      0|          .whenComplete(sink.close)
      0|          .catchError((_) {});
       |    }
       |
       |    // If the user has already asked when the sink is done, connect the sink's
       |    // done callback to that completer.
      0|    if (_doneCompleter != null) {
      0|      _doneCompleter.complete(sink.done);
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_sink_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'stream_sink_transformer/handler_transformer.dart';
       |import 'stream_sink_transformer/stream_transformer_wrapper.dart';
       |import 'stream_sink_transformer/typed.dart';
       |
       |/// A [StreamSinkTransformer] transforms the events being passed to a sink.
       |///
       |/// This works on the same principle as a [StreamTransformer]. Each transformer
       |/// defines a [bind] method that takes in the original [StreamSink] and returns
       |/// the transformed version. However, where a [StreamTransformer] transforms
       |/// events after they leave the stream, this transforms them before they enter
       |/// the sink.
       |///
       |/// Transformers must be able to have `bind` called used multiple times.
       |abstract class StreamSinkTransformer<S, T> {
       |  /// Creates a [StreamSinkTransformer] that transforms events and errors
       |  /// using [transformer].
       |  ///
       |  /// This is equivalent to piping all events from the outer sink through a
       |  /// stream transformed by [transformer] and from there into the inner sink.
       |  const factory StreamSinkTransformer.fromStreamTransformer(
       |          StreamTransformer<S, T> transformer) =
       |      StreamTransformerWrapper<S, T>;
       |
       |  /// Creates a [StreamSinkTransformer] that delegates events to the given
       |  /// handlers.
       |  ///
       |  /// The handlers work exactly as they do for [StreamTransformer.fromHandlers].
       |  /// They're called for each incoming event, and any actions on the sink
       |  /// they're passed are forwarded to the inner sink. If a handler is omitted,
       |  /// the event is passed through unaltered.
       |  factory StreamSinkTransformer.fromHandlers({
       |      void handleData(S data, EventSink<T> sink),
       |      void handleError(Object error, StackTrace stackTrace, EventSink<T> sink),
       |      void handleDone(EventSink<T> sink)}) {
      0|    return new HandlerTransformer<S, T>(handleData, handleError, handleDone);
       |  }
       |
       |  /// Transforms the events passed to [sink].
       |  ///
       |  /// Creates a new sink. When events are passed to the returned sink, it will
       |  /// transform them and pass the transformed versions to [sink].
       |  StreamSink<S> bind(StreamSink<T> sink);
       |
       |  /// Creates a wrapper that coerces the type of [transformer].
       |  ///
       |  /// This soundly converts a [StreamSinkTransformer] to a
       |  /// `StreamSinkTransformer<S, T>`, regardless of its original generic type.
       |  /// This means that calls to [StreamSink.add] on the returned sink may throw a
       |  /// [CastError] if the argument type doesn't match the reified type of the
       |  /// sink.
       |  static StreamSinkTransformer<S, T> typed<S, T>(
       |          StreamSinkTransformer transformer) =>
      0|      transformer is StreamSinkTransformer<S, T>
       |          ? transformer
      0|          : new TypeSafeStreamSinkTransformer(transformer);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_splitter.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'future_group.dart';
       |import 'result.dart';
       |
       |/// A class that splits a single source stream into an arbitrary number of
       |/// (single-subscription) streams (called "branch") that emit the same events.
       |///
       |/// Each branch will emit all the same values and errors as the source stream,
       |/// regardless of which values have been emitted on other branches. This means
       |/// that the splitter stores every event that has been emitted so far, which may
       |/// consume a lot of memory. The user can call [close] to indicate that no more
       |/// branches will be created, and this memory will be released.
       |///
       |/// The source stream is only listened to once a branch is created *and listened
       |/// to*. It's paused when all branches are paused *or when all branches are
       |/// canceled*, and resumed once there's at least one branch that's listening and
       |/// unpaused. It's not canceled unless no branches are listening and [close] has
       |/// been called.
       |class StreamSplitter<T> {
       |  /// The wrapped stream.
       |  final Stream<T> _stream;
       |
       |  /// The subscription to [_stream].
       |  ///
       |  /// This will be `null` until a branch has a listener.
       |  StreamSubscription<T> _subscription;
       |
       |  /// The buffer of events or errors that have already been emitted by
       |  /// [_stream].
       |  final _buffer = new List<Result<T>>();
       |
       |  /// The controllers for branches that are listening for future events from
       |  /// [_stream].
       |  ///
       |  /// Once a branch is canceled, it's removed from this list. When [_stream] is
       |  /// done, all branches are removed.
       |  final _controllers = new Set<StreamController<T>>();
       |
       |  /// A group of futures returned by [close].
       |  ///
       |  /// This is used to ensure that [close] doesn't complete until all
       |  /// [StreamController.close] and [StreamSubscription.cancel] calls complete.
       |  final _closeGroup = new FutureGroup();
       |
       |  /// Whether [_stream] is done emitting events.
       |  var _isDone = false;
       |
       |  /// Whether [close] has been called.
       |  var _isClosed = false;
       |
       |  /// Splits [stream] into [count] identical streams.
       |  ///
       |  /// [count] defaults to 2. This is the same as creating [count] branches and
       |  /// then closing the [StreamSplitter].
       |  static List<Stream<T>> splitFrom<T>(Stream<T> stream,
       |      [int count]) {
       |    if (count == null) count = 2;
      0|    var splitter = new StreamSplitter<T>(stream);
      0|    var streams = new List<Stream>.generate(count, (_) => splitter.split());
      0|    splitter.close();
       |    return streams;
       |  }
       |
      0|  StreamSplitter(this._stream);
       |
       |  /// Returns a single-subscription stream that's a copy of the input stream.
       |  ///
       |  /// This will throw a [StateError] if [close] has been called.
       |  Stream<T> split() {
      0|    if (_isClosed) {
      0|      throw new StateError("Can't call split() on a closed StreamSplitter.");
       |    }
       |
      0|    var controller = new StreamController<T>(
      0|        onListen: _onListen,
      0|        onPause: _onPause,
      0|        onResume: _onResume);
      0|    controller.onCancel = () => _onCancel(controller);
       |
      0|    for (var result in _buffer) {
      0|      result.addTo(controller);
       |    }
       |
      0|    if (_isDone) {
      0|      _closeGroup.add(controller.close());
       |    } else {
      0|      _controllers.add(controller);
       |    }
       |
      0|    return controller.stream;
       |  }
       |
       |  /// Indicates that no more branches will be requested via [split].
       |  ///
       |  /// This clears the internal buffer of events. If there are no branches or all
       |  /// branches have been canceled, this cancels the subscription to the input
       |  /// stream.
       |  ///
       |  /// Returns a [Future] that completes once all events have been processed by
       |  /// all branches and (if applicable) the subscription to the input stream has
       |  /// been canceled.
       |  Future close() {
      0|    if (_isClosed) return _closeGroup.future;
      0|    _isClosed = true;
       |
      0|    _buffer.clear();
      0|    if (_controllers.isEmpty) _cancelSubscription();
       |
      0|    return _closeGroup.future;
       |  }
       |
       |  /// Cancel [_subscription] and close [_closeGroup].
       |  ///
       |  /// This should be called after all the branches' subscriptions have been
       |  /// canceled and the splitter has been closed. In that case, we won't use the
       |  /// events from [_subscription] any more, since there's nothing to pipe them
       |  /// to and no more branches will be created. If [_subscription] is done,
       |  /// canceling it will be a no-op.
       |  ///
       |  /// This may also be called before any branches have been created, in which
       |  /// case [_subscription] will be `null`.
       |  void _cancelSubscription() {
       |    assert(_controllers.isEmpty);
       |    assert(_isClosed);
       |
       |    var future = null;
      0|    if (_subscription != null) future = _subscription.cancel();
      0|    if (future != null) _closeGroup.add(future);
      0|    _closeGroup.close();
       |  }
       |
       |  // StreamController events
       |
       |  /// Subscribe to [_stream] if we haven't yet done so, and resume the
       |  /// subscription if we have.
       |  void _onListen() {
      0|    if (_isDone) return;
       |
      0|    if (_subscription != null) {
       |      // Resume the subscription in case it was paused, either because all the
       |      // controllers were paused or because the last one was canceled. If it
       |      // wasn't paused, this will be a no-op.
      0|      _subscription.resume();
       |    } else {
      0|      _subscription = _stream.listen(
      0|          _onData, onError: _onError, onDone: _onDone);
       |    }
       |  }
       |
       |  /// Pauses [_subscription] if every controller is paused.
       |  void _onPause() {
      0|    if (!_controllers.every((controller) => controller.isPaused)) return;
      0|    _subscription.pause();
       |  }
       |
       |  /// Resumes [_subscription].
       |  ///
       |  /// If [_subscription] wasn't paused, this is a no-op.
       |  void _onResume() {
      0|    _subscription.resume();
       |  }
       |
       |  /// Removes [controller] from [_controllers] and cancels or pauses
       |  /// [_subscription] as appropriate.
       |  ///
       |  /// Since the controller emitting a done event will cause it to register as
       |  /// canceled, this is the only way that a controller is ever removed from
       |  /// [_controllers].
       |  void _onCancel(StreamController controller) {
      0|    _controllers.remove(controller);
      0|    if (_controllers.isNotEmpty) return;
       |
      0|    if (_isClosed) {
      0|      _cancelSubscription();
       |    } else {
      0|      _subscription.pause();
       |    }
       |  }
       |
       |  // Stream events
       |
       |  /// Buffers [data] and passes it to [_controllers].
       |  void _onData(T data) {
      0|    if (!_isClosed) _buffer.add(new Result.value(data));
      0|    for (var controller in _controllers) {
      0|      controller.add(data);
       |    }
       |  }
       |
       |  /// Buffers [error] and passes it to [_controllers].
       |  void _onError(Object error, StackTrace stackTrace) {
      0|    if (!_isClosed) _buffer.add(new Result.error(error, stackTrace));
      0|    for (var controller in _controllers) {
      0|      controller.addError(error, stackTrace);
       |    }
       |  }
       |
       |  /// Marks [_controllers] as done.
       |  void _onDone() {
      0|    _isDone = true;
      0|    for (var controller in _controllers) {
      0|      _closeGroup.add(controller.close());
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_subscription_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'async_memoizer.dart';
       |
       |typedef Future _AsyncHandler<T>(StreamSubscription<T> inner);
       |
       |typedef void _VoidHandler<T>(StreamSubscription<T> inner);
       |
       |/// Creates a [StreamTransformer] that modifies the behavior of subscriptions to
       |/// a stream.
       |///
       |/// When [StreamSubscription.cancel], [StreamSubscription.pause], or
       |/// [StreamSubscription.resume] is called, the corresponding handler is invoked.
       |/// By default, handlers just forward to the underlying subscription.
       |///
       |/// Guarantees that none of the [StreamSubscription] callbacks and none of the
       |/// callbacks passed to `subscriptionTransformer()` will be invoked once the
       |/// transformed [StreamSubscription] has been canceled and `handleCancel()` has
       |/// run. The [handlePause] and [handleResume] are invoked regardless of whether
       |/// the subscription is paused already or not.
       |///
       |/// In order to preserve [StreamSubscription] guarantees, **all callbacks must
       |/// synchronously call the corresponding method** on the inner
       |/// [StreamSubscription]: [handleCancel] must call `cancel()`, [handlePause]
       |/// must call `pause()`, and [handleResume] must call `resume()`.
       |StreamTransformer<T, T> subscriptionTransformer<T>(
       |    {Future handleCancel(StreamSubscription<T> inner),
       |    void handlePause(StreamSubscription<T> inner),
       |    void handleResume(StreamSubscription<T> inner)}) {
      0|  return new StreamTransformer((stream, cancelOnError) {
      0|    return new _TransformedSubscription(
      0|        stream.listen(null, cancelOnError: cancelOnError),
      0|        handleCancel ?? (inner) => inner.cancel(),
       |        handlePause ?? (inner) {
      0|          inner.pause();
       |        },
       |        handleResume ?? (inner) {
      0|          inner.resume();
       |        });
       |  });
       |}
       |
       |/// A [StreamSubscription] wrapper that calls callbacks for subscription
       |/// methods.
       |class _TransformedSubscription<T> implements StreamSubscription<T> {
       |  /// The wrapped subscription.
       |  StreamSubscription<T> _inner;
       |
       |  /// The callback to run when [cancel] is called.
       |  final _AsyncHandler<T> _handleCancel;
       |
       |  /// The callback to run when [pause] is called.
       |  final _VoidHandler<T> _handlePause;
       |
       |  /// The callback to run when [resume] is called.
       |  final _VoidHandler<T> _handleResume;
       |
      0|  bool get isPaused => _inner?.isPaused ?? false;
       |
       |  _TransformedSubscription(this._inner, this._handleCancel, this._handlePause,
      0|      this._handleResume);
       |
       |  void onData(void handleData(T data)) {
      0|    _inner?.onData(handleData);
       |  }
       |
       |  void onError(Function handleError) {
      0|    _inner?.onError(handleError);
       |  }
       |
       |  void onDone(void handleDone()) {
      0|    _inner?.onDone(handleDone);
       |  }
       |
      0|  Future cancel() => _cancelMemoizer.runOnce(() {
      0|    var inner = _inner;
      0|    _inner.onData(null);
      0|    _inner.onDone(null);
       |
       |    // Setting onError to null will cause errors to be top-leveled.
      0|    _inner.onError((_, __) {});
      0|    _inner = null;
      0|    return _handleCancel(inner);
       |  });
       |  final _cancelMemoizer = new AsyncMemoizer();
       |
       |  void pause([Future resumeFuture]) {
      0|    if (_cancelMemoizer.hasRun) return;
      0|    if (resumeFuture != null) resumeFuture.whenComplete(resume);
      0|    _handlePause(_inner);
       |  }
       |
       |  void resume() {
      0|    if (_cancelMemoizer.hasRun) return;
      0|    _handleResume(_inner);
       |  }
       |
       |  Future<E> asFuture<E>([E futureValue]) =>
      0|      _inner?.asFuture(futureValue) ?? new Completer<E>().future;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_zip.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:async";
       |
       |/// A stream that combines the values of other streams.
       |///
       |/// This emits lists of collected values from each input stream. The first list
       |/// contains the first value emitted by each stream, the second contains the
       |/// second value, and so on. The lists have the same ordering as the iterable
       |/// passed to [new StreamZip].
       |///
       |/// Any errors from any of the streams are forwarded directly to this stream.
       |class StreamZip<T> extends Stream<List<T>> {
       |  final Iterable<Stream<T>> _streams;
       |
      0|  StreamZip(Iterable<Stream<T>> streams) : _streams = streams;
       |
       |  StreamSubscription<List<T>> listen(void onData(List<T> data), {
       |                                  Function onError,
       |                                  void onDone(),
       |                                  bool cancelOnError}) {
       |    cancelOnError = identical(true, cancelOnError);
      0|    var subscriptions = <StreamSubscription<T>>[];
       |    StreamController<List<T>> controller;
       |    List<T> current;
       |    int dataCount = 0;
       |
       |    /// Called for each data from a subscription in [subscriptions].
       |    void handleData(int index, T data) {
      0|      current[index] = data;
      0|      dataCount++;
      0|      if (dataCount == subscriptions.length) {
       |        var data = current;
      0|        current = new List(subscriptions.length);
       |        dataCount = 0;
      0|        for (int i = 0; i < subscriptions.length; i++) {
      0|          if (i != index) subscriptions[i].resume();
       |        }
      0|        controller.add(data);
       |      } else {
      0|        subscriptions[index].pause();
       |      }
       |    }
       |
       |    /// Called for each error from a subscription in [subscriptions].
       |    /// Except if [cancelOnError] is true, in which case the function below
       |    /// is used instead.
       |    void handleError(Object error, StackTrace stackTrace) {
      0|      controller.addError(error, stackTrace);
       |    }
       |
       |    /// Called when a subscription has an error and [cancelOnError] is true.
       |    ///
       |    /// Prematurely cancels all subscriptions since we know that we won't
       |    /// be needing any more values.
       |    void handleErrorCancel(Object error, StackTrace stackTrace) {
      0|      for (int i = 0; i < subscriptions.length; i++) {
      0|        subscriptions[i].cancel();
       |      }
      0|      controller.addError(error, stackTrace);
       |    }
       |
       |    void handleDone() {
      0|      for (int i = 0; i < subscriptions.length; i++) {
      0|        subscriptions[i].cancel();
       |      }
      0|      controller.close();
       |    }
       |
       |    try {
      0|      for (var stream in _streams) {
      0|        int index = subscriptions.length;
      0|        subscriptions.add(stream.listen(
      0|            (data) { handleData(index, data); },
       |            onError: cancelOnError ? handleError : handleErrorCancel,
       |            onDone: handleDone,
       |            cancelOnError: cancelOnError));
       |      }
       |    } catch (e) {
      0|      for (int i = subscriptions.length - 1; i >= 0; i--) {
      0|        subscriptions[i].cancel();
       |      }
       |      rethrow;
       |    }
       |
      0|    current = new List(subscriptions.length);
       |
      0|    controller = new StreamController<List<T>>(
       |      onPause: () {
      0|        for (int i = 0; i < subscriptions.length; i++) {
       |          // This may pause some subscriptions more than once.
       |          // These will not be resumed by onResume below, but must wait for the
       |          // next round.
      0|          subscriptions[i].pause();
       |        }
       |      },
       |      onResume: () {
      0|        for (int i = 0; i < subscriptions.length; i++) {
      0|          subscriptions[i].resume();
       |        }
       |      },
       |      onCancel: () {
      0|        for (int i = 0; i < subscriptions.length; i++) {
       |          // Canceling more than once is safe.
      0|          subscriptions[i].cancel();
       |        }
       |      }
       |    );
       |
      0|    if (subscriptions.isEmpty) {
      0|      controller.close();
       |    }
      0|    return controller.stream.listen(onData,
       |                                    onError: onError,
       |                                    onDone: onDone,
       |                                    cancelOnError: cancelOnError);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/subscription_stream.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import "delegate/stream_subscription.dart";
       |
       |/// A [Stream] adapter for a [StreamSubscription].
       |///
       |/// This class allows a `StreamSubscription` to be treated as a `Stream`.
       |///
       |/// The subscription is paused until the stream is listened to,
       |/// then it is resumed and the events are passed on to the
       |/// stream's new subscription.
       |///
       |/// This class assumes that is has control over the original subscription.
       |/// If other code is accessing the subscription, results may be unpredictable.
       |class SubscriptionStream<T> extends Stream<T> {
       |  /// The subscription providing the events for this stream.
       |  StreamSubscription<T> _source;
       |
       |  /// Create a single-subscription `Stream` from [subscription].
       |  ///
       |  /// The `subscription` should not be paused. This class will not resume prior
       |  /// pauses, so being paused is indistinguishable from not providing any
       |  /// events.
       |  ///
       |  /// If the `subscription` doesn't send any `done` events, neither will this
       |  /// stream. That may be an issue if `subscription` was made to cancel on
       |  /// an error.
       |  SubscriptionStream(StreamSubscription<T> subscription)
      0|       : _source = subscription {
      0|    _source.pause();
       |    // Clear callbacks to avoid keeping them alive unnecessarily.
      0|    _source.onData(null);
      0|    _source.onError(null);
      0|    _source.onDone(null);
       |  }
       |
       |  StreamSubscription<T> listen(void onData(T event),
       |                               {Function onError,
       |                                void onDone(),
       |                                bool cancelOnError}) {
      0|    if (_source == null) {
      0|      throw new StateError("Stream has already been listened to.");
       |    }
      0|    cancelOnError = (true == cancelOnError);
      0|    var subscription = _source;
      0|    _source = null;
       |
       |    var result = cancelOnError
      0|        ? new _CancelOnErrorSubscriptionWrapper<T>(subscription)
       |        : subscription;
      0|    result.onData(onData);
      0|    result.onError(onError);
      0|    result.onDone(onDone);
      0|    subscription.resume();
       |    return result;
       |  }
       |}
       |
       |/// Subscription wrapper that cancels on error.
       |///
       |/// Used by [SubscriptionStream] when forwarding a subscription
       |/// created with `cancelOnError` as `true` to one with (assumed)
       |/// `cancelOnError` as `false`. It automatically cancels the
       |/// source subscription on the first error.
       |class _CancelOnErrorSubscriptionWrapper<T>
       |    extends DelegatingStreamSubscription<T> {
       |  _CancelOnErrorSubscriptionWrapper(StreamSubscription<T> subscription)
      0|      : super(subscription);
       |
       |  void onError(Function handleError) {
       |    // Cancel when receiving an error.
      0|    super.onError((error, StackTrace stackTrace) {
      0|      var cancelFuture = super.cancel();
       |      if (cancelFuture != null) {
       |        // Wait for the cancel to complete before sending the error event.
      0|        cancelFuture.whenComplete(() {
      0|          if (handleError is ZoneBinaryCallback) {
      0|            handleError(error, stackTrace);
       |          } else {
      0|            handleError(error);
       |          }
       |        });
       |      } else {
      0|        if (handleError is ZoneBinaryCallback) {
      0|          handleError(error, stackTrace);
       |        } else {
      0|          handleError(error);
       |        }
       |      }
       |    });
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/typed_stream_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'delegate/stream.dart';
       |
       |/// Creates a wrapper that coerces the type of [transformer].
       |///
       |/// This soundly converts a [StreamTransformer] to a `StreamTransformer<S, T>`,
       |/// regardless of its original generic type, by asserting that the events
       |/// emitted by the transformed stream are instances of `T` whenever they're
       |/// provided. If they're not, the stream throws a [CastError].
       |StreamTransformer<S, T> typedStreamTransformer<S, T>(
       |        StreamTransformer transformer) =>
      0|    transformer is StreamTransformer<S, T>
       |        ? transformer
      0|        : new _TypeSafeStreamTransformer(transformer);
       |
       |/// A wrapper that coerces the type of the stream returned by an inner
       |/// transformer.
       |class _TypeSafeStreamTransformer<S, T> implements StreamTransformer<S, T> {
       |  final StreamTransformer _inner;
       |
      0|  _TypeSafeStreamTransformer(this._inner);
       |
       |  Stream<T> bind(Stream<S> stream) =>
      0|      DelegatingStream.typed(_inner.bind(stream));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/test-0.12.20+10/lib/src/util/forkable_stream.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// TODO(nweiz): Get rid of this when https://codereview.chromium.org/1241723003/
       |// lands.
       |import 'dart:async';
       |
       |import 'package:async/async.dart' hide ForkableStream;
       |
       |/// A single-subscription stream from which other streams may be forked off at
       |/// the current position.
       |///
       |/// This adds an operation, [fork], which produces a new stream that
       |/// independently emits the same events as this stream. Unlike the branches
       |/// produced by [StreamSplitter], a fork only emits events that arrive *after*
       |/// the call to [fork].
       |///
       |/// Each fork can be paused or canceled independently of one another and of this
       |/// stream. The underlying stream will be listened to once any branch is
       |/// listened to. It will be paused when all branches are paused or not yet
       |/// listened to. It will be canceled when all branches have been listened to and
       |/// then canceled.
       |class ForkableStream<T> extends StreamView<T> {
       |  /// The underlying stream.
       |  final Stream<T> _sourceStream;
       |
       |  /// The subscription to [_sourceStream].
       |  ///
       |  /// This will be `null` until this stream or any of its forks are listened to.
       |  StreamSubscription _subscription;
       |
       |  /// Whether this has been cancelled and no more forks may be created.
       |  bool _isCanceled = false;
       |
       |  /// The controllers for any branches that have not yet been canceled.
       |  ///
       |  /// This includes a controller for this stream, until that has been cancelled.
       |  final _controllers = new Set<StreamController<T>>();
       |
       |  /// Creates a new forkable stream wrapping [sourceStream].
       |  ForkableStream(Stream<T> sourceStream)
       |      // Use a completer here so that we can provide its stream to the
       |      // superclass constructor while also adding the stream controller to
       |      // [_controllers].
      0|      : this._(sourceStream, new StreamCompleter<T>());
       |
       |  ForkableStream._(this._sourceStream, StreamCompleter<T> completer)
      0|      : super(completer.stream) {
      0|    completer.setSourceStream(_fork(primary: true));
       |  }
       |
       |  /// Creates a new fork of this stream.
       |  ///
       |  /// From this point forward, the fork will emit the same events as this
       |  /// stream. It will *not* emit any events that have already been emitted by
       |  /// this stream. The fork is independent of this stream, which means each one
       |  /// may be paused or canceled without affecting the other.
       |  ///
       |  /// If this stream is done or its subscription has been canceled, this returns
       |  /// an empty stream.
      0|  Stream<T> fork() => _fork(primary: false);
       |
       |  /// Creates a stream forwarding [_sourceStream].
       |  ///
       |  /// If [primary] is true, this is the stream underlying this object;
       |  /// otherwise, it's a fork. The only difference is that when the primary
       |  /// stream is canceled, [fork] starts throwing [StateError]s.
       |  Stream<T> _fork({bool primary: false}) {
      0|    if (_isCanceled) {
      0|      var controller = new StreamController<T>()..close();
      0|      return controller.stream;
       |    }
       |
       |    StreamController<T> controller;
      0|    controller = new StreamController<T>(
      0|        onListen: () => _onListenOrResume(controller),
      0|        onCancel: () => _onCancel(controller, primary: primary),
      0|        onPause: () => _onPause(controller),
      0|        onResume: () => _onListenOrResume(controller),
       |        sync: true);
       |
      0|    _controllers.add(controller);
       |
      0|    return controller.stream;
       |  }
       |
       |  /// The callback called when `onListen` or `onResume` is called for the branch
       |  /// managed by [controller].
       |  ///
       |  /// This ensures that we're subscribed to [_sourceStream] and that the
       |  /// subscription isn't paused.
       |  void _onListenOrResume(StreamController<T> controller) {
      0|    if (controller.isClosed) return;
      0|    if (_subscription == null) {
      0|      _subscription =
      0|          _sourceStream.listen(_onData, onError: _onError, onDone: _onDone);
       |    } else {
      0|      _subscription.resume();
       |    }
       |  }
       |
       |  /// The callback called when `onCancel` is called for the branch managed by
       |  /// [controller].
       |  ///
       |  /// This cancels or pauses the underlying subscription as necessary. If
       |  /// [primary] is true, it also ensures that future calls to [fork] throw
       |  /// [StateError]s.
       |  Future _onCancel(StreamController<T> controller, {bool primary: false}) {
      0|    if (primary) _isCanceled = true;
       |
      0|    if (controller.isClosed) return null;
      0|    _controllers.remove(controller);
       |
      0|    if (_controllers.isEmpty) return _subscription.cancel();
       |
      0|    _onPause(controller);
       |    return null;
       |  }
       |
       |  /// The callback called when `onPause` is called for the branch managed by
       |  /// [controller].
       |  ///
       |  /// This pauses the underlying subscription if necessary.
       |  void _onPause(StreamController<T> controller) {
      0|    if (controller.isClosed) return;
      0|    if (_subscription.isPaused) return;
      0|    if (_controllers
      0|        .any((controller) => controller.hasListener && !controller.isPaused)) {
       |      return;
       |    }
       |
      0|    _subscription.pause();
       |  }
       |
       |  /// Forwards data events to all branches.
       |  void _onData(T value) {
       |    // Don't iterate directly over the set because [controller.add] might cause
       |    // it to be modified synchronously.
      0|    for (var controller in _controllers.toList()) {
      0|      controller.add(value);
       |    }
       |  }
       |
       |  /// Forwards error events to all branches.
       |  void _onError(error, StackTrace stackTrace) {
       |    // Don't iterate directly over the set because [controller.addError] might
       |    // cause it to be modified synchronously.
      0|    for (var controller in _controllers.toList()) {
      0|      controller.addError(error, stackTrace);
       |    }
       |  }
       |
       |  /// Forwards close events to all branches.
       |  void _onDone() {
      0|    _isCanceled = true;
       |
       |    // Don't iterate directly over the set because [controller.close] might
       |    // cause it to be modified synchronously.
      0|    for (var controller in _controllers.toList()) {
      0|      controller.close();
       |    }
      0|    _controllers.clear();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/algorithms.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:math" as math;
       |
       |import "utils.dart";
       |
       |/// Returns a position of the [value] in [sortedList], if it is there.
       |///
       |/// If the list isn't sorted according to the [compare] function, the result
       |/// is unpredictable.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [CastError].
       |///
       |/// Returns -1 if [value] is not in the list by default.
       |int binarySearch/*<T>*/(List/*<T>*/ sortedList, /*=T*/ value,
       |    {int compare(/*=T*/ a, /*=T*/ b)}) {
      0|  compare ??= defaultCompare/*<T>*/();
       |  int min = 0;
      0|  int max = sortedList.length;
      0|  while (min < max) {
      0|    int mid = min + ((max - min) >> 1);
      0|    var element = sortedList[mid];
      0|    int comp = compare(element, value);
      0|    if (comp == 0) return mid;
      0|    if (comp < 0) {
      0|      min = mid + 1;
       |    } else {
       |      max = mid;
       |    }
       |  }
       |  return -1;
       |}
       |
       |/// Returns the first position in [sortedList] that does not compare less than
       |/// [value].
       |///
       |/// If the list isn't sorted according to the [compare] function, the result
       |/// is unpredictable.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [CastError].
       |///
       |/// Returns [sortedList.length] if all the items in [sortedList] compare less
       |/// than [value].
       |int lowerBound/*<T>*/(List/*<T>*/ sortedList, /*=T*/ value,
       |    {int compare(/*=T*/ a, /*=T*/ b)}) {
      0|  compare ??= defaultCompare/*<T>*/();
       |  int min = 0;
      0|  int max = sortedList.length;
      0|  while (min < max) {
      0|    int mid = min + ((max - min) >> 1);
      0|    var element = sortedList[mid];
      0|    int comp = compare(element, value);
      0|    if (comp < 0) {
      0|      min = mid + 1;
       |    } else {
       |      max = mid;
       |    }
       |  }
       |  return min;
       |}
       |
       |/// Shuffles a list randomly.
       |///
       |/// A sub-range of a list can be shuffled by providing [start] and [end].
       |void shuffle(List list, [int start = 0, int end = null]) {
      0|  var random = new math.Random();
      0|  if (end == null) end = list.length;
      0|  int length = end - start;
      0|  while (length > 1) {
      0|    int pos = random.nextInt(length);
      0|    length--;
      0|    var tmp1 = list[start + pos];
      0|    list[start + pos] = list[start + length];
      0|    list[start + length] = tmp1;
       |  }
       |}
       |
       |
       |/// Reverses a list, or a part of a list, in-place.
       |void reverse(List list, [int start = 0, int end = null]) {
      0|  if (end == null) end = list.length;
      0|  _reverse(list, start, end);
       |}
       |
       |/// Internal helper function that assumes valid arguments.
       |void _reverse(List list, int start, int end) {
      0|  for (int i = start, j = end - 1; i < j; i++, j--) {
      0|    var tmp = list[i];
      0|    list[i] = list[j];
      0|    list[j] = tmp;
       |  }
       |}
       |
       |/// Sort a list between [start] (inclusive) and [end] (exclusive) using
       |/// insertion sort.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [CastError].
       |///
       |/// Insertion sort is a simple sorting algorithm. For `n` elements it does on
       |/// the order of `n * log(n)` comparisons but up to `n` squared moves. The
       |/// sorting is performed in-place, without using extra memory.
       |///
       |/// For short lists the many moves have less impact than the simple algorithm,
       |/// and it is often the favored sorting algorithm for short lists.
       |///
       |/// This insertion sort is stable: Equal elements end up in the same order
       |/// as they started in.
       |void insertionSort/*<T>*/(List/*<T>*/ list, {int compare(/*=T*/ a, /*=T*/ b),
       |    int start: 0, int end}) {
       |  // If the same method could have both positional and named optional
       |  // parameters, this should be (list, [start, end], {compare}).
      0|  compare ??= defaultCompare/*<T>*/();
      0|  end ??= list.length;
       |
      0|  for (int pos = start + 1; pos < end; pos++) {
       |    int min = start;
       |    int max = pos;
      0|    var element = list[pos];
      0|    while (min < max) {
      0|      int mid = min + ((max - min) >> 1);
      0|      int comparison = compare(element, list[mid]);
      0|      if (comparison < 0) {
       |        max = mid;
       |      } else {
      0|        min = mid + 1;
       |      }
       |    }
      0|    list.setRange(min + 1, pos + 1, list, min);
      0|    list[min] = element;
       |  }
       |}
       |
       |/// Limit below which merge sort defaults to insertion sort.
       |const int _MERGE_SORT_LIMIT = 32;
       |
       |/// Sorts a list between [start] (inclusive) and [end] (exclusive) using the
       |/// merge sort algorithm.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [CastError].
       |///
       |/// Merge-sorting works by splitting the job into two parts, sorting each
       |/// recursively, and then merging the two sorted parts.
       |///
       |/// This takes on the order of `n * log(n)` comparisons and moves to sort
       |/// `n` elements, but requires extra space of about the same size as the list
       |/// being sorted.
       |///
       |/// This merge sort is stable: Equal elements end up in the same order
       |/// as they started in.
       |void mergeSort/*<T>*/(List/*<T>*/ list, {int start: 0, int end,
       |    int compare(/*=T*/ a, /*=T*/ b)}) {
      0|  end ??= list.length;
      0|  compare ??= defaultCompare/*<T>*/();
       |
      0|  int length = end - start;
      0|  if (length < 2) return;
      0|  if (length < _MERGE_SORT_LIMIT) {
      0|    insertionSort(list, compare: compare, start: start, end: end);
       |    return;
       |  }
       |  // Special case the first split instead of directly calling
       |  // _mergeSort, because the _mergeSort requires its target to
       |  // be different from its source, and it requires extra space
       |  // of the same size as the list to sort.
       |  // This split allows us to have only half as much extra space,
       |  // and it ends up in the original place.
      0|  int middle = start + ((end - start) >> 1);
      0|  int firstLength = middle - start;
      0|  int secondLength = end - middle;
       |  // secondLength is always the same as firstLength, or one greater.
      0|  var scratchSpace = new List/*<T>*/(secondLength);
      0|  _mergeSort(list, compare, middle, end, scratchSpace, 0);
      0|  int firstTarget = end - firstLength;
      0|  _mergeSort(list, compare, start, middle, list, firstTarget);
      0|  _merge(compare,
       |         list, firstTarget, end,
       |         scratchSpace, 0, secondLength,
       |         list, start);
       |}
       |
       |/// Performs an insertion sort into a potentially different list than the
       |/// one containing the original values.
       |///
       |/// It will work in-place as well.
       |void _movingInsertionSort/*<T>*/(List/*<T>*/ list,
       |    int compare(/*=T*/ a, /*=T*/ b), int start, int end, List/*<T>*/ target,
       |    int targetOffset) {
      0|  int length = end - start;
      0|  if (length == 0) return;
      0|  target[targetOffset] = list[start];
      0|  for (int i = 1; i < length; i++) {
      0|    var element = list[start + i];
       |    int min = targetOffset;
      0|    int max = targetOffset + i;
      0|    while (min < max) {
      0|      int mid = min + ((max - min) >> 1);
      0|      if (compare(element, target[mid]) < 0) {
       |        max = mid;
       |      } else {
      0|        min = mid + 1;
       |      }
       |    }
      0|    target.setRange(min + 1, targetOffset + i + 1,
       |                    target, min);
      0|    target[min] = element;
       |  }
       |}
       |
       |/// Sorts [list] from [start] to [end] into [target] at [targetOffset].
       |///
       |/// The `target` list must be able to contain the range from `start` to `end`
       |/// after `targetOffset`.
       |///
       |/// Allows target to be the same list as [list], as long as it's not
       |/// overlapping the `start..end` range.
       |void _mergeSort/*<T>*/(List/*<T>*/ list, int compare(/*=T*/ a, /*=T*/ b),
       |    int start, int end, List/*<T>*/ target, int targetOffset) {
      0|  int length = end - start;
      0|  if (length < _MERGE_SORT_LIMIT) {
      0|    _movingInsertionSort(list, compare, start, end, target, targetOffset);
       |    return;
       |  }
      0|  int middle = start + (length >> 1);
      0|  int firstLength = middle - start;
      0|  int secondLength = end - middle;
       |  // Here secondLength >= firstLength (differs by at most one).
      0|  int targetMiddle = targetOffset + firstLength;
       |  // Sort the second half into the end of the target area.
      0|  _mergeSort(list, compare, middle, end,
       |             target, targetMiddle);
       |  // Sort the first half into the end of the source area.
      0|  _mergeSort(list, compare, start, middle,
       |             list, middle);
       |  // Merge the two parts into the target area.
      0|  _merge(compare,
      0|         list, middle, middle + firstLength,
      0|         target, targetMiddle, targetMiddle + secondLength,
       |         target, targetOffset);
       |}
       |
       |/// Merges two lists into a target list.
       |///
       |/// One of the input lists may be positioned at the end of the target
       |/// list.
       |///
       |/// For equal object, elements from [firstList] are always preferred.
       |/// This allows the merge to be stable if the first list contains elements
       |/// that started out earlier than the ones in [secondList]
       |void _merge/*<T>*/(int compare(/*=T*/ a, /*=T*/ b),
       |    List/*<T>*/ firstList, int firstStart, int firstEnd,
       |    List/*<T>*/ secondList, int secondStart, int secondEnd,
       |    List/*<T>*/ target, int targetOffset) {
       |  // No empty lists reaches here.
       |  assert(firstStart < firstEnd);
       |  assert(secondStart < secondEnd);
       |  int cursor1 = firstStart;
       |  int cursor2 = secondStart;
      0|  var firstElement = firstList[cursor1++];
      0|  var secondElement = secondList[cursor2++];
       |  while (true) {
      0|    if (compare(firstElement, secondElement) <= 0) {
      0|      target[targetOffset++] = firstElement;
      0|      if (cursor1 == firstEnd) break;  // Flushing second list after loop.
      0|      firstElement = firstList[cursor1++];
       |    } else {
      0|      target[targetOffset++] = secondElement;
      0|      if (cursor2 != secondEnd) {
      0|        secondElement = secondList[cursor2++];
       |        continue;
       |      }
       |      // Second list empties first. Flushing first list here.
      0|      target[targetOffset++] = firstElement;
      0|      target.setRange(targetOffset, targetOffset + (firstEnd - cursor1),
       |          firstList, cursor1);
       |      return;
       |    }
       |  }
       |  // First list empties first. Reached by break above.
      0|  target[targetOffset++] = secondElement;
      0|  target.setRange(targetOffset, targetOffset + (secondEnd - cursor2),
       |      secondList, cursor2);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/canonicalized_map.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'utils.dart';
       |
       |typedef C _Canonicalize<C, K>(K key);
       |
       |typedef bool _IsValidKey(Object key);
       |
       |/// A map whose keys are converted to canonical values of type `C`.
       |///
       |/// This is useful for using case-insensitive String keys, for example. It's
       |/// more efficient than a [LinkedHashMap] with a custom equality operator
       |/// because it only canonicalizes each key once, rather than doing so for each
       |/// comparison.
       |///
       |/// By default, `null` is allowed as a key. It can be forbidden via the
       |/// `isValidKey` parameter.
       |class CanonicalizedMap<C, K, V> implements Map<K, V> {
       |  final _Canonicalize<C, K> _canonicalize;
       |
       |  final _IsValidKey _isValidKeyFn;
       |
       |  final _base = new Map<C, Pair<K, V>>();
       |
       |  /// Creates an empty canonicalized map.
       |  ///
       |  /// The [canonicalize] function should return the canonical value for the
       |  /// given key. Keys with the same canonical value are considered equivalent.
       |  ///
       |  /// The [isValidKey] function is called before calling [canonicalize] for
       |  /// methods that take arbitrary objects. It can be used to filter out keys
       |  /// that can't be canonicalized.
       |  CanonicalizedMap(C canonicalize(K key), {bool isValidKey(Object key)})
       |      : _canonicalize = canonicalize,
      0|        _isValidKeyFn = isValidKey;
       |
       |  /// Creates a canonicalized map that is initialized with the key/value pairs
       |  /// of [other].
       |  ///
       |  /// The [canonicalize] function should return the canonical value for the
       |  /// given key. Keys with the same canonical value are considered equivalent.
       |  ///
       |  /// The [isValidKey] function is called before calling [canonicalize] for
       |  /// methods that take arbitrary objects. It can be used to filter out keys
       |  /// that can't be canonicalized.
       |  CanonicalizedMap.from(Map<K, V> other, C canonicalize(K key),
       |                        {bool isValidKey(Object key)})
       |      : _canonicalize = canonicalize,
      0|        _isValidKeyFn = isValidKey {
      0|    addAll(other);
       |  }
       |
       |  V operator [](Object key) {
      0|    if (!_isValidKey(key)) return null;
      0|    var pair = _base[_canonicalize(key as K)];
      0|    return pair == null ? null : pair.last;
       |  }
       |
       |  void operator []=(K key, V value) {
      0|    if (!_isValidKey(key)) return;
      0|    _base[_canonicalize(key)] = new Pair(key, value);
       |  }
       |
       |  void addAll(Map<K, V> other) {
      0|    other.forEach((key, value) => this[key] = value);
       |  }
       |
       |  void clear() {
      0|    _base.clear();
       |  }
       |
       |  bool containsKey(Object key) {
      0|    if (!_isValidKey(key)) return false;
      0|    return _base.containsKey(_canonicalize(key as K));
       |  }
       |
       |  bool containsValue(Object value) =>
      0|      _base.values.any((pair) => pair.last == value);
       |
       |  void forEach(void f(K key, V value)) {
      0|    _base.forEach((key, pair) => f(pair.first, pair.last));
       |  }
       |
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      0|  Iterable<K> get keys => _base.values.map((pair) => pair.first);
       |
      0|  int get length => _base.length;
       |
       |  V putIfAbsent(K key, V ifAbsent()) {
      0|    return _base.putIfAbsent(_canonicalize(key),
      0|        () => new Pair(key, ifAbsent())).last;
       |  }
       |
       |  V remove(Object key) {
      0|    if (!_isValidKey(key)) return null;
      0|    var pair = _base.remove(_canonicalize(key as K));
      0|    return pair == null ? null : pair.last;
       |  }
       |
      0|  Iterable<V> get values => _base.values.map((pair) => pair.last);
       |
      0|  String toString() => Maps.mapToString(this);
       |
      0|  bool _isValidKey(Object key) => (key == null || key is K) &&
      0|      (_isValidKeyFn == null || _isValidKeyFn(key));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/combined_wrappers/combined_iterable.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// A view of several iterables combined sequentially into a single iterable.
       |///
       |/// All methods and accessors treat the [CombinedIterableView] as if it were a
       |/// single concatenated iterable, but the underlying implementation is based on
       |/// lazily accessing individual iterable instances. This means that if the
       |/// underlying iterables change, the [CombinedIterableView] will reflect those
       |/// changes.
       |class CombinedIterableView<T> extends IterableBase<T> {
       |  /// The iterables that this combines.
       |  final Iterable<Iterable<T>> _iterables;
       |
       |  /// Creates a combined view of [iterables].
      0|  const CombinedIterableView(this._iterables);
       |
       |  Iterator<T> get iterator =>
      0|      new _CombinedIterator<T>(_iterables.map((i) => i.iterator).iterator);
       |
       |  // Special cased contains/isEmpty/length since many iterables have an
       |  // efficient implementation instead of running through the entire iterator.
       |
      0|  bool contains(Object element) => _iterables.any((i) => i.contains(element));
       |
      0|  bool get isEmpty => _iterables.every((i) => i.isEmpty);
       |
      0|  int get length => _iterables.fold(0, (length, i) => length + i.length);
       |}
       |
       |/// The iterator for [CombinedIterableView].
       |///
       |/// This moves through each iterable's iterators in sequence.
       |class _CombinedIterator<T> implements Iterator<T> {
       |  /// The iterators that this combines.
       |  ///
       |  /// Because this comes from a call to [Iterable.map], it's lazy and will
       |  /// avoid instantiating unnecessary iterators.
       |  final Iterator<Iterator<T>> _iterators;
       |
      0|  _CombinedIterator(this._iterators);
       |
      0|  T get current => _iterators.current?.current;
       |
       |  bool moveNext() {
      0|    var current = _iterators.current;
      0|    if (current != null && current.moveNext()) {
       |      return true;
       |    }
      0|    return _iterators.moveNext() && moveNext();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/combined_wrappers/combined_list.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// A view of several lists combined into a single list.
       |///
       |/// All methods and accessors treat the [CombinedListView] list as if it were a
       |/// single concatenated list, but the underlying implementation is based on
       |/// lazily accessing individual list instances. This means that if the
       |/// underlying lists change, the [CombinedListView] will reflect those changes.
       |///
       |/// The index operator (`[]`) and [length] property of a [CombinedListView] are
       |/// both `O(lists)` rather than `O(1)`. A [CombinedListView] is unmodifiable.
       |class CombinedListView<T> extends ListBase<T>
       |    implements UnmodifiableListView<T> {
       |  static void _throw() {
      0|    throw new UnsupportedError('Cannot modify an unmodifiable List');
       |  }
       |
       |  /// The lists that this combines.
       |  final List<List<T>> _lists;
       |
       |  /// Creates a combined view of [lists].
      0|  CombinedListView(this._lists);
       |
       |  set length(int length) {
      0|    _throw();
       |  }
       |
      0|  int get length => _lists.fold(0, (length, list) => length + list.length);
       |
       |  T operator [](int index) {
       |    var initialIndex = index;
      0|    for (var i = 0; i < _lists.length; i++) {
      0|      var list = _lists[i];
      0|      if (index < list.length) {
      0|        return list[index];
       |      }
      0|      index -= list.length;
       |    }
      0|    throw new RangeError.index(initialIndex, this, 'index', null, length);
       |  }
       |
       |  void operator []=(int index, T value) {
      0|    _throw();
       |  }
       |
       |  void clear() {
      0|    _throw();
       |  }
       |
       |  bool remove(Object element) {
      0|    _throw();
       |    return null;
       |  }
       |
       |  void removeWhere(bool filter(T element)) {
      0|    _throw();
       |  }
       |
       |  void retainWhere(bool filter(T element)) {
      0|    _throw();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/combined_wrappers/combined_map.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'combined_iterable.dart';
       |
       |/// Returns a new map that represents maps flattened into a single map.
       |///
       |/// All methods and accessors treat the new map as-if it were a single
       |/// concatenated map, but the underlying implementation is based on lazily
       |/// accessing individual map instances. In the occasion where a key occurs in
       |/// multiple maps the first value is returned.
       |///
       |/// The resulting map has an index operator (`[]`) and `length` property that
       |/// are both `O(maps)`, rather than `O(1)`, and the map is unmodifiable - but
       |/// underlying changes to these maps are still accessible from the resulting
       |/// map.
       |class CombinedMapView<K, V> extends UnmodifiableMapBase<K, V> {
       |  final Iterable<Map<K, V>> _maps;
       |
       |  /// Create a new combined view into multiple maps.
       |  ///
       |  /// The iterable is accessed lazily so it should be collection type like
       |  /// [List] or [Set] rather than a lazy iterable produced by `map()` et al.
      0|  CombinedMapView(this._maps);
       |
       |  V operator [](Object key) {
      0|    for (var map in _maps) {
       |      // Avoid two hash lookups on a positive hit.
      0|      var value = map[key];
      0|      if (value != null || map.containsKey(value)) {
       |        return value;
       |      }
       |    }
       |    return null;
       |  }
       |
       |  /// The keys of [this].
       |  ///
       |  /// The returned iterable has efficient `length` and `contains` operations,
       |  /// based on [length] and [containsKey] of the individual maps.
       |  ///
       |  /// The order of iteration is defined by the individual `Map` implementations,
       |  /// but must be consistent between changes to the maps.
       |  ///
       |  /// Unlike most [Map] implementations, modifying an individual map while
       |  /// iterating the keys will _sometimes_ throw. This behavior may change in
       |  /// the future.
      0|  Iterable<K> get keys => new CombinedIterableView<K>(_maps.map((m) => m.keys));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/comparators.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// Character constants.
       |const int _zero         = 0x30;
       |const int _upperCaseA   = 0x41;
       |const int _upperCaseZ   = 0x5a;
       |const int _lowerCaseA   = 0x61;
       |const int _lowerCaseZ   = 0x7a;
       |const int _asciiCaseBit = 0x20;
       |
       |/// Checks if strings [a] and [b] differ only on the case of ASCII letters.
       |///
       |/// Strings are equal if they have the same length, and the characters at
       |/// each index are the same, or they are ASCII letters where one is upper-case
       |/// and the other is the lower-case version of the same letter.
       |///
       |/// The comparison does not ignore the case of non-ASCII letters, so
       |/// an upper-case ae-ligature (Æ) is different from
       |/// a lower case ae-ligature (æ).
       |///
       |/// Ignoring non-ASCII letters is not generally a good idea, but it makes sense
       |/// for situations where the strings are known to be ASCII. Examples could
       |/// be Dart identifiers, base-64 or hex encoded strings, GUIDs or similar
       |/// strings with a known structure.
       |bool equalsIgnoreAsciiCase(String a, String b) {
      0|  if (a.length != b.length) return false;
      0|  for (int i = 0; i < a.length; i++) {
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    // Quick-check for whether this may be different cases of the same letter.
      0|    if (aChar ^ bChar != _asciiCaseBit) return false;
       |    // If it's possible, then check if either character is actually an ASCII
       |    // letter.
      0|    int aCharLowerCase = aChar | _asciiCaseBit;
      0|    if (_lowerCaseA <= aCharLowerCase && aCharLowerCase <= _lowerCaseZ) {
       |      continue;
       |    }
       |    return false;
       |  }
       |  return true;
       |}
       |
       |
       |/// Hash code for a string which is compatible with [equalsIgnoreAsciiCase].
       |///
       |/// The hash code is unaffected by changing the case of ASCII letters, but
       |/// the case of non-ASCII letters do affect the result.
       |int hashIgnoreAsciiCase(String string) {
       |  // Jenkins hash code ( http://en.wikipedia.org/wiki/Jenkins_hash_function).
       |  // adapted to smi values.
       |  // Same hash used by dart2js for strings, modified to ignore ASCII letter
       |  // case.
       |  int hash = 0;
      0|  for (int i = 0; i < string.length; i++) {
      0|    int char = string.codeUnitAt(i);
       |    // Convert lower-case ASCII letters to upper case.upper
       |    // This ensures that strings that differ only in case will have the
       |    // same hash code.
      0|    if (_lowerCaseA <= char && char <= _lowerCaseZ) char -= _asciiCaseBit;
      0|    hash = 0x1fffffff & (hash + char);
      0|    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
      0|    hash >>= 6;
       |  }
      0|  hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
      0|  hash >>= 11;
      0|  return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
       |}
       |
       |
       |/// Compares [a] and [b] lexically, converting ASCII letters to upper case.
       |///
       |/// Comparison treats all lower-case ASCII letters as upper-case letters,
       |/// but does no case conversion for non-ASCII letters.
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings and is compatible with equality.
       |///
       |/// Ignoring non-ASCII letters is not generally a good idea, but it makes sense
       |/// for situations where the strings are known to be ASCII. Examples could
       |/// be Dart identifiers, base-64 or hex encoded strings, GUIDs or similar
       |/// strings with a known structure.
       |int compareAsciiUpperCase(String a, String b) {
       |  int defaultResult = 0; // Returned if no difference found.
      0|  for (int i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    // Upper-case if letters.
       |    int aUpperCase = aChar;
       |    int bUpperCase = bChar;
      0|    if (_lowerCaseA <= aChar && aChar <= _lowerCaseZ) {
      0|      aUpperCase -= _asciiCaseBit;
       |    }
      0|    if (_lowerCaseA <= bChar && bChar <= _lowerCaseZ) {
      0|      bUpperCase -= _asciiCaseBit;
       |    }
      0|    if (aUpperCase != bUpperCase) return (aUpperCase - bUpperCase).sign;
      0|    if (defaultResult == 0) defaultResult = (aChar - bChar);
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |
       |/// Compares [a] and [b] lexically, converting ASCII letters to lower case.
       |///
       |/// Comparison treats all upper-case ASCII letters as lower-case letters,
       |/// but does no case conversion for non-ASCII letters.
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings.
       |///
       |/// Ignoring non-ASCII letters is not generally a good idea, but it makes sense
       |/// for situations where the strings are known to be ASCII. Examples could
       |/// be Dart identifiers, base-64 or hex encoded strings, GUIDs or similar
       |/// strings with a known structure.
       |int compareAsciiLowerCase(String a, String b) {
       |  int defaultResult = 0;
      0|  for (int i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    int aLowerCase = aChar;
       |    int bLowerCase = bChar;
       |    // Upper case if ASCII letters.
      0|    if (_upperCaseA <= bChar && bChar <= _upperCaseZ) {
      0|      bLowerCase += _asciiCaseBit;
       |    }
      0|    if (_upperCaseA <= aChar && aChar <= _upperCaseZ) {
      0|      aLowerCase += _asciiCaseBit;
       |    }
      0|    if (aLowerCase != bLowerCase) return (aLowerCase - bLowerCase).sign;
      0|    if (defaultResult == 0) defaultResult = aChar - bChar;
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |/// Compares strings [a] and [b] according to [natural sort ordering][].
       |///
       |/// A natural sort ordering is a lexical ordering where embedded
       |/// numerals (digit sequences) are treated as a single unit and ordered by
       |/// numerical value.
       |/// This means that `"a10b"` will be ordered after `"a7b"` in natural
       |/// ordering, where lexical ordering would put the `1` before the `7`, ignoring
       |/// that the `1` is part of a larger number.
       |///
       |/// Example:
       |/// The following strings are in the order they would be sorted by using this
       |/// comparison function:
       |///
       |///     "a", "a0", "a0b", "a1", "a01", "a9", "a10", "a100", "a100b", "aa"
       |///
       |/// [natural sort ordering]: https://en.wikipedia.org/wiki/Natural_sort_order
       |int compareNatural(String a, String b) {
      0|  for (int i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar != bChar) {
      0|      return _compareNaturally(a, b, i, aChar, bChar);
       |    }
       |  }
      0|  if (b.length > a.length) return -1;
       |  return 0;
       |}
       |
       |/// Compares strings [a] and [b] according to lower-case
       |/// [natural sort ordering][].
       |///
       |/// ASCII letters are converted to lower case before being compared, like
       |/// for [compareAsciiLowerCase], then the result is compared like for
       |/// [compareNatural].
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings.
       |///
       |/// [natural sort ordering]: https://en.wikipedia.org/wiki/Natural_sort_order
       |int compareAsciiLowerCaseNatural(String a, String b) {
       |  int defaultResult = 0; // Returned if no difference found.
      0|  for (int i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    int aLowerCase = aChar;
       |    int bLowerCase = bChar;
      0|    if (_upperCaseA <= aChar && aChar <= _upperCaseZ) {
      0|      aLowerCase += _asciiCaseBit;
       |    }
      0|    if (_upperCaseA <= bChar && bChar <= _upperCaseZ) {
      0|      bLowerCase += _asciiCaseBit;
       |    }
      0|    if (aLowerCase != bLowerCase) {
      0|      return _compareNaturally(a, b, i, aLowerCase, bLowerCase);
       |    }
      0|    if (defaultResult == 0) defaultResult = aChar - bChar;
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |/// Compares strings [a] and [b] according to upper-case
       |/// [natural sort ordering][].
       |///
       |/// ASCII letters are converted to upper case before being compared, like
       |/// for [compareAsciiUpperCase], then the result is compared like for
       |/// [compareNatural].
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings
       |///
       |/// [natural sort ordering]: https://en.wikipedia.org/wiki/Natural_sort_order
       |int compareAsciiUpperCaseNatural(String a, String b) {
       |  int defaultResult = 0;
      0|  for (int i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    int aUpperCase = aChar;
       |    int bUpperCase = bChar;
      0|    if (_lowerCaseA <= aChar && aChar <= _lowerCaseZ) {
      0|      aUpperCase -= _asciiCaseBit;
       |    }
      0|    if (_lowerCaseA <= bChar && bChar <= _lowerCaseZ) {
      0|      bUpperCase -= _asciiCaseBit;
       |    }
      0|    if (aUpperCase != bUpperCase) {
      0|      return _compareNaturally(a, b, i, aUpperCase, bUpperCase);
       |    }
      0|    if (defaultResult == 0) defaultResult = aChar - bChar;
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |/// Check for numbers overlapping the current mismatched characters.
       |///
       |/// If both [aChar] and [bChar] are digits, use numerical comparison.
       |/// Check if the previous characters is a non-zero number, and if not,
       |/// skip - but count - leading zeros before comparing numbers.
       |///
       |/// If one is a digit and the other isn't, check if the previous character
       |/// is a digit, and if so, the the one with the digit is the greater number.
       |///
       |/// Otherwise just returns the difference between [aChar] and [bChar].
       |int _compareNaturally(
       |    String a, String b, int index, int aChar, int bChar) {
       |  assert(aChar != bChar);
      0|  var aIsDigit = _isDigit(aChar);
      0|  var bIsDigit = _isDigit(bChar);
       |  if (aIsDigit) {
       |    if (bIsDigit) {
      0|      return _compareNumerically(a, b, aChar, bChar, index);
      0|    } else if (index > 0 && _isDigit(a.codeUnitAt(index - 1))) {
       |      // aChar is the continuation of a longer number.
       |      return 1;
       |    }
      0|  } else if (bIsDigit && index > 0 && _isDigit(b.codeUnitAt(index - 1))) {
       |    // bChar is the continuation of a longer number.
       |    return -1;
       |  }
       |  // Characters are both non-digits, or not continuation of earlier number.
      0|  return (aChar - bChar).sign;
       |}
       |
       |/// Compare numbers overlapping [aChar] and [bChar] numerically.
       |///
       |/// If the numbers have the same numerical value, but one has more leading
       |/// zeros, the longer number is considered greater than the shorter one.
       |///
       |/// This ensures a total ordering on strings compatible with equality.
       |int _compareNumerically(String a, String b, int aChar, int bChar, int index) {
       |  // Both are digits. Find the first significant different digit, then find
       |  // the length of the numbers.
      0|  if (_isNonZeroNumberSuffix(a, index)) {
       |    // Part of a longer number, differs at this index, just count the length.
      0|    int result = _compareDigitCount(a, b, index, index);
      0|    if (result != 0) return result;
       |    // If same length, the current character is the most significant differing
       |    // digit.
      0|    return (aChar - bChar).sign;
       |  }
       |  // Not part of larger (non-zero) number, so skip leading zeros before
       |  // comparing numbers.
       |  int aIndex = index;
       |  int bIndex = index;
      0|  if (aChar == _zero) {
       |    do {
      0|      aIndex++;
      0|      if (aIndex == a.length) return -1;  // number in a is zero, b is not.
      0|      aChar = a.codeUnitAt(aIndex);
      0|    } while (aChar == _zero);
      0|    if (!_isDigit(aChar)) return -1;
      0|  } else if (bChar == _zero) {
       |    do {
      0|      bIndex++;
      0|      if (bIndex == b.length) return 1;  // number in b is zero, a is not.
      0|      bChar = b.codeUnitAt(bIndex);
      0|    } while (bChar == _zero);
      0|    if (!_isDigit(bChar)) return 1;
       |  }
      0|  if (aChar != bChar) {
      0|    int result = _compareDigitCount(a, b, aIndex, bIndex);
      0|    if (result != 0) return result;
      0|    return (aChar - bChar).sign;
       |  }
       |  // Same leading digit, one had more leading zeros.
       |  // Compare digits until reaching a difference.
       |  while (true) {
       |    var aIsDigit = false;
       |    var bIsDigit = false;
       |    aChar = 0;
       |    bChar = 0;
      0|    if (++aIndex < a.length) {
      0|      aChar = a.codeUnitAt(aIndex);
      0|      aIsDigit = _isDigit(aChar);
       |    }
      0|    if (++bIndex < b.length) {
      0|      bChar = b.codeUnitAt(bIndex);
      0|      bIsDigit = _isDigit(bChar);
       |    }
       |    if (aIsDigit) {
       |      if (bIsDigit) {
      0|        if (aChar == bChar) continue;
       |        // First different digit found.
       |        break;
       |      }
       |      // bChar is non-digit, so a has longer number.
       |      return 1;
       |    } else if (bIsDigit) {
       |      return -1;  // b has longer number.
       |    } else {
       |      // Neither is digit, so numbers had same numerical value.
       |      // Fall back on number of leading zeros
       |      // (reflected by difference in indices).
      0|      return (aIndex - bIndex).sign;
       |    }
       |  }
       |  // At first differing digits.
      0|  int result = _compareDigitCount(a, b, aIndex, bIndex);
      0|  if (result != 0) return result;
      0|  return (aChar - bChar).sign;
       |}
       |
       |/// Checks which of [a] and [b] has the longest sequence of digits.
       |///
       |/// Starts counting from `i + 1` and `j + 1` (assumes that `a[i]` and `b[j]` are
       |/// both already known to be digits).
       |int _compareDigitCount(String a, String b, int i, int j) {
      0|  while (++i < a.length) {
      0|    bool aIsDigit = _isDigit(a.codeUnitAt(i));
      0|    if (++j == b.length) return aIsDigit ? 1 : 0;
      0|    bool bIsDigit = _isDigit(b.codeUnitAt(j));
       |    if (aIsDigit) {
       |      if (bIsDigit) continue;
       |      return 1;
       |    } else if (bIsDigit) {
       |      return -1;
       |    } else {
       |      return 0;
       |    }
       |  }
      0|  if (++j < b.length && _isDigit(b.codeUnitAt(j))) {
       |    return -1;
       |  }
       |  return 0;
       |}
       |
      0|bool _isDigit(int charCode) => (charCode ^ _zero) <= 9;
       |
       |/// Check if the digit at [index] is continuing a non-zero number.
       |///
       |/// If there is no non-zero digits before, then leading zeros at [index]
       |/// are also ignored when comparing numerically. If there is a non-zero digit
       |/// before, then zeros at [index] are significant.
       |bool _isNonZeroNumberSuffix(String string, int index) {
      0|  while (--index >= 0) {
      0|    int char = string.codeUnitAt(index);
      0|    if (char != _zero) return _isDigit(char);
       |  }
       |  return false;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/equality.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:collection";
       |
       |import "comparators.dart";
       |
       |const int _HASH_MASK = 0x7fffffff;
       |
       |/// A generic equality relation on objects.
       |abstract class Equality<E> {
       |  const factory Equality() = DefaultEquality<E>;
       |
       |  /// Compare two elements for being equal.
       |  ///
       |  /// This should be a proper equality relation.
       |  bool equals(E e1, E e2);
       |
       |  /// Get a hashcode of an element.
       |  ///
       |  /// The hashcode should be compatible with [equals], so that if
       |  /// `equals(a, b)` then `hash(a) == hash(b)`.
       |  int hash(E e);
       |
       |  /// Test whether an object is a valid argument to [equals] and [hash].
       |  ///
       |  /// Some implementations may be restricted to only work on specific types
       |  /// of objects.
       |  bool isValidKey(Object o);
       |}
       |
       |typedef F _GetKey<E, F>(E object);
       |
       |/// Equality of objects based on derived values.
       |///
       |/// For example, given the class:
       |/// ```dart
       |/// abstract class Employee {
       |///   int get employmentId;
       |/// }
       |/// ```
       |///
       |/// The following [Equality] considers employees with the same IDs to be equal:
       |/// ```dart
       |/// new EqualityBy((Employee e) => e.employmentId);
       |/// ```
       |///
       |/// It's also possible to pass an additional equality instance that should be
       |/// used to compare the value itself.
       |class EqualityBy<E, F> implements Equality<E> {
       |  // Returns a derived value F from an object E.
       |  final _GetKey<E, F> _getKey;
       |
       |  // Determines equality between two values of F.
       |  final Equality<F> _inner;
       |
       |  EqualityBy(F getKey(E object), [Equality<F> inner = const DefaultEquality()])
       |      : _getKey = getKey,
      0|        _inner = inner;
       |
      0|  bool equals(E e1, E e2) => _inner.equals(_getKey(e1), _getKey(e2));
       |
      0|  int hash(E e) => _inner.hash(_getKey(e));
       |
       |  bool isValidKey(Object o) {
      0|    if (o is E) {
      0|      final value = _getKey(o);
      0|      return value is F && _inner.isValidKey(value);
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Equality of objects that compares only the natural equality of the objects.
       |///
       |/// This equality uses the objects' own [Object.==] and [Object.hashCode] for
       |/// the equality.
       |class DefaultEquality<E> implements Equality<E> {
      1|  const DefaultEquality();
      0|  bool equals(E e1, E e2) => e1 == e2;
      0|  int hash(E e) => e.hashCode;
       |  bool isValidKey(Object o) => true;
       |}
       |
       |/// Equality of objects that compares only the identity of the objects.
       |class IdentityEquality<E> implements Equality<E> {
      0|  const IdentityEquality();
       |  bool equals(E e1, E e2) => identical(e1, e2);
      0|  int hash(E e) => identityHashCode(e);
       |  bool isValidKey(Object o) => true;
       |}
       |
       |/// Equality on iterables.
       |///
       |/// Two iterables are equal if they have the same elements in the same order.
       |class IterableEquality<E> implements Equality<Iterable<E>> {
       |  final Equality<E> _elementEquality;
       |  const IterableEquality([Equality<E> elementEquality =
       |                              const DefaultEquality()])
      0|      : _elementEquality = elementEquality;
       |
       |  bool equals(Iterable<E> elements1, Iterable<E> elements2) {
       |    if (identical(elements1, elements2)) return true;
       |    if (elements1 == null || elements2 == null) return false;
      0|    var it1 = elements1.iterator;
      0|    var it2 = elements2.iterator;
       |    while (true) {
      0|      bool hasNext = it1.moveNext();
      0|      if (hasNext != it2.moveNext()) return false;
       |      if (!hasNext) return true;
      0|      if (!_elementEquality.equals(it1.current, it2.current)) return false;
       |    }
       |  }
       |
       |  int hash(Iterable<E> elements) {
       |    // Jenkins's one-at-a-time hash function.
       |    int hash = 0;
      0|    for (E element in elements) {
      0|      int c = _elementEquality.hash(element);
      0|      hash = (hash + c) & _HASH_MASK;
      0|      hash = (hash + (hash << 10)) & _HASH_MASK;
      0|      hash ^= (hash >> 6);
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |
      0|  bool isValidKey(Object o) => o is Iterable<E>;
       |}
       |
       |/// Equality on lists.
       |///
       |/// Two lists are equal if they have the same length and their elements
       |/// at each index are equal.
       |///
       |/// This is effectively the same as [IterableEquality] except that it
       |/// accesses elements by index instead of through iteration.
       |class ListEquality<E> implements Equality<List<E>> {
       |  final Equality<E> _elementEquality;
       |  const ListEquality([Equality<E> elementEquality = const DefaultEquality()])
      0|      : _elementEquality = elementEquality;
       |
       |  bool equals(List<E> e1, List<E> e2) {
       |    if (identical(e1, e2)) return true;
       |    if (e1 == null || e2 == null) return false;
      0|    int length = e1.length;
      0|    if (length != e2.length) return false;
      0|    for (int i = 0; i < length; i++) {
      0|      if (!_elementEquality.equals(e1[i], e2[i])) return false;
       |    }
       |    return true;
       |  }
       |
       |  int hash(List<E> e) {
       |    // Jenkins's one-at-a-time hash function.
       |    // This code is almost identical to the one in IterableEquality, except
       |    // that it uses indexing instead of iterating to get the elements.
       |    int hash = 0;
      0|    for (int i = 0; i < e.length; i++) {
      0|      int c = _elementEquality.hash(e[i]);
      0|      hash = (hash + c) & _HASH_MASK;
      0|      hash = (hash + (hash << 10)) & _HASH_MASK;
      0|      hash ^= (hash >> 6);
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |
      0|  bool isValidKey(Object o) => o is List<E>;
       |}
       |
       |abstract class _UnorderedEquality<E, T extends Iterable<E>>
       |    implements Equality<T> {
       |  final Equality<E> _elementEquality;
       |
      0|  const _UnorderedEquality(this._elementEquality);
       |
       |  bool equals(T e1, T e2) {
       |    if (identical(e1, e2)) return true;
       |    if (e1 == null || e2 == null) return false;
      0|    HashMap<E, int> counts = new HashMap(
      0|        equals: _elementEquality.equals,
      0|        hashCode: _elementEquality.hash,
      0|        isValidKey: _elementEquality.isValidKey);
       |    int length = 0;
      0|    for (var e in e1) {
      0|      int count = counts[e];
       |      if (count == null) count = 0;
      0|      counts[e] = count + 1;
      0|      length++;
       |    }
      0|    for (var e in e2) {
      0|      int count = counts[e];
      0|      if (count == null || count == 0) return false;
      0|      counts[e] = count - 1;
      0|      length--;
       |    }
      0|    return length == 0;
       |  }
       |
       |  int hash(T e) {
       |    int hash = 0;
      0|    for (E element in e) {
      0|      int c = _elementEquality.hash(element);
      0|      hash = (hash + c) & _HASH_MASK;
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |}
       |
       |/// Equality of the elements of two iterables without considering order.
       |///
       |/// Two iterables are considered equal if they have the same number of elements,
       |/// and the elements of one set can be paired with the elements
       |/// of the other iterable, so that each pair are equal.
       |class UnorderedIterableEquality<E> extends _UnorderedEquality<E, Iterable<E>> {
       |  const UnorderedIterableEquality(
       |      [Equality<E> elementEquality = const DefaultEquality()])
      0|      : super(elementEquality);
       |
      0|  bool isValidKey(Object o) => o is Iterable<E>;
       |}
       |
       |/// Equality of sets.
       |///
       |/// Two sets are considered equal if they have the same number of elements,
       |/// and the elements of one set can be paired with the elements
       |/// of the other set, so that each pair are equal.
       |///
       |/// This equality behaves the same as [UnorderedIterableEquality] except that
       |/// it expects sets instead of iterables as arguments.
       |class SetEquality<E> extends _UnorderedEquality<E, Set<E>> {
       |  const SetEquality(
       |      [Equality<E> elementEquality = const DefaultEquality()])
      0|      : super(elementEquality);
       |
      0|  bool isValidKey(Object o) => o is Set<E>;
       |}
       |
       |/// Internal class used by [MapEquality].
       |///
       |/// The class represents a map entry as a single object,
       |/// using a combined hashCode and equality of the key and value.
       |class _MapEntry {
       |  final MapEquality equality;
       |  final key;
       |  final value;
      0|  _MapEntry(this.equality, this.key, this.value);
       |
       |  int get hashCode =>
      0|      (3 * equality._keyEquality.hash(key) +
      0|       7 * equality._valueEquality.hash(value)) & _HASH_MASK;
       |
       |  bool operator==(Object other) {
      0|    if (other is! _MapEntry) return false;
       |    _MapEntry otherEntry = other;
      0|    return equality._keyEquality.equals(key, otherEntry.key) &&
      0|           equality._valueEquality.equals(value, otherEntry.value);
       |
       |  }
       |}
       |
       |/// Equality on maps.
       |///
       |/// Two maps are equal if they have the same number of entries, and if the
       |/// entries of the two maps are pairwise equal on both key and value.
       |class MapEquality<K, V> implements Equality<Map<K, V>> {
       |  final Equality<K> _keyEquality;
       |  final Equality<V> _valueEquality;
       |  const MapEquality({ Equality<K> keys : const DefaultEquality(),
       |                      Equality<V> values : const DefaultEquality() })
      0|      : _keyEquality = keys, _valueEquality = values;
       |
       |  bool equals(Map<K, V> e1, Map<K, V> e2) {
       |    if (identical(e1, e2)) return true;
       |    if (e1 == null || e2 == null) return false;
      0|    int length = e1.length;
      0|    if (length != e2.length) return false;
      0|    Map<_MapEntry, int> equalElementCounts = new HashMap();
      0|    for (K key in e1.keys) {
      0|      _MapEntry entry = new _MapEntry(this, key, e1[key]);
      0|      int count = equalElementCounts[entry];
       |      if (count == null) count = 0;
      0|      equalElementCounts[entry] = count + 1;
       |    }
      0|    for (K key in e2.keys) {
      0|      _MapEntry entry = new _MapEntry(this, key, e2[key]);
      0|      int count = equalElementCounts[entry];
      0|      if (count == null || count == 0) return false;
      0|      equalElementCounts[entry] = count - 1;
       |    }
       |    return true;
       |  }
       |
       |  int hash(Map<K, V> map) {
       |    int hash = 0;
      0|    for (K key in map.keys) {
      0|      int keyHash = _keyEquality.hash(key);
      0|      int valueHash = _valueEquality.hash(map[key]);
      0|      hash = (hash + 3 * keyHash + 7 * valueHash) & _HASH_MASK;
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |
      0|  bool isValidKey(Object o) => o is Map<K, V>;
       |}
       |
       |/// Combines several equalities into a single equality.
       |///
       |/// Tries each equality in order, using [Equality.isValidKey], and returns
       |/// the result of the first equality that applies to the argument or arguments.
       |///
       |/// For `equals`, the first equality that matches the first argument is used,
       |/// and if the second argument of `equals` is not valid for that equality,
       |/// it returns false.
       |///
       |/// Because the equalities are tried in order, they should generally work on
       |/// disjoint types. Otherwise the multi-equality may give inconsistent results
       |/// for `equals(e1, e2)` and `equals(e2, e1)`. This can happen if one equality
       |/// considers only `e1` a valid key, and not `e2`, but an equality which is
       |/// checked later, allows both.
       |class MultiEquality<E> implements Equality<E> {
       |  final Iterable<Equality<E>> _equalities;
       |
       |  const MultiEquality(Iterable<Equality<E>> equalities)
      0|      : _equalities = equalities;
       |
       |  bool equals(E e1, E e2) {
      0|    for (Equality<E> eq in _equalities) {
      0|      if (eq.isValidKey(e1)) return eq.isValidKey(e2) && eq.equals(e1, e2);
       |    }
       |    return false;
       |  }
       |
       |  int hash(E e) {
      0|    for (Equality<E> eq in _equalities) {
      0|      if (eq.isValidKey(e)) return eq.hash(e);
       |    }
       |    return -1;
       |  }
       |
       |  bool isValidKey(Object o) {
      0|    for (Equality<E> eq in _equalities) {
      0|      if (eq.isValidKey(o)) return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Deep equality on collections.
       |///
       |/// Recognizes lists, sets, iterables and maps and compares their elements using
       |/// deep equality as well.
       |///
       |/// Non-iterable/map objects are compared using a configurable base equality.
       |///
       |/// Works in one of two modes: ordered or unordered.
       |///
       |/// In ordered mode, lists and iterables are required to have equal elements
       |/// in the same order. In unordered mode, the order of elements in iterables
       |/// and lists are not important.
       |///
       |/// A list is only equal to another list, likewise for sets and maps. All other
       |/// iterables are compared as iterables only.
       |class DeepCollectionEquality implements Equality {
       |  final Equality _base;
       |  final bool _unordered;
       |  const DeepCollectionEquality([Equality base = const DefaultEquality()])
      0|      : _base = base, _unordered = false;
       |
       |  /// Creates a deep equality on collections where the order of lists and
       |  /// iterables are not considered important. That is, lists and iterables are
       |  /// treated as unordered iterables.
       |  const DeepCollectionEquality.unordered(
       |      [Equality base = const DefaultEquality()])
      0|      : _base = base, _unordered = true;
       |
       |  bool equals(e1, e2) {
      0|    if (e1 is Set) {
      0|      if (e2 is! Set) return false;
      0|      return new SetEquality(this).equals(e1, e2);
       |    }
      0|    if (e1 is Map) {
      0|      if (e2 is! Map) return false;
      0|      return new MapEquality(keys: this, values: this).equals(e1, e2);
       |    }
      0|    if (!_unordered) {
      0|      if (e1 is List) {
      0|        if (e2 is! List) return false;
      0|        return new ListEquality(this).equals(e1, e2);
       |      }
      0|      if (e1 is Iterable) {
      0|        if (e2 is! Iterable) return false;
      0|        return new IterableEquality(this).equals(e1, e2);
       |      }
      0|    } else if (e1 is Iterable) {
      0|      if (e2 is! Iterable) return false;
      0|      if (e1 is List != e2 is List) return false;
      0|      return new UnorderedIterableEquality(this).equals(e1, e2);
       |    }
      0|    return _base.equals(e1, e2);
       |  }
       |
       |  int hash(Object o) {
      0|    if (o is Set) return new SetEquality(this).hash(o);
      0|    if (o is Map) return new MapEquality(keys: this, values: this).hash(o);
      0|    if (!_unordered) {
      0|      if (o is List) return new ListEquality(this).hash(o);
      0|      if (o is Iterable) return new IterableEquality(this).hash(o);
      0|    } else if (o is Iterable) {
      0|      return new UnorderedIterableEquality(this).hash(o);
       |    }
      0|    return _base.hash(o);
       |  }
       |
      0|  bool isValidKey(Object o) => o is Iterable || o is Map || _base.isValidKey(o);
       |}
       |
       |/// String equality that's insensitive to differences in ASCII case.
       |///
       |/// Non-ASCII characters are compared as-is, with no conversion.
       |class CaseInsensitiveEquality implements Equality<String> {
      0|  const CaseInsensitiveEquality();
       |
       |  bool equals(String string1, String string2) =>
      0|      equalsIgnoreAsciiCase(string1, string2);
       |
      0|  int hash(String string) => hashIgnoreAsciiCase(string);
       |
      0|  bool isValidKey(Object object) => object is String;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/equality_map.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'equality.dart';
       |import 'wrappers.dart';
       |
       |/// A [Map] whose key equality is determined by an [Equality] object.
       |class EqualityMap<K, V> extends DelegatingMap<K, V> {
       |  /// Creates a map with equality based on [equality].
       |  EqualityMap(Equality<K> equality)
      0|      : super(new LinkedHashMap(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey));
       |
       |  /// Creates a map with equality based on [equality] that contains all
       |  /// key-value pairs of [other].
       |  ///
       |  /// If [other] has multiple keys that are equivalent according to [equality],
       |  /// the last one reached during iteration takes precedence.
       |  EqualityMap.from(Equality<K> equality, Map<K, V> other)
      0|      : super(new LinkedHashMap(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey)) {
      0|    addAll(other);
       |  }
       |}
       |
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/equality_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'equality.dart';
       |import 'wrappers.dart';
       |
       |/// A [Map] whose key equality is determined by an [Equality] object.
       |class EqualitySet<E> extends DelegatingSet<E> {
       |  /// Creates a set with equality based on [equality].
       |  EqualitySet(Equality<E> equality)
      0|      : super(new LinkedHashSet(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey));
       |
       |  /// Creates a set with equality based on [equality] that contains all
       |  /// elements in [other].
       |  ///
       |  /// If [other] has multiple values that are equivalent according to
       |  /// [equality], the first one reached during iteration takes precedence.
       |  EqualitySet.from(Equality<E> equality, Iterable<E> other)
      0|      : super(new LinkedHashSet(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey)) {
      0|    addAll(other);
       |  }
       |}
       |
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/functions.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |import 'dart:collection';
       |
       |import 'utils.dart';
       |
       |// TODO(nweiz): When sdk#26488 is fixed, use overloads to ensure that if [key]
       |// or [value] isn't passed, `K2`/`V2` defaults to `K1`/`V1`, respectively.
       |/// Creates a new map from [map] with new keys and values. 
       |///
       |/// The return values of [key] are used as the keys and the return values of
       |/// [value] are used as the values for the new map.
       |Map/*<K2, V2>*/ mapMap/*<K1, V1, K2, V2>*/(Map/*<K1, V1>*/ map,
       |    {/*=K2*/ key(/*=K1*/ key, /*=V1*/ value),
       |    /*=V2*/ value(/*=K1*/ key, /*=V1*/ value)}) {
       |  key ??= (mapKey, _) => mapKey as dynamic/*=K2*/;
       |  value ??= (_, mapValue) => mapValue as dynamic/*=V2*/;
       |
      0|  var result = /*<K2, V2>*/{};
      0|  map.forEach((mapKey, mapValue) {
      0|    result[key(mapKey, mapValue)] = value(mapKey, mapValue);
       |  });
       |  return result;
       |}
       |
       |/// Returns a new map with all key/value pairs in both [map1] and [map2].
       |///
       |/// If there are keys that occur in both maps, the [value] function is used to
       |/// select the value that goes into the resulting map based on the two original
       |/// values. If [value] is omitted, the value from [map2] is used.
       |Map/*<K, V>*/ mergeMaps/*<K, V>*/(Map/*<K, V>*/ map1, Map/*<K, V>*/ map2,
       |    {/*=V*/ value(/*=V*/ value1, /*=V*/ value2)}) {
      1|  var result = new Map/*<K, V>*/.from(map1);
      0|  if (value == null) return result..addAll(map2);
       |
      1|  map2.forEach((key, mapValue) {
      0|    result[key] = result.containsKey(key)
      0|        ? value(result[key], mapValue)
       |        : mapValue;
       |  });
       |  return result;
       |}
       |
       |/// Groups the elements in [values] by the value returned by [key].
       |///
       |/// Returns a map from keys computed by [key] to a list of all values for which
       |/// [key] returns that key. The values appear in the list in the same relative
       |/// order as in [values].
       |Map<dynamic/*=T*/, List/*<S>*/> groupBy/*<S, T>*/(Iterable/*<S>*/ values,
       |    /*=T*/ key(/*=S*/ element)) {
      0|  var map = /*<T, List<S>>*/{};
      0|  for (var element in values) {
      0|    var list = map.putIfAbsent(key(element), () => []);
      0|    list.add(element);
       |  }
       |  return map;
       |}
       |
       |/// Returns the element of [values] for which [orderBy] returns the minimum
       |/// value.
       |///
       |/// The values returned by [orderBy] are compared using the [compare] function.
       |/// If [compare] is omitted, values must implement [Comparable<T>] and they are
       |/// compared using their [Comparable.compareTo].
       |/*=S*/ minBy/*<S, T>*/(Iterable/*<S>*/ values, /*=T*/ orderBy(/*=S*/ element),
       |    {int compare(/*=T*/ value1, /*=T*/ value2)}) {
      0|  compare ??= defaultCompare/*<T>*/();
       |
       |  var/*=S*/ minValue;
       |  var/*=T*/ minOrderBy;
      0|  for (var element in values) {
      0|    var elementOrderBy = orderBy(element);
      0|    if (minOrderBy == null || compare(elementOrderBy, minOrderBy) < 0) {
       |      minValue = element;
       |      minOrderBy = elementOrderBy;
       |    }
       |  }
       |  return minValue;
       |}
       |
       |/// Returns the element of [values] for which [orderBy] returns the maximum
       |/// value.
       |///
       |/// The values returned by [orderBy] are compared using the [compare] function.
       |/// If [compare] is omitted, values must implement [Comparable<T>] and they are
       |/// compared using their [Comparable.compareTo].
       |/*=S*/ maxBy/*<S, T>*/(Iterable/*<S>*/ values, /*=T*/ orderBy(/*=S*/ element),
       |    {int compare(/*=T*/ value1, /*=T*/ value2)}) {
      0|  compare ??= defaultCompare/*<T>*/();
       |
       |  var/*=S*/ maxValue;
       |  var/*=T*/ maxOrderBy;
      0|  for (var element in values) {
      0|    var elementOrderBy = orderBy(element);
      0|    if (maxOrderBy == null || compare(elementOrderBy, maxOrderBy) > 0) {
       |      maxValue = element;
       |      maxOrderBy = elementOrderBy;
       |    }
       |  }
       |  return maxValue;
       |}
       |
       |/// Returns the [transitive closure][] of [graph].
       |///
       |/// [transitive closure]: https://en.wikipedia.org/wiki/Transitive_closure
       |///
       |/// Interprets [graph] as a directed graph with a vertex for each key and edges
       |/// from each key to the values that the key maps to.
       |///
       |/// Assumes that every vertex in the graph has a key to represent it, even if
       |/// that vertex has no outgoing edges. This isn't checked, but if it's not
       |/// satisfied, the function may crash or provide unexpected output. For example,
       |/// `{"a": ["b"]}` is not valid, but `{"a": ["b"], "b": []}` is.
       |Map<dynamic/*=T*/, Set/*<T>*/> transitiveClosure/*<T>*/(
       |    Map<dynamic/*=T*/, Iterable/*<T>*/> graph) {
       |  // This uses [Warshall's algorithm][], modified not to add a vertex from each
       |  // node to itself.
       |  //
       |  // [Warshall's algorithm]: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Applications_and_generalizations.
      0|  var result = /*<T, Set>*/{};
      0|  graph.forEach((vertex, edges) {
      0|    result[vertex] = new Set/*<T>*/.from(edges);
       |  });
       |
       |  // Lists are faster to iterate than maps, so we create a list since we're
       |  // iterating repeatedly.
      0|  var keys = graph.keys.toList();
      0|  for (var vertex1 in keys) {
      0|    for (var vertex2 in keys) {
      0|      for (var vertex3 in keys) {
      0|        if (result[vertex2].contains(vertex1) &&
      0|            result[vertex1].contains(vertex3)) {
      0|          result[vertex2].add(vertex3);
       |        }
       |      }
       |    }
       |  }
       |
       |  return result;
       |}
       |
       |/// Returns the [strongly connected components][] of [graph], in topological
       |/// order.
       |///
       |/// [strongly connected components]: https://en.wikipedia.org/wiki/Strongly_connected_component
       |///
       |/// Interprets [graph] as a directed graph with a vertex for each key and edges
       |/// from each key to the values that the key maps to.
       |///
       |/// Assumes that every vertex in the graph has a key to represent it, even if
       |/// that vertex has no outgoing edges. This isn't checked, but if it's not
       |/// satisfied, the function may crash or provide unexpected output. For example,
       |/// `{"a": ["b"]}` is not valid, but `{"a": ["b"], "b": []}` is.
       |List<Set/*<T>*/> stronglyConnectedComponents/*<T>*/(
       |    Map<dynamic/*=T*/, Iterable/*<T>*/> graph) {
       |  // This uses [Tarjan's algorithm][].
       |  //
       |  // [Tarjan's algorithm]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
       |  var index = 0;
      0|  var stack = /*<T>*/[];
      0|  var result = /*<Set<T>>*/[];
       |
       |  // The order of these doesn't matter, so we use un-linked implementations to
       |  // avoid unnecessary overhead.
      0|  var indices = new HashMap/*<T, int>*/();
      0|  var lowLinks = new HashMap/*<T, int>*/();
      0|  var onStack = new HashSet/*<T>*/();
       |
       |  strongConnect(/*=T*/ vertex) {
      0|    indices[vertex] = index;
      0|    lowLinks[vertex] = index;
      0|    index++;
       |
      0|    stack.add(vertex);
      0|    onStack.add(vertex);
       |
      0|    for (var successor in graph[vertex]) {
      0|      if (!indices.containsKey(successor)) {
      0|        strongConnect(successor);
      1|        lowLinks[vertex] = math.min(lowLinks[vertex], lowLinks[successor]);
      0|      } else if (onStack.contains(successor)) {
      1|        lowLinks[vertex] = math.min(lowLinks[vertex], lowLinks[successor]);
       |      }
       |    }
       |
      0|    if (lowLinks[vertex] == indices[vertex]) {
      0|      var component = new Set/*<T>*/();
       |      var/*=T*/ neighbor;
       |      do {
      0|        neighbor = stack.removeLast();
      0|        onStack.remove(neighbor);
      0|        component.add(neighbor);
      0|      } while (neighbor != vertex);
      0|      result.add(component);
       |    }
       |  }
       |
      0|  for (var vertex in graph.keys) {
      0|    if (!indices.containsKey(vertex)) strongConnect(vertex);
       |  }
       |
       |  // Tarjan's algorithm produces a reverse-topological sort, so we reverse it to
       |  // get a normal topological sort.
      0|  return result.reversed.toList();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/iterable_zip.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:collection";
       |
       |/// Iterable that iterates over lists of values from other iterables.
       |///
       |/// When [iterator] is read, an [Iterator] is created for each [Iterable] in
       |/// the [Iterable] passed to the constructor.
       |///
       |/// As long as all these iterators have a next value, those next values are
       |/// combined into a single list, which becomes the next value of this
       |/// [Iterable]'s [Iterator]. As soon as any of the iterators run out,
       |/// the zipped iterator also stops.
       |class IterableZip<T> extends IterableBase<List<T>> {
       |  final Iterable<Iterable<T>> _iterables;
       |
       |  IterableZip(Iterable<Iterable<T>> iterables)
      0|      : this._iterables = iterables;
       |
       |  /// Returns an iterator that combines values of the iterables' iterators
       |  /// as long as they all have values.
       |  Iterator<List<T>> get iterator {
      0|    var iterators = _iterables.map((x) => x.iterator).toList(growable: false);
       |    // TODO(lrn): Return an empty iterator directly if iterators is empty?
      0|    return new _IteratorZip<T>(iterators);
       |  }
       |}
       |
       |class _IteratorZip<T> implements Iterator<List<T>> {
       |  final List<Iterator<T>> _iterators;
       |  List<T> _current;
       |
      0|  _IteratorZip(List<Iterator<T>> iterators) : _iterators = iterators;
       |
       |  bool moveNext() {
      0|    if (_iterators.isEmpty) return false;
      0|    for (int i = 0; i < _iterators.length; i++) {
      0|      if (!_iterators[i].moveNext()) {
      0|        _current = null;
       |        return false;
       |      }
       |    }
      0|    _current = new List(_iterators.length);
      0|    for (int i = 0; i < _iterators.length; i++) {
      0|      _current[i] = _iterators[i].current;
       |    }
       |    return true;
       |  }
       |
      0|  List<T> get current => _current;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/priority_queue.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:collection";
       |
       |import "utils.dart";
       |
       |/// A priority queue is a priority based work-list of elements.
       |///
       |/// The queue allows adding elements, and removing them again in priority order.
       |abstract class PriorityQueue<E> {
       |  /// Creates an empty [PriorityQueue].
       |  ///
       |  /// The created [PriorityQueue] is a plain [HeapPriorityQueue].
       |  ///
       |  /// The [comparison] is a [Comparator] used to compare the priority of
       |  /// elements. An element that compares as less than another element has
       |  /// a higher priority.
       |  ///
       |  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this
       |  /// is the case, `E` must implement [Comparable], and this is checked at
       |  /// runtime for every comparison.
       |  factory PriorityQueue([int comparison(E e1, E e2)]) = HeapPriorityQueue<E>;
       |
       |  /// Number of elements in the queue.
       |  int get length;
       |
       |  /// Whether the queue is empty.
       |  bool get isEmpty;
       |
       |  /// Whether the queue has any elements.
       |  bool get isNotEmpty;
       |
       |  /// Checks if [object] is in the queue.
       |  ///
       |  /// Returns true if the element is found.
       |  bool contains(E object);
       |
       |  /// Adds element to the queue.
       |  ///
       |  /// The element will become the next to be removed by [removeFirst]
       |  /// when all elements with higher priority have been removed.
       |  void add(E element);
       |
       |  /// Adds all [elements] to the queue.
       |  void addAll(Iterable<E> elements);
       |
       |  /// Returns the next element that will be returned by [removeFirst].
       |  ///
       |  /// The element is not removed from the queue.
       |  ///
       |  /// The queue must not be empty when this method is called.
       |  E get first;
       |
       |  /// Removes and returns the element with the highest priority.
       |  ///
       |  /// Repeatedly calling this method, without adding element in between,
       |  /// is guaranteed to return elements in non-decreasing order as, specified by
       |  /// [comparison].
       |  ///
       |  /// The queue must not be empty when this method is called.
       |  E removeFirst();
       |
       |  /// Removes an element that compares equal to [element] in the queue.
       |  ///
       |  /// Returns true if an element is found and removed,
       |  /// and false if no equal element is found.
       |  bool remove(E element);
       |
       |  /// Removes all the elements from this queue and returns them.
       |  ///
       |  /// The returned iterable has no specified order.
       |  Iterable<E> removeAll();
       |
       |  /// Removes all the elements from this queue.
       |  void clear();
       |
       |  /// Returns a list of the elements of this queue in priority order.
       |  ///
       |  /// The queue is not modified.
       |  ///
       |  /// The order is the order that the elements would be in if they were
       |  /// removed from this queue using [removeFirst].
       |  List<E> toList();
       |
       |  /// Return a comparator based set using the comparator of this queue.
       |  ///
       |  /// The queue is not modified.
       |  ///
       |  /// The returned [Set] is currently a [SplayTreeSet],
       |  /// but this may change as other ordered sets are implemented.
       |  ///
       |  /// The set contains all the elements of this queue.
       |  /// If an element occurs more than once in the queue,
       |  /// the set will contain it only once.
       |  Set<E> toSet();
       |}
       |
       |/// Heap based priority queue.
       |///
       |/// The elements are kept in a heap structure,
       |/// where the element with the highest priority is immediately accessible,
       |/// and modifying a single element takes
       |/// logarithmic time in the number of elements on average.
       |///
       |/// * The [add] and [removeFirst] operations take amortized logarithmic time,
       |///   O(log(n)), but may occasionally take linear time when growing the capacity
       |///   of the heap.
       |/// * The [addAll] operation works as doing repeated [add] operations.
       |/// * The [first] getter takes constant time, O(1).
       |/// * The [clear] and [removeAll] methods also take constant time, O(1).
       |/// * The [contains] and [remove] operations may need to search the entire
       |///   queue for the elements, taking O(n) time.
       |/// * The [toList] operation effectively sorts the elements, taking O(n*log(n))
       |///   time.
       |/// * The [toSet] operation effectively adds each element to the new set, taking
       |///   an expected O(n*log(n)) time.
       |class HeapPriorityQueue<E> implements PriorityQueue<E> {
       |  /// Initial capacity of a queue when created, or when added to after a
       |  /// [clear].
       |  ///
       |  /// Number can be any positive value. Picking a size that gives a whole
       |  /// number of "tree levels" in the heap is only done for aesthetic reasons.
       |  static const int _INITIAL_CAPACITY = 7;
       |
       |  /// The comparison being used to compare the priority of elements.
       |  final Comparator<E> comparison;
       |
       |  /// List implementation of a heap.
       |  List<E> _queue = new List<E>(_INITIAL_CAPACITY);
       |
       |  /// Number of elements in queue.
       |  ///
       |  /// The heap is implemented in the first [_length] entries of [_queue].
       |  int _length = 0;
       |
       |  /// Create a new priority queue.
       |  ///
       |  /// The [comparison] is a [Comparator] used to compare the priority of
       |  /// elements. An element that compares as less than another element has
       |  /// a higher priority.
       |  ///
       |  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this
       |  /// is the case, `E` must implement [Comparable], and this is checked at
       |  /// runtime for every comparison.
       |  HeapPriorityQueue([int comparison(E e1, E e2)])
      0|      : comparison = comparison ?? defaultCompare/*<E>*/();
       |
       |  void add(E element) {
      0|    _add(element);
       |  }
       |
       |  void addAll(Iterable<E> elements) {
      0|    for (E element in elements) {
      0|      _add(element);
       |    }
       |  }
       |
       |  void clear() {
      0|    _queue = const [];
      0|    _length = 0;
       |  }
       |
       |  bool contains(E object) {
      0|    return _locate(object) >= 0;
       |  }
       |
       |  E get first {
      0|    if (_length == 0) throw new StateError("No such element");
      0|    return _queue[0];
       |  }
       |
      0|  bool get isEmpty => _length == 0;
       |
      0|  bool get isNotEmpty => _length != 0;
       |
      0|  int get length => _length;
       |
       |  bool remove(E element) {
      0|    int index = _locate(element);
      0|    if (index < 0) return false;
      0|    E last = _removeLast();
      0|    if (index < _length) {
      0|      int comp = comparison(last, element);
      0|      if (comp <= 0) {
      0|        _bubbleUp(last, index);
       |      } else {
      0|        _bubbleDown(last, index);
       |      }
       |    }
       |    return true;
       |  }
       |
       |  Iterable<E> removeAll() {
      0|    List<E> result = _queue;
      0|    int length = _length;
      0|    _queue = const [];
      0|    _length = 0;
      0|    return result.take(length);
       |  }
       |
       |  E removeFirst() {
      0|    if (_length == 0) throw new StateError("No such element");
      0|    E result = _queue[0];
      0|    E last = _removeLast();
      0|    if (_length > 0) {
      0|      _bubbleDown(last, 0);
       |    }
       |    return result;
       |  }
       |
       |  List<E> toList() {
      0|    List<E> list = new List<E>()..length = _length;
      0|    list.setRange(0, _length, _queue);
      0|    list.sort(comparison);
       |    return list;
       |  }
       |
       |  Set<E> toSet() {
      0|    Set<E> set = new SplayTreeSet<E>(comparison);
      0|    for (int i = 0; i < _length; i++) {
      0|      set.add(_queue[i]);
       |    }
       |    return set;
       |  }
       |
       |  /// Returns some representation of the queue.
       |  ///
       |  /// The format isn't significant, and may change in the future.
       |  String toString() {
      0|    return _queue.take(_length).toString();
       |  }
       |
       |  /// Add element to the queue.
       |  ///
       |  /// Grows the capacity if the backing list is full.
       |  void _add(E element) {
      0|    if (_length == _queue.length) _grow();
      0|    _bubbleUp(element, _length++);
       |  }
       |
       |  /// Find the index of an object in the heap.
       |  ///
       |  /// Returns -1 if the object is not found.
       |  int _locate(E object) {
      0|    if (_length == 0) return -1;
       |    // Count positions from one instead of zero. This gives the numbers
       |    // some nice properties. For example, all right children are odd,
       |    // their left sibling is even, and the parent is found by shifting
       |    // right by one.
       |    // Valid range for position is [1.._length], inclusive.
       |    int position = 1;
       |    // Pre-order depth first search, omit child nodes if the current
       |    // node has lower priority than [object], because all nodes lower
       |    // in the heap will also have lower priority.
       |    do {
      0|      int index = position - 1;
      0|      E element = _queue[index];
      0|      int comp = comparison(element, object);
      0|      if (comp == 0) return index;
      0|      if (comp < 0) {
       |        // Element may be in subtree.
       |        // Continue with the left child, if it is there.
      0|        int leftChildPosition = position * 2;
      0|        if (leftChildPosition <= _length) {
       |          position = leftChildPosition;
       |          continue;
       |        }
       |      }
       |      // Find the next right sibling or right ancestor sibling.
       |      do {
      0|        while (position.isOdd) {
       |          // While position is a right child, go to the parent.
      0|          position >>= 1;
       |        }
       |        // Then go to the right sibling of the left-child.
      0|        position += 1;
      0|      } while (position > _length);  // Happens if last element is a left child.
      0|    } while (position != 1);  // At root again. Happens for right-most element.
       |    return -1;
       |  }
       |
       |  E _removeLast() {
      0|    int newLength = _length - 1;
      0|    E last = _queue[newLength];
      0|    _queue[newLength] = null;
      0|    _length = newLength;
       |    return last;
       |  }
       |
       |  /// Place [element] in heap at [index] or above.
       |  ///
       |  /// Put element into the empty cell at `index`.
       |  /// While the `element` has higher priority than the
       |  /// parent, swap it with the parent.
       |  void _bubbleUp(E element, int index) {
      0|    while (index > 0) {
      0|      int parentIndex = (index - 1) ~/ 2;
      0|      E parent = _queue[parentIndex];
      0|      if (comparison(element, parent) > 0) break;
      0|      _queue[index] = parent;
       |      index = parentIndex;
       |    }
      0|    _queue[index] = element;
       |  }
       |
       |  /// Place [element] in heap at [index] or above.
       |  ///
       |  /// Put element into the empty cell at `index`.
       |  /// While the `element` has lower priority than either child,
       |  /// swap it with the highest priority child.
       |  void _bubbleDown(E element, int index) {
      0|    int rightChildIndex = index * 2 + 2;
      0|    while (rightChildIndex < _length) {
      0|      int leftChildIndex = rightChildIndex - 1;
      0|      E leftChild = _queue[leftChildIndex];
      0|      E rightChild = _queue[rightChildIndex];
      0|      int comp = comparison(leftChild, rightChild);
       |      int minChildIndex;
       |      E minChild;
      0|      if (comp < 0) {
       |        minChild = leftChild;
       |        minChildIndex = leftChildIndex;
       |      } else {
       |        minChild = rightChild;
       |        minChildIndex = rightChildIndex;
       |      }
      0|      comp = comparison(element, minChild);
      0|      if (comp <= 0) {
      0|        _queue[index] = element;
       |        return;
       |      }
      0|      _queue[index] = minChild;
       |      index = minChildIndex;
      0|      rightChildIndex = index * 2 + 2;
       |    }
      0|    int leftChildIndex = rightChildIndex - 1;
      0|    if (leftChildIndex < _length) {
      0|      E child = _queue[leftChildIndex];
      0|      int comp = comparison(element, child);
      0|      if (comp > 0) {
      0|        _queue[index] = child;
       |        index = leftChildIndex;
       |      }
       |    }
      0|    _queue[index] = element;
       |  }
       |
       |  /// Grows the capacity of the list holding the heap.
       |  ///
       |  /// Called when the list is full.
       |  void _grow() {
      0|    int newCapacity = _queue.length * 2 + 1;
      0|    if (newCapacity < _INITIAL_CAPACITY) newCapacity = _INITIAL_CAPACITY;
      0|    List<E> newQueue = new List<E>(newCapacity);
      0|    newQueue.setRange(0, _length, _queue);
      0|    _queue = newQueue;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/queue_list.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// A class that efficiently implements both [Queue] and [List].
       |// TODO(nweiz): Currently this code is copied almost verbatim from
       |// dart:collection. The only changes are to implement List and to remove methods
       |// that are redundant with ListMixin. Remove or simplify it when issue 21330 is
       |// fixed.
       |class QueueList<E> extends Object with ListMixin<E> implements Queue<E> {
       |  static const int _INITIAL_CAPACITY = 8;
       |  List<E> _table;
       |  int _head;
       |  int _tail;
       |
       |  /// Create an empty queue.
       |  ///
       |  /// If [initialCapacity] is given, prepare the queue for at least that many
       |  /// elements.
      1|  QueueList([int initialCapacity]) : _head = 0, _tail = 0 {
      0|    if (initialCapacity == null || initialCapacity < _INITIAL_CAPACITY) {
       |      initialCapacity = _INITIAL_CAPACITY;
      0|    } else if (!_isPowerOf2(initialCapacity)) {
      0|      initialCapacity = _nextPowerOf2(initialCapacity);
       |    }
       |    assert(_isPowerOf2(initialCapacity));
      2|    _table = new List<E>(initialCapacity);
       |  }
       |
       |  /// Create a queue initially containing the elements of [source].
       |  factory QueueList.from(Iterable<E> source) {
      0|    if (source is List) {
      0|      int length = source.length;
      0|      QueueList<E> queue = new QueueList(length + 1);
       |      assert(queue._table.length > length);
       |      var sourceList = source;
      0|      queue._table.setRange(0, length, sourceList, 0);
      0|      queue._tail = length;
       |      return queue;
       |    } else {
      0|      return new QueueList<E>()..addAll(source);
       |    }
       |  }
       |
       |  // Collection interface.
       |
       |  void add(E element) {
      1|    _add(element);
       |  }
       |
       |  void addAll(Iterable<E> elements) {
      0|    if (elements is List) {
       |      var list = elements;
      0|      int addCount = list.length;
      0|      int length = this.length;
      0|      if (length + addCount >= _table.length) {
      0|        _preGrow(length + addCount);
       |        // After preGrow, all elements are at the start of the list.
      0|        _table.setRange(length, length + addCount, list, 0);
      0|        _tail += addCount;
       |      } else {
       |        // Adding addCount elements won't reach _head.
      0|        int endSpace = _table.length - _tail;
      0|        if (addCount < endSpace) {
      0|          _table.setRange(_tail, _tail + addCount, list, 0);
      0|          _tail += addCount;
       |        } else {
      0|          int preSpace = addCount - endSpace;
      0|          _table.setRange(_tail, _tail + endSpace, list, 0);
      0|          _table.setRange(0, preSpace, list, endSpace);
      0|          _tail = preSpace;
       |        }
       |      }
       |    } else {
      0|      for (E element in elements) _add(element);
       |    }
       |  }
       |
      0|  String toString() => IterableBase.iterableToFullString(this, "{", "}");
       |
       |  // Queue interface.
       |
      0|  void addLast(E element) { _add(element); }
       |
       |  void addFirst(E element) {
      0|    _head = (_head - 1) & (_table.length - 1);
      0|    _table[_head] = element;
      0|    if (_head == _tail) _grow();
       |  }
       |
       |  E removeFirst() {
      0|    if (_head == _tail) throw new StateError("No element");
      0|    E result = _table[_head];
      0|    _table[_head] = null;
      0|    _head = (_head + 1) & (_table.length - 1);
       |    return result;
       |  }
       |
       |  E removeLast() {
      0|    if (_head == _tail) throw new StateError("No element");
      0|    _tail = (_tail - 1) & (_table.length - 1);
      0|    E result = _table[_tail];
      0|    _table[_tail] = null;
       |    return result;
       |  }
       |
       |  // List interface.
       |
      7|  int get length => (_tail - _head) & (_table.length - 1);
       |
       |  void set length(int value) {
      1|    if (value < 0) throw new RangeError("Length $value may not be negative.");
       |
      2|    int delta = value - length;
      1|    if (delta >= 0) {
      0|      if (_table.length <= value) {
      0|        _preGrow(value);
       |      }
      0|      _tail = (_tail + delta) & (_table.length - 1);
       |      return;
       |    }
       |
      2|    int newTail = _tail + delta; // [delta] is negative.
      1|    if (newTail >= 0) {
      3|      _table.fillRange(newTail, _tail, null);
       |    } else { 
      0|      newTail += _table.length;
      0|      _table.fillRange(0, _tail, null);
      0|      _table.fillRange(newTail, _table.length, null);
       |    }
      1|    _tail = newTail;
       |  }
       |
       |  E operator [](int index) {
      3|    if (index < 0 || index >= length) {
      0|      throw new RangeError("Index $index must be in the range [0..$length).");
       |    }
       |
      8|    return _table[(_head + index) & (_table.length - 1)];
       |  }
       |
       |  void operator[]=(int index, E value) {
      0|    if (index < 0 || index >= length) {
      0|      throw new RangeError("Index $index must be in the range [0..$length).");
       |    }
       |
      0|    _table[(_head + index) & (_table.length - 1)] = value;
       |  }
       |
       |  // Internal helper functions.
       |
       |  /// Whether [number] is a power of two.
       |  ///
       |  /// Only works for positive numbers.
      0|  static bool _isPowerOf2(int number) => (number & (number - 1)) == 0;
       |
       |  /// Rounds [number] up to the nearest power of 2.
       |  ///
       |  /// If [number] is a power of 2 already, it is returned.
       |  ///
       |  /// Only works for positive numbers.
       |  static int _nextPowerOf2(int number) {
       |    assert(number > 0);
      0|    number = (number << 1) - 1;
       |    for(;;) {
      0|      int nextNumber = number & (number - 1);
      0|      if (nextNumber == 0) return number;
       |      number = nextNumber;
       |    }
       |  }
       |
       |  /// Adds element at end of queue. Used by both [add] and [addAll].
       |  void _add(E element) {
      3|    _table[_tail] = element;
      7|    _tail = (_tail + 1) & (_table.length - 1);
      3|    if (_head == _tail) _grow();
       |  }
       |
       |  /// Grow the table when full.
       |  void _grow() {
      0|    List<E> newTable = new List<E>(_table.length * 2);
      0|    int split = _table.length - _head;
      0|    newTable.setRange(0, split, _table, _head);
      0|    newTable.setRange(split, split + _head, _table, 0);
      0|    _head = 0;
      0|    _tail = _table.length;
      0|    _table = newTable;
       |  }
       |
       |  int _writeToList(List<E> target) {
       |    assert(target.length >= length);
      0|    if (_head <= _tail) {
      0|      int length = _tail - _head;
      0|      target.setRange(0, length, _table, _head);
       |      return length;
       |    } else {
      0|      int firstPartSize = _table.length - _head;
      0|      target.setRange(0, firstPartSize, _table, _head);
      0|      target.setRange(firstPartSize, firstPartSize + _tail, _table, 0);
      0|      return _tail + firstPartSize;
       |    }
       |  }
       |
       |  /// Grows the table even if it is not full.
       |  void _preGrow(int newElementCount) {
       |    assert(newElementCount >= length);
       |
       |    // Add 1.5x extra room to ensure that there's room for more elements after
       |    // expansion.
      0|    newElementCount += newElementCount >> 1;
      0|    int newCapacity = _nextPowerOf2(newElementCount);
      0|    List<E> newTable = new List<E>(newCapacity);
      0|    _tail = _writeToList(newTable);
      0|    _table = newTable;
      0|    _head = 0;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/union_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'unmodifiable_wrappers.dart';
       |
       |/// A single set that provides a view of the union over a set of sets.
       |///
       |/// Since this is just a view, it reflects all changes in the underlying sets.
       |///
       |/// If an element is in multiple sets and the outer set is ordered, the version
       |/// in the earliest inner set is preferred. Component sets are assumed to use
       |/// `==` and `hashCode` for equality.
       |class UnionSet<E> extends SetBase<E> with UnmodifiableSetMixin<E> {
       |  /// The set of sets that this provides a view of.
       |  final Set<Set<E>> _sets;
       |
       |  /// Whether the sets in [_sets] are guaranteed to be disjoint.
       |  final bool _disjoint;
       |
       |  /// Creates a new set that's a view of the union of all sets in [sets].
       |  ///
       |  /// If any sets in [sets] change, this [UnionSet] reflects that change. If a
       |  /// new set is added to [sets], this [UnionSet] reflects that as well.
       |  ///
       |  /// If [disjoint] is `true`, then all component sets must be disjoint. That
       |  /// is, that they contain no elements in common. This makes many operations
       |  /// including [length] more efficient. If the component sets turn out not to
       |  /// be disjoint, some operations may behave inconsistently.
      1|  UnionSet(this._sets, {bool disjoint: false}) : _disjoint = disjoint;
       |
       |  /// Creates a new set that's a view of the union of all sets in [sets].
       |  ///
       |  /// If any sets in [sets] change, this [UnionSet] reflects that change.
       |  /// However, unlike [new UnionSet], this creates a copy of its parameter, so
       |  /// changes in [sets] aren't reflected in this [UnionSet].
       |  ///
       |  /// If [disjoint] is `true`, then all component sets must be disjoint. That
       |  /// is, that they contain no elements in common. This makes many operations
       |  /// including [length] more efficient. If the component sets turn out not to
       |  /// be disjoint, some operations may behave inconsistently.
       |  UnionSet.from(Iterable<Set<E>> sets, {bool disjoint: false})
      2|      : this(sets.toSet(), disjoint: disjoint);
       |
      1|  int get length => _disjoint
      4|      ? _sets.fold(0, (length, set) => length + set.length)
      0|      : _iterable.length;
       |
      2|  Iterator<E> get iterator => _iterable.iterator;
       |
       |  /// Returns an iterable over the contents of all the sets in [this].
       |  Iterable<E> get _iterable =>
      3|      _disjoint ? _sets.expand((set) => set) : _dedupIterable;
       |
       |  /// Returns an iterable over the contents of all the sets in [this] that
       |  /// de-duplicates elements.
       |  ///
       |  /// If the sets aren't guaranteed to be disjoint, this keeps track of the
       |  /// elements we've already emitted so that we can de-duplicate them.
       |  Iterable<E> get _dedupIterable {
      0|    var seen = new Set<E>();
      0|    return _sets.expand((set) => set).where((element) {
      0|      if (seen.contains(element)) return false;
      0|      seen.add(element);
       |      return true;
       |    });
       |  }
       |
      0|  bool contains(Object element) => _sets.any((set) => set.contains(element));
       |
       |  E lookup(Object element) {
       |    if (element == null) return null;
       |
      0|    return _sets
      0|        .map((set) => set.lookup(element))
      0|        .firstWhere((result) => result != null, orElse: () => null);
       |  }
       |
       |  Set<E> toSet() {
      0|    var result = new Set<E>();
      0|    for (var set in _sets) {
      0|      result.addAll(set);
       |    }
       |    return result;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/union_set_controller.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'union_set.dart';
       |
       |/// A controller that exposes a view of the union of a collection of sets.
       |///
       |/// This is a convenience class for creating a [UnionSet] whose contents change
       |/// over the lifetime of a class. For example:
       |///
       |/// ```dart
       |/// class Engine {
       |///   Set<Test> get activeTests => _activeTestsGroup.set;
       |///   final _activeTestsGroup = new UnionSetController<Test>();
       |///
       |///   void addSuite(Suite suite) {
       |///     _activeTestsGroup.add(suite.tests);
       |///     _runSuite(suite);
       |///     _activeTestsGroup.remove(suite.tests);
       |///   }
       |/// }
       |/// ```
       |class UnionSetController<E> {
       |  /// The [UnionSet] that provides a view of the union of sets in [this].
      1|  UnionSet<E> get set => _set;
       |  UnionSet<E> _set;
       |
       |  /// The sets whose union is exposed through [set].
       |  final _sets = new Set<Set<E>>();
       |
       |  /// Creates a set of sets that provides a view of the union of those sets.
       |  ///
       |  /// If [disjoint] is `true`, this assumes that all component sets are
       |  /// disjoint—that is, that they contain no elements in common. This makes
       |  /// many operations including [length] more efficient.
      1|  UnionSetController({bool disjoint: false}) {
      3|    _set = new UnionSet<E>(_sets, disjoint: disjoint);
       |  }
       |
       |  /// Adds the contents of [component] to [set].
       |  ///
       |  /// If the contents of [component] change over time, [set] will change
       |  /// accordingly.
       |  void add(Set<E> component) {
      2|    _sets.add(component);
       |  }
       |
       |  /// Removes the contents of [component] to [set].
       |  ///
       |  /// If another set in [this] has overlapping elements with [component], those
       |  /// elements will remain in [set].
      0|  bool remove(Set<E> component) => _sets.remove(component);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/wrappers.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:collection";
       |import "dart:math" as math;
       |
       |import "typed_wrappers.dart";
       |import "unmodifiable_wrappers.dart";
       |
       |typedef K _KeyForValue<K, V>(V value);
       |
       |/// A base class for delegating iterables.
       |///
       |/// Subclasses can provide a [_base] that should be delegated to. Unlike
       |/// [DelegatingIterable], this allows the base to be created on demand.
       |abstract class _DelegatingIterableBase<E> implements Iterable<E> {
       |  Iterable<E> get _base;
       |
      1|  const _DelegatingIterableBase();
       |
      0|  bool any(bool test(E element)) => _base.any(test);
       |
      0|  bool contains(Object element) => _base.contains(element);
       |
      0|  E elementAt(int index) => _base.elementAt(index);
       |
      0|  bool every(bool test(E element)) => _base.every(test);
       |
       |  Iterable/*<T>*/ expand/*<T>*/(Iterable/*<T>*/ f(E element)) =>
      0|      _base.expand(f);
       |
      0|  E get first => _base.first;
       |
       |  E firstWhere(bool test(E element), {E orElse()}) =>
      0|      _base.firstWhere(test, orElse: orElse);
       |
       |  /*=T*/ fold/*<T>*/(
       |          /*=T*/ initialValue,
       |          /*=T*/ combine(/*=T*/ previousValue, E element)) =>
      0|      _base.fold(initialValue, combine);
       |
      0|  void forEach(void f(E element)) => _base.forEach(f);
       |
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      2|  Iterator<E> get iterator => _base.iterator;
       |
      0|  String join([String separator = ""]) => _base.join(separator);
       |
      0|  E get last => _base.last;
       |
       |  E lastWhere(bool test(E element), {E orElse()}) =>
      0|      _base.lastWhere(test, orElse: orElse);
       |
      2|  int get length => _base.length;
       |
      0|  Iterable/*<T>*/ map/*<T>*/(/*=T*/ f(E element)) => _base.map(f);
       |
      0|  E reduce(E combine(E value, E element)) => _base.reduce(combine);
       |
      0|  E get single => _base.single;
       |
      0|  E singleWhere(bool test(E element)) => _base.singleWhere(test);
       |
      0|  Iterable<E> skip(int n) => _base.skip(n);
       |
      0|  Iterable<E> skipWhile(bool test(E value)) => _base.skipWhile(test);
       |
      0|  Iterable<E> take(int n) => _base.take(n);
       |
      0|  Iterable<E> takeWhile(bool test(E value)) => _base.takeWhile(test);
       |
      0|  List<E> toList({bool growable: true}) => _base.toList(growable: growable);
       |
      0|  Set<E> toSet() => _base.toSet();
       |
      2|  Iterable<E> where(bool test(E element)) => _base.where(test);
       |
      0|  String toString() => _base.toString();
       |}
       |
       |/// An [Iterable] that delegates all operations to a base iterable.
       |///
       |/// This class can be used to hide non-`Iterable` methods of an iterable object,
       |/// or it can be extended to add extra functionality on top of an existing
       |/// iterable object.
       |class DelegatingIterable<E> extends _DelegatingIterableBase<E> {
       |  final Iterable<E> _base;
       |
       |  /// Creates a wrapper that forwards operations to [base].
      1|  const DelegatingIterable(Iterable<E> base) : _base = base;
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts an [Iterable] without a generic type to an
       |  /// `Iterable<E>` by asserting that its elements are instances of `E` whenever
       |  /// they're accessed. If they're not, it throws a [CastError].
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already an `Iterable<E>`, it's returned
       |  /// unmodified.
       |  static Iterable/*<E>*/ typed/*<E>*/(Iterable base) =>
      0|      base is Iterable/*<E>*/ ? base : new TypeSafeIterable/*<E>*/(base);
       |}
       |
       |
       |/// A [List] that delegates all operations to a base list.
       |///
       |/// This class can be used to hide non-`List` methods of a list object, or it
       |/// can be extended to add extra functionality on top of an existing list
       |/// object.
       |class DelegatingList<E> extends DelegatingIterable<E> implements List<E> {
      0|  const DelegatingList(List<E> base) : super(base);
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts a [List] without a generic type to a `List<E>` by
       |  /// asserting that its elements are instances of `E` whenever they're
       |  /// accessed. If they're not, it throws a [CastError]. Note that even if an
       |  /// operation throws a [CastError], it may still mutate the underlying
       |  /// collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `List<E>`, it's returned
       |  /// unmodified.
       |  static List/*<E>*/ typed/*<E>*/(List base) =>
      0|      base is List/*<E>*/ ? base : new TypeSafeList/*<E>*/(base);
       |
      0|  List<E> get _listBase => _base;
       |
      0|  E operator [](int index) => _listBase[index];
       |
       |  void operator []=(int index, E value) {
      0|    _listBase[index] = value;
       |  }
       |
       |  void add(E value) {
      0|    _listBase.add(value);
       |  }
       |
       |  void addAll(Iterable<E> iterable) {
      0|    _listBase.addAll(iterable);
       |  }
       |
      0|  Map<int, E> asMap() => _listBase.asMap();
       |
       |  void clear() {
      0|    _listBase.clear();
       |  }
       |
       |  void fillRange(int start, int end, [E fillValue]) {
      0|    _listBase.fillRange(start, end, fillValue);
       |  }
       |
      0|  Iterable<E> getRange(int start, int end) => _listBase.getRange(start, end);
       |
      0|  int indexOf(E element, [int start = 0]) => _listBase.indexOf(element, start);
       |
       |  void insert(int index, E element) {
      0|    _listBase.insert(index, element);
       |  }
       |
       |  void insertAll(int index, Iterable<E> iterable) {
      0|    _listBase.insertAll(index, iterable);
       |  }
       |
       |  int lastIndexOf(E element, [int start]) =>
      0|      _listBase.lastIndexOf(element, start);
       |
       |  void set length(int newLength) {
      0|    _listBase.length = newLength;
       |  }
       |
      0|  bool remove(Object value) => _listBase.remove(value);
       |
      0|  E removeAt(int index) => _listBase.removeAt(index);
       |
      0|  E removeLast() => _listBase.removeLast();
       |
       |  void removeRange(int start, int end) {
      0|    _listBase.removeRange(start, end);
       |  }
       |
       |  void removeWhere(bool test(E element)) {
      0|    _listBase.removeWhere(test);
       |  }
       |
       |  void replaceRange(int start, int end, Iterable<E> iterable) {
      0|    _listBase.replaceRange(start, end, iterable);
       |  }
       |
       |  void retainWhere(bool test(E element)) {
      0|    _listBase.retainWhere(test);
       |  }
       |
      0|  Iterable<E> get reversed => _listBase.reversed;
       |
       |  void setAll(int index, Iterable<E> iterable) {
      0|    _listBase.setAll(index, iterable);
       |  }
       |
       |  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {
      0|    _listBase.setRange(start, end, iterable, skipCount);
       |  }
       |
       |  void shuffle([math.Random random]) {
      0|    _listBase.shuffle(random);
       |  }
       |
       |  void sort([int compare(E a, E b)]) {
      0|    _listBase.sort(compare);
       |  }
       |
      0|  List<E> sublist(int start, [int end]) => _listBase.sublist(start, end);
       |}
       |
       |
       |/// A [Set] that delegates all operations to a base set.
       |///
       |/// This class can be used to hide non-`Set` methods of a set object, or it can
       |/// be extended to add extra functionality on top of an existing set object.
       |class DelegatingSet<E> extends DelegatingIterable<E> implements Set<E> {
      1|  const DelegatingSet(Set<E> base) : super(base);
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts a [Set] without a generic type to a `Set<E>` by
       |  /// asserting that its elements are instances of `E` whenever they're
       |  /// accessed. If they're not, it throws a [CastError]. Note that even if an
       |  /// operation throws a [CastError], it may still mutate the underlying
       |  /// collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `Set<E>`, it's returned
       |  /// unmodified.
       |  static Set/*<E>*/ typed/*<E>*/(Set base) =>
      0|      base is Set/*<E>*/ ? base : new TypeSafeSet/*<E>*/(base);
       |
      1|  Set<E> get _setBase => _base;
       |
      0|  bool add(E value) => _setBase.add(value);
       |
       |  void addAll(Iterable<E> elements) {
      0|    _setBase.addAll(elements);
       |  }
       |
       |  void clear() {
      0|    _setBase.clear();
       |  }
       |
      0|  bool containsAll(Iterable<Object> other) => _setBase.containsAll(other);
       |
      0|  Set<E> difference(Set<Object> other) => _setBase.difference(other);
       |
      0|  Set<E> intersection(Set<Object> other) => _setBase.intersection(other);
       |
      0|  E lookup(Object element) => _setBase.lookup(element);
       |
      0|  bool remove(Object value) => _setBase.remove(value);
       |
       |  void removeAll(Iterable<Object> elements) {
      0|    _setBase.removeAll(elements);
       |  }
       |
       |  void removeWhere(bool test(E element)) {
      0|    _setBase.removeWhere(test);
       |  }
       |
       |  void retainAll(Iterable<Object> elements) {
      0|    _setBase.retainAll(elements);
       |  }
       |
       |  void retainWhere(bool test(E element)) {
      0|    _setBase.retainWhere(test);
       |  }
       |
      2|  Set<E> union(Set<E> other) => _setBase.union(other);
       |
      0|  Set<E> toSet() => new DelegatingSet<E>(_setBase.toSet());
       |}
       |
       |/// A [Queue] that delegates all operations to a base queue.
       |///
       |/// This class can be used to hide non-`Queue` methods of a queue object, or it
       |/// can be extended to add extra functionality on top of an existing queue
       |/// object.
       |class DelegatingQueue<E> extends DelegatingIterable<E> implements Queue<E> {
      0|  const DelegatingQueue(Queue<E> queue) : super(queue);
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts a [Queue] without a generic type to a `Queue<E>` by
       |  /// asserting that its elements are instances of `E` whenever they're
       |  /// accessed. If they're not, it throws a [CastError]. Note that even if an
       |  /// operation throws a [CastError], it may still mutate the underlying
       |  /// collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `Queue<E>`, it's returned
       |  /// unmodified.
       |  static Queue/*<E>*/ typed/*<E>*/(Queue base) =>
      0|      base is Queue/*<E>*/ ? base : new TypeSafeQueue/*<E>*/(base);
       |
      0|  Queue<E> get _baseQueue => _base;
       |
       |  void add(E value) {
      0|    _baseQueue.add(value);
       |  }
       |
       |  void addAll(Iterable<E> iterable) {
      0|    _baseQueue.addAll(iterable);
       |  }
       |
       |  void addFirst(E value) {
      0|    _baseQueue.addFirst(value);
       |  }
       |
       |  void addLast(E value) {
      0|    _baseQueue.addLast(value);
       |  }
       |
       |  void clear() {
      0|    _baseQueue.clear();
       |  }
       |
      0|  bool remove(Object object) => _baseQueue.remove(object);
       |
      0|  void removeWhere(bool test(E element)) { _baseQueue.removeWhere(test); }
       |
      0|  void retainWhere(bool test(E element)) { _baseQueue.retainWhere(test); }
       |
      0|  E removeFirst() => _baseQueue.removeFirst();
       |
      0|  E removeLast() => _baseQueue.removeLast();
       |}
       |
       |/// A [Map] that delegates all operations to a base map.
       |///
       |/// This class can be used to hide non-`Map` methods of an object that extends
       |/// `Map`, or it can be extended to add extra functionality on top of an
       |/// existing map object.
       |class DelegatingMap<K, V> implements Map<K, V> {
       |  final Map<K, V> _base;
       |
      0|  const DelegatingMap(Map<K, V> base) : _base = base;
       |
       |  /// Creates a wrapper that asserts the types of keys and values in [base].
       |  ///
       |  /// This soundly converts a [Map] without generic types to a `Map<K, V>` by
       |  /// asserting that its keys are instances of `E` and its values are instances
       |  /// of `V` whenever they're accessed. If they're not, it throws a [CastError].
       |  /// Note that even if an operation throws a [CastError], it may still mutate
       |  /// the underlying collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `Map<K, V>`, it's returned
       |  /// unmodified.
       |  static Map/*<K, V>*/ typed/*<K, V>*/(Map base) =>
      0|      base is Map/*<K, V>*/ ? base : new TypeSafeMap/*<K, V>*/(base);
       |
      0|  V operator [](Object key) => _base[key];
       |
       |  void operator []=(K key, V value) {
      0|    _base[key] = value;
       |  }
       |
       |  void addAll(Map<K, V> other) {
      0|    _base.addAll(other);
       |  }
       |
       |  void clear() {
      0|    _base.clear();
       |  }
       |
      0|  bool containsKey(Object key) => _base.containsKey(key);
       |
      0|  bool containsValue(Object value) => _base.containsValue(value);
       |
       |  void forEach(void f(K key, V value)) {
      0|    _base.forEach(f);
       |  }
       |
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      0|  Iterable<K> get keys => _base.keys;
       |
      0|  int get length => _base.length;
       |
      0|  V putIfAbsent(K key, V ifAbsent()) => _base.putIfAbsent(key, ifAbsent);
       |
      0|  V remove(Object key) => _base.remove(key);
       |
      0|  Iterable<V> get values => _base.values;
       |
      0|  String toString() => _base.toString();
       |}
       |
       |/// An unmodifiable [Set] view of the keys of a [Map].
       |///
       |/// The set delegates all operations to the underlying map.
       |///
       |/// A `Map` can only contain each key once, so its keys can always
       |/// be viewed as a `Set` without any loss, even if the [Map.keys]
       |/// getter only shows an [Iterable] view of the keys.
       |///
       |/// Note that [lookup] is not supported for this set.
       |class MapKeySet<E> extends _DelegatingIterableBase<E>
       |    with UnmodifiableSetMixin<E> {
       |  final Map<E, dynamic> _baseMap;
       |
      0|  MapKeySet(Map<E, dynamic> base) : _baseMap = base;
       |
      0|  Iterable<E> get _base => _baseMap.keys;
       |
      0|  bool contains(Object element) => _baseMap.containsKey(element);
       |
      0|  bool get isEmpty => _baseMap.isEmpty;
       |
      0|  bool get isNotEmpty => _baseMap.isNotEmpty;
       |
      0|  int get length => _baseMap.length;
       |
      0|  String toString() => "{${_base.join(', ')}}";
       |
      0|  bool containsAll(Iterable<Object> other) => other.every(contains);
       |
       |  /// Returns a new set with the the elements of [this] that are not in [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// not elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
       |  Set<E> difference(Set<Object> other) =>
      0|      where((element) => !other.contains(element)).toSet();
       |
       |  /// Returns a new set which is the intersection between [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// also elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  Set<E> intersection(Set<Object> other) => where(other.contains).toSet();
       |
       |  /// Throws an [UnsupportedError] since there's no corresponding method for
       |  /// [Map]s.
      0|  E lookup(E element) => throw new UnsupportedError(
       |      "MapKeySet doesn't support lookup().");
       |
       |  /// Returns a new set which contains all the elements of [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] and all
       |  /// the elements of [other].
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  Set<E> union(Set<E> other) => toSet()..addAll(other);
       |}
       |
       |/// Creates a modifiable [Set] view of the values of a [Map].
       |///
       |/// The `Set` view assumes that the keys of the `Map` can be uniquely determined
       |/// from the values. The `keyForValue` function passed to the constructor finds
       |/// the key for a single value. The `keyForValue` function should be consistent
       |/// with equality. If `value1 == value2` then `keyForValue(value1)` and
       |/// `keyForValue(value2)` should be considered equal keys by the underlying map,
       |/// and vice versa.
       |///
       |/// Modifying the set will modify the underlying map based on the key returned
       |/// by `keyForValue`.
       |///
       |/// If the `Map` contents are not compatible with the `keyForValue` function,
       |/// the set will not work consistently, and may give meaningless responses or do
       |/// inconsistent updates.
       |///
       |/// This set can, for example, be used on a map from database record IDs to the
       |/// records. It exposes the records as a set, and allows for writing both
       |/// `recordSet.add(databaseRecord)` and `recordMap[id]`.
       |///
       |/// Effectively, the map will act as a kind of index for the set.
       |class MapValueSet<K, V> extends _DelegatingIterableBase<V> implements Set<V> {
       |  final Map<K, V> _baseMap;
       |  final _KeyForValue<K, V> _keyForValue;
       |
       |  /// Creates a new [MapValueSet] based on [base].
       |  ///
       |  /// [keyForValue] returns the key in the map that should be associated with
       |  /// the given value. The set's notion of equality is identical to the equality
       |  /// of the return values of [keyForValue].
       |  MapValueSet(Map<K, V> base, K keyForValue(V value))
       |      : _baseMap = base,
      0|        _keyForValue = keyForValue;
       |
      0|  Iterable<V> get _base => _baseMap.values;
       |
       |  bool contains(Object element) {
      0|    if (element != null && element is! V) return false;
      0|    var key = _keyForValue(element as V);
       |
      0|    return _baseMap.containsKey(key);
       |  }
       |
      0|  bool get isEmpty => _baseMap.isEmpty;
       |
      0|  bool get isNotEmpty => _baseMap.isNotEmpty;
       |
      0|  int get length => _baseMap.length;
       |
      0|  String toString() => toSet().toString();
       |
       |  bool add(V value) {
      0|    K key = _keyForValue(value);
       |    bool result = false;
      0|    _baseMap.putIfAbsent(key, () {
       |      result = true;
       |      return value;
       |    });
       |    return result;
       |  }
       |
      0|  void addAll(Iterable<V> elements) => elements.forEach(add);
       |
      0|  void clear() => _baseMap.clear();
       |
      0|  bool containsAll(Iterable<Object> other) => other.every(contains);
       |
       |  /// Returns a new set with the the elements of [this] that are not in [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// not elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
       |  Set<V> difference(Set<Object> other) =>
      0|      where((element) => !other.contains(element)).toSet();
       |
       |  /// Returns a new set which is the intersection between [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// also elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  Set<V> intersection(Set<Object> other) => where(other.contains).toSet();
       |
       |  V lookup(Object element) {
      0|    if (element != null && element is! V) return null;
      0|    var key = _keyForValue(element as V);
       |
      0|    return _baseMap[key];
       |  }
       |
       |  bool remove(Object element) {
      0|    if (element != null && element is! V) return false;
      0|    var key = _keyForValue(element as V);
       |
      0|    if (!_baseMap.containsKey(key)) return false;
      0|    _baseMap.remove(key);
       |    return true;
       |  }
       |
      0|  void removeAll(Iterable<Object> elements) => elements.forEach(remove);
       |
       |  void removeWhere(bool test(V element)) {
      0|    var toRemove = [];
      0|    _baseMap.forEach((key, value) {
      0|      if (test(value)) toRemove.add(key);
       |    });
      0|    toRemove.forEach(_baseMap.remove);
       |  }
       |
       |  void retainAll(Iterable<Object> elements) {
      0|    var valuesToRetain = new Set<V>.identity();
      0|    for (var element in elements) {
      0|      if (element != null && element is! V) continue;
      0|      var key = _keyForValue(element as V);
       |
      0|      if (!_baseMap.containsKey(key)) continue;
      0|      valuesToRetain.add(_baseMap[key]);
       |    }
       |
      0|    var keysToRemove = [];
      0|    _baseMap.forEach((k, v) {
      0|      if (!valuesToRetain.contains(v)) keysToRemove.add(k);
       |    });
      0|    keysToRemove.forEach(_baseMap.remove);
       |  }
       |
       |  void retainWhere(bool test(V element)) =>
      0|      removeWhere((element) => !test(element));
       |
       |  /// Returns a new set which contains all the elements of [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] and all
       |  /// the elements of [other].
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  Set<V> union(Set<V> other) => toSet()..addAll(other);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/guarantee_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [StreamChannel] that enforces the stream channel guarantees.
       |///
       |/// This is exposed via [new StreamChannel.withGuarantees].
       |class GuaranteeChannel<T> extends StreamChannelMixin<T> {
      0|  Stream<T> get stream => _streamController.stream;
       |
      0|  StreamSink<T> get sink => _sink;
       |  _GuaranteeSink<T> _sink;
       |
       |  /// The controller for [stream].
       |  ///
       |  /// This intermediate controller allows us to continue listening for a done
       |  /// event even after the user has canceled their subscription, and to send our
       |  /// own done event when the sink is closed.
       |  StreamController<T> _streamController;
       |
       |  /// The subscription to the inner stream.
       |  StreamSubscription<T> _subscription;
       |
       |  /// Whether the sink has closed, causing the underlying channel to disconnect.
       |  bool _disconnected = false;
       |
       |  GuaranteeChannel(Stream<T> innerStream, StreamSink<T> innerSink,
      0|      {bool allowSinkErrors: true}) {
      0|    _sink = new _GuaranteeSink<T>(innerSink, this,
       |        allowErrors: allowSinkErrors);
       |
       |    // Enforce the single-subscription guarantee by changing a broadcast stream
       |    // to single-subscription.
      0|    if (innerStream.isBroadcast) {
      0|      innerStream = innerStream.transform(
       |          const SingleSubscriptionTransformer());
       |    }
       |
      0|    _streamController = new StreamController<T>(onListen: () {
       |      // If the sink has disconnected, we've already called
       |      // [_streamController.close].
      0|      if (_disconnected) return;
       |
      0|      _subscription = innerStream.listen(_streamController.add,
      0|          onError: _streamController.addError,
       |          onDone: () {
      0|            _sink._onStreamDisconnected();
      0|            _streamController.close();
       |          });
       |    }, sync: true);
       |  }
       |
       |  /// Called by [_GuaranteeSink] when the user closes it.
       |  ///
       |  /// The sink closing indicates that the connection is closed, so the stream
       |  /// should stop emitting events.
       |  void _onSinkDisconnected() {
      0|    _disconnected = true;
      0|    if (_subscription != null) _subscription.cancel();
      0|    _streamController.close();
       |  }
       |}
       |
       |/// The sink for [GuaranteeChannel].
       |///
       |/// This wraps the inner sink to ignore events and cancel any in-progress
       |/// [addStream] calls when the underlying channel closes.
       |class _GuaranteeSink<T> implements StreamSink<T> {
       |  /// The inner sink being wrapped.
       |  final StreamSink<T> _inner;
       |
       |  /// The [GuaranteeChannel] this belongs to.
       |  final GuaranteeChannel<T> _channel;
       |
      0|  Future get done => _doneCompleter.future;
       |  final _doneCompleter = new Completer();
       |
       |  /// Whether connection is disconnected.
       |  ///
       |  /// This can happen because the stream has emitted a done event, or because
       |  /// the user added an error when [_allowErrors] is `false`.
       |  bool _disconnected = false;
       |
       |  /// Whether the user has called [close].
       |  bool _closed = false;
       |
       |  /// The subscription to the stream passed to [addStream], if a stream is
       |  /// currently being added.
       |  StreamSubscription<T> _addStreamSubscription;
       |
       |  /// The completer for the future returned by [addStream], if a stream is
       |  /// currently being added.
       |  Completer _addStreamCompleter;
       |
       |  /// Whether we're currently adding a stream with [addStream].
      0|  bool get _inAddStream => _addStreamSubscription != null;
       |
       |  /// Whether errors are passed on to the underlying sink.
       |  ///
       |  /// If this is `false`, any error passed to the sink is piped to [done] and
       |  /// the underlying sink is closed.
       |  final bool _allowErrors;
       |
       |  _GuaranteeSink(this._inner, this._channel, {bool allowErrors: true})
      0|      : _allowErrors = allowErrors;
       |
       |  void add(T data) {
      0|    if (_closed) throw new StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_disconnected) return;
       |
      0|    _inner.add(data);
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_closed) throw new StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_disconnected) return;
       |
      0|    _addError(error, stackTrace);
       |  }
       |
       |  /// Like [addError], but doesn't check to ensure that an error can be added.
       |  ///
       |  /// This is called from [addStream], so it shouldn't fail if a stream is being
       |  /// added.
       |  void _addError(error, [StackTrace stackTrace]) {
      0|    if (_allowErrors) {
      0|      _inner.addError(error, stackTrace);
       |      return;
       |    }
       |
      0|    _doneCompleter.completeError(error, stackTrace);
       |
       |    // Treat an error like both the stream and sink disconnecting.
      0|    _onStreamDisconnected();
      0|    _channel._onSinkDisconnected();
       |
       |    // Ignore errors from the inner sink. We're already surfacing one error, and
       |    // if the user handles it we don't want them to have another top-level.
      0|    _inner.close().catchError((_) {});
       |  }
       |
       |  Future addStream(Stream<T> stream) {
      0|    if (_closed) throw new StateError("Cannot add stream after closing.");
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot add stream while adding stream.");
       |    }
      0|    if (_disconnected) return new Future.value();
       |
      0|    _addStreamCompleter = new Completer.sync();
      0|    _addStreamSubscription = stream.listen(
      0|        _inner.add,
      0|        onError: _addError,
      0|        onDone: _addStreamCompleter.complete);
      0|    return _addStreamCompleter.future.then((_) {
      0|      _addStreamCompleter = null;
      0|      _addStreamSubscription = null;
       |    });
       |  }
       |
       |  Future close() {
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot close sink while adding stream.");
       |    }
       |
      0|    if (_closed) return done;
      0|    _closed = true;
       |
      0|    if (!_disconnected) {
      0|      _channel._onSinkDisconnected();
      0|      _doneCompleter.complete(_inner.close());
       |    }
       |
      0|    return done;
       |  }
       |
       |  /// Called by [GuaranteeChannel] when the stream emits a done event.
       |  ///
       |  /// The stream being done indicates that the connection is closed, so the
       |  /// sink should stop forwarding events.
       |  void _onStreamDisconnected() {
      0|    _disconnected = true;
      0|    if (!_doneCompleter.isCompleted) _doneCompleter.complete();
       |
      0|    if (!_inAddStream) return;
      0|    _addStreamCompleter.complete(_addStreamSubscription.cancel());
      0|    _addStreamCompleter = null;
      0|    _addStreamSubscription = null;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/close_guarantee_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [StreamChannel] that specifically enforces the stream channel guarantee
       |/// that closing the sink causes the stream to close before it emits any more
       |/// events
       |///
       |/// This is exposed via [new StreamChannel.withCloseGuarantee].
       |class CloseGuaranteeChannel<T> extends StreamChannelMixin<T> {
      0|  Stream<T> get stream => _stream;
       |  _CloseGuaranteeStream<T> _stream;
       |
      0|  StreamSink<T> get sink => _sink;
       |  _CloseGuaranteeSink<T> _sink;
       |
       |  /// The subscription to the inner stream.
       |  StreamSubscription<T> _subscription;
       |
       |  /// Whether the sink has closed, causing the underlying channel to disconnect.
       |  bool _disconnected = false;
       |
      0|  CloseGuaranteeChannel(Stream<T> innerStream, StreamSink<T> innerSink) {
      0|    _sink = new _CloseGuaranteeSink<T>(innerSink, this);
      0|    _stream = new _CloseGuaranteeStream<T>(innerStream, this);
       |  }
       |}
       |
       |/// The stream for [CloseGuaranteeChannel].
       |///
       |/// This wraps the inner stream to save the subscription on the channel when
       |/// [listen] is called.
       |class _CloseGuaranteeStream<T> extends Stream<T> {
       |  /// The inner stream this is delegating to.
       |  final Stream<T> _inner;
       |
       |  /// The [CloseGuaranteeChannel] this belongs to.
       |  final CloseGuaranteeChannel<T> _channel;
       |
      0|  _CloseGuaranteeStream(this._inner, this._channel);
       |
       |  StreamSubscription<T> listen(void onData(T event),
       |      {Function onError, void onDone(), bool cancelOnError}) {
       |    // If the channel is already disconnected, we shouldn't dispatch anything
       |    // but a done event.
      0|    if (_channel._disconnected) {
       |      onData = null;
       |      onError = null;
       |    }
       |
      0|    var subscription = _inner.listen(onData,
       |        onError: onError, onDone: onDone, cancelOnError: cancelOnError);
      0|    if (!_channel._disconnected) {
      0|      _channel._subscription = subscription;
       |    }
       |    return subscription;
       |  }
       |}
       |
       |/// The sink for [CloseGuaranteeChannel].
       |///
       |/// This wraps the inner sink to cancel the stream subscription when the sink is
       |/// canceled.
       |class _CloseGuaranteeSink<T> extends DelegatingStreamSink<T> {
       |  /// The [CloseGuaranteeChannel] this belongs to.
       |  final CloseGuaranteeChannel<T> _channel;
       |
      0|  _CloseGuaranteeSink(StreamSink<T> inner, this._channel) : super(inner);
       |
       |  Future close() {
      0|    var done = super.close();
      0|    _channel._disconnected = true;
      0|    if (_channel._subscription != null) {
       |      // Don't dispatch anything but a done event.
      0|      _channel._subscription.onData(null);
      0|      _channel._subscription.onError(null);
       |    }
       |    return done;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/stream_channel_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:convert';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |import 'transformer/typed.dart';
       |
       |/// A [StreamChannelTransformer] transforms the events being passed to and
       |/// emitted by a [StreamChannel].
       |///
       |/// This works on the same principle as [StreamTransformer] and
       |/// [StreamSinkTransformer]. Each transformer defines a [bind] method that takes
       |/// in the original [StreamChannel] and returns the transformed version.
       |///
       |/// Transformers must be able to have [bind] called multiple times. If a
       |/// subclass implements [bind] explicitly, it should be sure that the returned
       |/// stream follows the second stream channel guarantee: closing the sink causes
       |/// the stream to close before it emits any more events. This guarantee is
       |/// invalidated when an asynchronous gap is added between the original stream's
       |/// event dispatch and the returned stream's, for example by transforming it
       |/// with a [StreamTransformer]. The guarantee can be easily preserved using [new
       |/// StreamChannel.withCloseGuarantee].
       |class StreamChannelTransformer<S, T> {
       |  /// The transformer to use on the channel's stream.
       |  final StreamTransformer<T, S> _streamTransformer;
       |
       |  /// The transformer to use on the channel's sink.
       |  final StreamSinkTransformer<S, T> _sinkTransformer;
       |
       |  /// Creates a wrapper that coerces the type of [transformer].
       |  ///
       |  /// This soundly converts a [StreamChannelTransformer] to a
       |  /// `StreamChannelTransformer<S, T>`, regardless of its original generic type,
       |  /// by asserting that the events emitted by the transformed channel's stream
       |  /// are instances of `T` whenever they're provided. If they're not, the stream
       |  /// throws a [CastError]. This also means that calls to [StreamSink.add] on
       |  /// the transformed channel's sink may throw a [CastError] if the argument
       |  /// type doesn't match the reified type of the sink.
       |  static StreamChannelTransformer/*<S, T>*/ typed/*<S, T>*/(
       |          StreamChannelTransformer transformer) =>
      0|      transformer is StreamChannelTransformer/*<S, T>*/
       |          ? transformer
      0|          : new TypeSafeStreamChannelTransformer(transformer);
       |
       |  /// Creates a [StreamChannelTransformer] from existing stream and sink
       |  /// transformers.
       |  const StreamChannelTransformer(
      0|      this._streamTransformer, this._sinkTransformer);
       |
       |  /// Creates a [StreamChannelTransformer] from a codec's encoder and decoder.
       |  ///
       |  /// All input to the inner channel's sink is encoded using [Codec.encoder],
       |  /// and all output from its stream is decoded using [Codec.decoder].
       |  StreamChannelTransformer.fromCodec(Codec<S, T> codec)
      0|      : this(
      0|          typedStreamTransformer(codec.decoder),
      0|          StreamSinkTransformer.typed(
      0|              new StreamSinkTransformer.fromStreamTransformer(codec.encoder)));
       |
       |  /// Transforms the events sent to and emitted by [channel].
       |  ///
       |  /// Creates a new channel. When events are passed to the returned channel's
       |  /// sink, the transformer will transform them and pass the transformed
       |  /// versions to `channel.sink`. When events are emitted from the
       |  /// `channel.straem`, the transformer will transform them and pass the
       |  /// transformed versions to the returned channel's stream.
       |  StreamChannel<S> bind(StreamChannel<T> channel) =>
      0|      new StreamChannel<S>.withCloseGuarantee(
      0|          channel.stream.transform(_streamTransformer),
      0|          _sinkTransformer.bind(channel.sink));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/delegating_stream_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_channel.dart';
       |
       |/// A simple delegating wrapper around [StreamChannel].
       |///
       |/// Subclasses can override individual methods, or use this to expose only
       |/// [StreamChannel] methods.
       |class DelegatingStreamChannel<T> extends StreamChannelMixin<T> {
       |  /// The inner channel to which methods are forwarded.
       |  final StreamChannel<T> _inner;
       |
      0|  Stream<T> get stream => _inner.stream;
      0|  StreamSink<T> get sink => _inner.sink;
       |
      0|  DelegatingStreamChannel(this._inner);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/disconnector.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// Allows the caller to force a channel to disconnect.
       |///
       |/// When [disconnect] is called, the channel (or channels) transformed by this
       |/// transformer will act as though the remote end had disconnected—the stream
       |/// will emit a done event, and the sink will ignore future inputs. The inner
       |/// sink will also be closed to notify the remote end of the disconnection.
       |///
       |/// If a channel is transformed after the [disconnect] has been called, it will
       |/// be disconnected immediately.
       |class Disconnector<T> implements StreamChannelTransformer<T, T> {
       |  /// Whether [disconnect] has been called.
      0|  bool get isDisconnected => _disconnectMemo.hasRun;
       |
       |  /// The sinks for transformed channels.
       |  ///
       |  /// Note that we assume that transformed channels provide the stream channel
       |  /// guarantees. This allows us to only track sinks, because we know closing
       |  /// the underlying sink will cause the stream to emit a done event.
       |  final _sinks = <_DisconnectorSink<T>>[];
       |
       |  /// Disconnects all channels that have been transformed.
       |  ///
       |  /// Returns a future that completes when all inner sinks' [StreamSink.close]
       |  /// futures have completed. Note that a [StreamController]'s sink won't close
       |  /// until the corresponding stream has a listener.
      0|  Future disconnect() => _disconnectMemo.runOnce(() {
      0|    var futures = _sinks.map((sink) => sink._disconnect()).toList();
      0|    _sinks.clear();
      0|    return Future.wait(futures, eagerError: true);
       |  });
       |  final _disconnectMemo = new AsyncMemoizer();
       |
       |  StreamChannel<T> bind(StreamChannel<T> channel) {
      0|    return channel.changeSink((innerSink) {
      0|      var sink = new _DisconnectorSink<T>(innerSink);
       |
      0|      if (isDisconnected) {
       |        // Ignore errors here, because otherwise there would be no way for the
       |        // user to handle them gracefully.
      0|        sink._disconnect().catchError((_) {});
       |      } else {
      0|        _sinks.add(sink);
       |      }
       |
       |      return sink;
       |    });
       |  }
       |}
       |
       |/// A sink wrapper that can force a disconnection.
       |class _DisconnectorSink<T> implements StreamSink<T> {
       |  /// The inner sink.
       |  final StreamSink<T> _inner;
       |
      0|  Future get done => _inner.done;
       |
       |  /// Whether [Disconnector.disconnect] has been called.
       |  var _isDisconnected = false;
       |
       |  /// Whether the user has called [close].
       |  var _closed = false;
       |
       |  /// The subscription to the stream passed to [addStream], if a stream is
       |  /// currently being added.
       |  StreamSubscription<T> _addStreamSubscription;
       |
       |  /// The completer for the future returned by [addStream], if a stream is
       |  /// currently being added.
       |  Completer _addStreamCompleter;
       |
       |  /// Whether we're currently adding a stream with [addStream].
      0|  bool get _inAddStream => _addStreamSubscription != null;
       |
      0|  _DisconnectorSink(this._inner);
       |
       |  void add(T data) {
      0|    if (_closed) throw new StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_isDisconnected) return;
       |
      0|    _inner.add(data);
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_closed) throw new StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_isDisconnected) return;
       |
      0|    _inner.addError(error, stackTrace);
       |  }
       |
       |  Future addStream(Stream<T> stream) {
      0|    if (_closed) throw new StateError("Cannot add stream after closing.");
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot add stream while adding stream.");
       |    }
      0|    if (_isDisconnected) return new Future.value();
       |
      0|    _addStreamCompleter = new Completer.sync();
      0|    _addStreamSubscription = stream.listen(
      0|        _inner.add,
      0|        onError: _inner.addError,
      0|        onDone: _addStreamCompleter.complete);
      0|    return _addStreamCompleter.future.then((_) {
      0|      _addStreamCompleter = null;
      0|      _addStreamSubscription = null;
       |    });
       |  }
       |
       |  Future close() {
      0|    if (_inAddStream) {
      0|      throw new StateError("Cannot close sink while adding stream.");
       |    }
       |
      0|    _closed = true;
      0|    return _inner.close();
       |  }
       |
       |  /// Disconnects this sink.
       |  ///
       |  /// This closes the underlying sink and stops forwarding events. It returns
       |  /// the [StreamSink.close] future for the underlying sink.
       |  Future _disconnect() {
      0|    _isDisconnected = true;
      0|    var future = _inner.close();
       |
      0|    if (_inAddStream) {
      0|      _addStreamCompleter.complete(_addStreamSubscription.cancel());
      0|      _addStreamCompleter = null;
      0|      _addStreamSubscription = null;
       |    }
       |
       |    return future;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/isolate_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:isolate';
       |
       |import 'package:async/async.dart';
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [StreamChannel] that communicates over a [ReceivePort]/[SendPort] pair,
       |/// presumably with another isolate.
       |///
       |/// The remote endpoint doesn't necessarily need to be running an
       |/// [IsolateChannel]. This can be used with any two ports, although the
       |/// [StreamChannel] semantics mean that this class will treat them as being
       |/// paired (for example, closing the [sink] will cause the [stream] to stop
       |/// emitting events).
       |///
       |/// The underlying isolate ports have no notion of closing connections. This
       |/// means that [stream] won't close unless [sink] is closed, and that closing
       |/// [sink] won't cause the remote endpoint to close. Users should take care to
       |/// ensure that they always close the [sink] of every [IsolateChannel] they use
       |/// to avoid leaving dangling [ReceivePort]s.
       |class IsolateChannel<T> extends StreamChannelMixin<T> {
       |  final Stream<T> stream;
       |  final StreamSink<T> sink;
       |
       |  /// Connects to a remote channel that was created with
       |  /// [IsolateChannel.connectSend].
       |  ///
       |  /// These constructors establish a connection using only a single
       |  /// [SendPort]/[ReceivePort] pair, as long as each side uses one of the
       |  /// connect constructors.
       |  ///
       |  /// The connection protocol is guaranteed to remain compatible across versions
       |  /// at least until the next major version release. If the protocol is
       |  /// violated, the resulting channel will emit a single value on its stream and
       |  /// then close.
       |  factory IsolateChannel.connectReceive(ReceivePort receivePort) {
       |    // We can't use a [StreamChannelCompleter] here because we need the return
       |    // value to be an [IsolateChannel].
      0|    var streamCompleter = new StreamCompleter<T>();
      0|    var sinkCompleter = new StreamSinkCompleter<T>();
      0|    var channel = new IsolateChannel<T>._(
      0|        streamCompleter.stream, sinkCompleter.sink);
       |
       |    // The first message across the ReceivePort should be a SendPort pointing to
       |    // the remote end. If it's not, we'll make the stream emit an error
       |    // complaining.
       |    var subscription;
      0|    subscription = receivePort.listen((message) {
      0|      if (message is SendPort) {
      0|        var controller = new StreamChannelController<T>(
       |            allowForeignErrors: false, sync: true);
      0|        new SubscriptionStream(subscription).pipe(controller.local.sink);
      0|        controller.local.stream.listen(
      0|            (data) => message.send(data),
      0|            onDone: receivePort.close);
       |
      0|        streamCompleter.setSourceStream(controller.foreign.stream);
      0|        sinkCompleter.setDestinationSink(controller.foreign.sink);
       |        return;
       |      }
       |
      0|      streamCompleter.setError(
      0|          new StateError('Unexpected Isolate response "$message".'),
      0|          new Trace.current());
      0|      sinkCompleter.setDestinationSink(new NullStreamSink<T>());
      0|      subscription.cancel();
       |    });
       |
       |    return channel;
       |  }
       |
       |  /// Connects to a remote channel that was created with
       |  /// [IsolateChannel.connectReceive].
       |  ///
       |  /// These constructors establish a connection using only a single
       |  /// [SendPort]/[ReceivePort] pair, as long as each side uses one of the
       |  /// connect constructors.
       |  ///
       |  /// The connection protocol is guaranteed to remain compatible across versions
       |  /// at least until the next major version release.
       |  factory IsolateChannel.connectSend(SendPort sendPort) {
      0|    var receivePort = new ReceivePort();
      0|    sendPort.send(receivePort.sendPort);
      0|    return new IsolateChannel(receivePort, sendPort);
       |  }
       |
       |  /// Creates a stream channel that receives messages from [receivePort] and
       |  /// sends them over [sendPort].
       |  factory IsolateChannel(ReceivePort receivePort, SendPort sendPort) {
      0|    var controller = new StreamChannelController<T>(
       |        allowForeignErrors: false, sync: true);
      0|    receivePort.pipe(controller.local.sink);
      0|    controller.local.stream.listen(
      0|        (data) => sendPort.send(data),
      0|        onDone: receivePort.close);
      0|    return new IsolateChannel._(
      0|        controller.foreign.stream, controller.foreign.sink);
       |  }
       |
      0|  IsolateChannel._(this.stream, this.sink);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/json_document_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |import 'stream_channel_transformer.dart';
       |
       |/// The canonical instance of [JsonDocumentTransformer].
       |final jsonDocument = new JsonDocumentTransformer();
       |
       |/// A [StreamChannelTransformer] that transforms JSON documents—strings that
       |/// contain individual objects encoded as JSON—into decoded Dart objects.
       |///
       |/// This decodes JSON that's emitted by the transformed channel's stream, and
       |/// encodes objects so that JSON is passed to the transformed channel's sink.
       |///
       |/// If the transformed channel emits invalid JSON, this emits a
       |/// [FormatException]. If an unencodable object is added to the sink, it
       |/// synchronously throws a [JsonUnsupportedObjectError].
       |class JsonDocumentTransformer
       |    implements StreamChannelTransformer<Object, String> {
       |  /// The underlying codec that implements the encoding and decoding logic.
       |  final JsonCodec _codec;
       |
       |  /// Creates a new transformer.
       |  ///
       |  /// The [reviver] and [toEncodable] arguments work the same way as the
       |  /// corresponding arguments to [new JsonCodec].
       |  JsonDocumentTransformer({reviver(key, value), toEncodable(object)})
      0|      : _codec = new JsonCodec(reviver: reviver, toEncodable: toEncodable);
       |
      0|  JsonDocumentTransformer._(this._codec);
       |
       |  StreamChannel bind(StreamChannel<String> channel) {
      0|    var stream = channel.stream.map(_codec.decode);
      0|    var sink = new StreamSinkTransformer.fromHandlers(handleData: (data, sink) {
      0|      sink.add(_codec.encode(data));
      0|    }).bind(channel.sink);
      0|    return new StreamChannel.withCloseGuarantee(stream, sink);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/multi_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A class that multiplexes multiple virtual channels across a single
       |/// underlying transport layer.
       |///
       |/// This should be connected to another [MultiChannel] on the other end of the
       |/// underlying channel. It starts with a single default virtual channel,
       |/// accessible via [stream] and [sink]. Additional virtual channels can be
       |/// created with [virtualChannel].
       |///
       |/// When a virtual channel is created by one endpoint, the other must connect to
       |/// it before messages may be sent through it. The first endpoint passes its
       |/// [VirtualChannel.id] to the second, which then creates a channel from that id
       |/// also using [virtualChannel]. For example:
       |///
       |/// ```dart
       |/// // First endpoint
       |/// var virtual = multiChannel.virtualChannel();
       |/// multiChannel.sink.add({
       |///   "channel": virtual.id
       |/// });
       |///
       |/// // Second endpoint
       |/// multiChannel.stream.listen((message) {
       |///   var virtual = multiChannel.virtualChannel(message["channel"]);
       |///   // ...
       |/// });
       |/// ```
       |///
       |/// Sending errors across a [MultiChannel] is not supported. Any errors from the
       |/// underlying stream will be reported only via the default
       |/// [MultiChannel.stream].
       |///
       |/// Each virtual channel may be closed individually. When all of them are
       |/// closed, the underlying [StreamSink] is closed automatically.
       |abstract class MultiChannel implements StreamChannel {
       |  /// The default input stream.
       |  ///
       |  /// This connects to the remote [sink].
       |  Stream get stream;
       |
       |  /// The default output stream.
       |  ///
       |  /// This connects to the remote [stream]. If this is closed, the remote
       |  /// [stream] will close, but other virtual channels will remain open and new
       |  /// virtual channels may be opened.
       |  StreamSink get sink;
       |
       |  /// Creates a new [MultiChannel] that sends and receives messages over
       |  /// [inner].
       |  ///
       |  /// The inner channel must take JSON-like objects.
      0|  factory MultiChannel(StreamChannel inner) => new _MultiChannel(inner);
       |
       |  /// Creates a new virtual channel.
       |  ///
       |  /// If [id] is not passed, this creates a virtual channel from scratch. Before
       |  /// it's used, its [VirtualChannel.id] must be sent to the remote endpoint
       |  /// where [virtualChannel] should be called with that id.
       |  ///
       |  /// If [id] is passed, this creates a virtual channel corresponding to the
       |  /// channel with that id on the remote channel.
       |  ///
       |  /// Throws an [ArgumentError] if a virtual channel already exists for [id].
       |  /// Throws a [StateError] if the underlying channel is closed.
       |  VirtualChannel virtualChannel([id]);
       |}
       |
       |/// The implementation of [MultiChannel].
       |///
       |/// This is private so that [VirtualChannel] can inherit from [MultiChannel]
       |/// without having to implement all the private members.
       |class _MultiChannel extends StreamChannelMixin implements MultiChannel {
       |  /// The inner channel over which all communication is conducted.
       |  ///
       |  /// This will be `null` if the underlying communication channel is closed.
       |  StreamChannel _inner;
       |
       |  /// The subscription to [_inner.stream].
       |  StreamSubscription _innerStreamSubscription;
       |
      0|  Stream get stream => _mainController.foreign.stream;
      0|  StreamSink get sink => _mainController.foreign.sink;
       |
       |  /// The controller for this channel.
       |  final _mainController = new StreamChannelController(sync: true);
       |
       |  /// A map from virtual channel ids to [StreamChannelController]s that should
       |  /// be used to communicate over those channels.
       |  final _controllers = <int, StreamChannelController>{};
       |
       |  /// The next id to use for a local virtual channel.
       |  ///
       |  /// Ids are used to identify virtual channels. Each message is tagged with an
       |  /// id; the receiving [MultiChannel] uses this id to look up which
       |  /// [VirtualChannel] the message should be dispatched to.
       |  ///
       |  /// The id scheme for virtual channels is somewhat complicated. This is
       |  /// necessary to ensure that there are no conflicts even when both endpoints
       |  /// have virtual channels with the same id; since both endpoints can send and
       |  /// receive messages across each virtual channel, a naïve scheme would make it
       |  /// impossible to tell whether a message was from a channel that originated in
       |  /// the remote endpoint or a reply on a channel that originated in the local
       |  /// endpoint.
       |  ///
       |  /// The trick is that each endpoint only uses odd ids for its own channels.
       |  /// When sending a message over a channel that was created by the remote
       |  /// endpoint, the channel's id plus one is used. This way each [MultiChannel]
       |  /// knows that if an incoming message has an odd id, it's using the local id
       |  /// scheme, but if it has an even id, it's using the remote id scheme.
       |  var _nextId = 1;
       |
      0|  _MultiChannel(this._inner) {
       |    // The default connection is a special case which has id 0 on both ends.
       |    // This allows it to begin connected without having to send over an id.
      0|    _controllers[0] = _mainController;
      0|    _mainController.local.stream.listen(
      0|        (message) => _inner.sink.add([0, message]),
      0|        onDone: () => _closeChannel(0, 0));
       |
      0|    _innerStreamSubscription = _inner.stream.listen((message) {
      0|      var id = message[0];
      0|      var controller = _controllers[id];
       |
       |      // A controller might not exist if the channel was closed before an
       |      // incoming message was processed.
       |      if (controller == null) return;
      0|      if (message.length > 1) {
      0|        controller.local.sink.add(message[1]);
       |        return;
       |      }
       |
       |      // A message without data indicates that the channel has been closed. We
       |      // can only close the sink here without doing any more cleanup, because
       |      // the sink closing will cause the stream to emit a done event which will
       |      // trigger more cleanup.
      0|      controller.local.sink.close();
       |    },
      0|        onDone: _closeInnerChannel,
      0|        onError: _mainController.local.sink.addError);
       |  }
       |
       |  VirtualChannel virtualChannel([id]) {
       |    var inputId;
       |    var outputId;
       |    if (id != null) {
       |      // Since the user is passing in an id, we're connected to a remote
       |      // VirtualChannel. This means messages they send over this channel will
       |      // have the original odd id, but our replies will have an even id.
       |      inputId = id;
      0|      outputId = (id as int) + 1;
       |    } else {
       |      // Since we're generating an id, we originated this VirtualChannel. This
       |      // means messages we send over this channel will have the original odd id,
       |      // but the remote channel's replies will have an even id.
      0|      inputId = _nextId + 1;
      0|      outputId = _nextId;
      0|      _nextId += 2;
       |    }
       |
       |    // If the inner channel has already closed, create new virtual channels in a
       |    // closed state.
      0|    if (_inner == null) {
      0|      return new VirtualChannel._(
      0|          this, inputId, new Stream.empty(), new NullStreamSink());
       |    }
       |
      0|    if (_controllers.containsKey(inputId)) {
      0|      throw new ArgumentError("A virtual channel with id $id already exists.");
       |    }
       |
      0|    var controller = new StreamChannelController(sync: true);
      0|    _controllers[inputId] = controller;
      0|    controller.local.stream.listen(
      0|        (message) => _inner.sink.add([outputId, message]),
      0|        onDone: () => _closeChannel(inputId, outputId));
       |
      0|    return new VirtualChannel._(
      0|        this, outputId, controller.foreign.stream, controller.foreign.sink);
       |  }
       |
       |  /// Closes the virtual channel for which incoming messages have [inputId] and
       |  /// outgoing messages have [outputId].
       |  void _closeChannel(int inputId, int outputId) {
      0|    var controller = _controllers.remove(inputId);
      0|    controller.local.sink.close();
       |
      0|    if (_inner == null) return;
       |
       |    // A message without data indicates that the virtual channel has been
       |    // closed.
      0|    _inner.sink.add([outputId]);
      0|    if (_controllers.isEmpty) _closeInnerChannel();
       |  }
       |
       |  /// Closes the underlying communication channel.
       |  void _closeInnerChannel() {
      0|    _inner.sink.close();
      0|    _innerStreamSubscription.cancel();
      0|    _inner = null;
       |
       |    // Convert this to a list because the close is dispatched synchronously, and
       |    // that could conceivably remove a controller from [_controllers].
      0|    for (var controller in new List.from(_controllers.values)) {
      0|      controller.local.sink.close();
       |    }
      0|    _controllers.clear();
       |  }
       |}
       |
       |/// A virtual channel created by [MultiChannel].
       |///
       |/// This implements [MultiChannel] for convenience.
       |/// [VirtualChannel.virtualChannel] is semantically identical to the parent's
       |/// [MultiChannel.virtualChannel].
       |class VirtualChannel extends StreamChannelMixin implements MultiChannel {
       |  /// The [MultiChannel] that created this.
       |  final MultiChannel _parent;
       |
       |  /// The identifier for this channel.
       |  ///
       |  /// This can be sent across the [MultiChannel] to provide the remote endpoint
       |  /// a means to connect to this channel. Nothing about this is guaranteed
       |  /// except that it will be JSON-serializable.
       |  final id;
       |
       |  final Stream stream;
       |  final StreamSink sink;
       |
      0|  VirtualChannel._(this._parent, this.id, this.stream, this.sink);
       |
      0|  VirtualChannel virtualChannel([id]) => _parent.virtualChannel(id);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/stream_channel_completer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [channel] where the source and destination are provided later.
       |///
       |/// The [channel] is a normal channel that can be listened to and that events
       |/// can be added to immediately, but until [setChannel] is called it won't emit
       |/// any events and all events added to it will be buffered.
       |class StreamChannelCompleter<T> {
       |  /// The completer for this channel's stream.
       |  final _streamCompleter = new StreamCompleter<T>();
       |
       |  /// The completer for this channel's sink.
       |  final _sinkCompleter = new StreamSinkCompleter<T>();
       |
       |  /// The channel for this completer.
      0|  StreamChannel<T> get channel => _channel;
       |  StreamChannel<T> _channel;
       |
       |  /// Whether [setChannel] has been called.
       |  bool _set = false;
       |
       |  /// Convert a `Future<StreamChannel>` to a `StreamChannel`.
       |  ///
       |  /// This creates a channel using a channel completer, and sets the source
       |  /// channel to the result of the future when the future completes.
       |  ///
       |  /// If the future completes with an error, the returned channel's stream will
       |  /// instead contain just that error. The sink will silently discard all
       |  /// events.
       |  static StreamChannel fromFuture(Future<StreamChannel> channelFuture) {
      0|    var completer = new StreamChannelCompleter();
      0|    channelFuture.then(completer.setChannel, onError: completer.setError);
      0|    return completer.channel;
       |  }
       |
      0|  StreamChannelCompleter() {
      0|    _channel = new StreamChannel<T>(
      0|        _streamCompleter.stream, _sinkCompleter.sink);
       |  }
       |
       |  /// Set a channel as the source and destination for [channel].
       |  ///
       |  /// A channel may be set at most once.
       |  ///
       |  /// Either [setChannel] or [setError] may be called at most once. Trying to
       |  /// call either of them again will fail.
       |  void setChannel(StreamChannel<T> channel) {
      0|    if (_set) throw new StateError("The channel has already been set.");
      0|    _set = true;
       |
      0|    _streamCompleter.setSourceStream(channel.stream);
      0|    _sinkCompleter.setDestinationSink(channel.sink);
       |  }
       |
       |  /// Indicates that there was an error connecting the channel.
       |  ///
       |  /// This makes the stream emit [error] and close. It makes the sink discard
       |  /// all its events.
       |  ///
       |  /// Either [setChannel] or [setError] may be called at most once. Trying to
       |  /// call either of them again will fail.
       |  void setError(error, [StackTrace stackTrace]) {
      0|    if (_set) throw new StateError("The channel has already been set.");
      0|    _set = true;
       |
      0|    _streamCompleter.setError(error, stackTrace);
      0|    _sinkCompleter.setDestinationSink(new NullStreamSink());
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/stream_channel_controller.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_channel.dart';
       |
       |/// A controller for exposing a new [StreamChannel].
       |///
       |/// This exposes two connected [StreamChannel]s, [local] and [foreign]. The
       |/// user's code should use [local] to emit and receive events. Then [foreign]
       |/// can be returned for others to use. For example, here's a simplified version
       |/// of the implementation of [new IsolateChannel]:
       |///
       |/// ```dart
       |/// StreamChannel isolateChannel(ReceivePort receivePort, SendPort sendPort) {
       |///   var controller = new StreamChannelController(allowForeignErrors: false);
       |///
       |///   // Pipe all events from the receive port into the local sink...
       |///   receivePort.pipe(controller.local.sink);
       |///
       |///   // ...and all events from the local stream into the send port.
       |///   controller.local.stream.listen(sendPort.send, onDone: receivePort.close);
       |///
       |///   // Then return the foreign controller for your users to use.
       |///   return controller.foreign;
       |/// }
       |/// ```
       |class StreamChannelController<T> {
       |  /// The local channel.
       |  ///
       |  /// This channel should be used directly by the creator of this
       |  /// [StreamChannelController] to send and receive events.
      0|  StreamChannel<T> get local => _local;
       |  StreamChannel<T> _local;
       |
       |  /// The foreign channel.
       |  ///
       |  /// This channel should be returned to external users so they can communicate
       |  /// with [local].
      0|  StreamChannel<T> get foreign => _foreign;
       |  StreamChannel<T> _foreign;
       |
       |  /// Creates a [StreamChannelController].
       |  ///
       |  /// If [sync] is true, events added to either channel's sink are synchronously
       |  /// dispatched to the other channel's stream. This should only be done if the
       |  /// source of those events is already asynchronous.
       |  ///
       |  /// If [allowForeignErrors] is `false`, errors are not allowed to be passed to
       |  /// the foreign channel's sink. If any are, the connection will close and the
       |  /// error will be forwarded to the foreign channel's [Sink.done] future. This
       |  /// guarantees that the local stream will never emit errors.
      0|  StreamChannelController({bool allowForeignErrors: true, bool sync: false}) {
      0|    var localToForeignController = new StreamController<T>(sync: sync);
      0|    var foreignToLocalController = new StreamController<T>(sync: sync);
      0|    _local = new StreamChannel<T>.withGuarantees(
      0|        foreignToLocalController.stream, localToForeignController.sink);
      0|    _foreign = new StreamChannel<T>.withGuarantees(
      0|        localToForeignController.stream, foreignToLocalController.sink,
       |        allowSinkErrors: allowForeignErrors);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/lazy_chain.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'chain.dart';
       |import 'frame.dart';
       |import 'lazy_trace.dart';
       |import 'trace.dart';
       |
       |/// A thunk for lazily constructing a [Chain].
       |typedef Chain ChainThunk();
       |
       |/// A wrapper around a [ChainThunk]. This works around issue 9579 by avoiding
       |/// the conversion of native [StackTrace]s to strings until it's absolutely
       |/// necessary.
       |class LazyChain implements Chain {
       |  final ChainThunk _thunk;
       |  Chain _inner;
       |
      0|  LazyChain(this._thunk);
       |
       |  Chain get _chain {
      0|    if (_inner == null) _inner = _thunk();
      0|    return _inner;
       |  }
       |
      0|  List<Trace> get traces => _chain.traces;
      0|  Chain get terse => _chain.terse;
       |  Chain foldFrames(bool predicate(Frame frame), {bool terse: false}) =>
      0|      new LazyChain(() => _chain.foldFrames(predicate, terse: terse));
      0|  Trace toTrace() => new LazyTrace(() => _chain.toTrace());
      0|  String toString() => _chain.toString();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/stack_zone_specification.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'chain.dart';
       |import 'lazy_trace.dart';
       |import 'trace.dart';
       |import 'utils.dart';
       |
       |/// A function that handles errors in the zone wrapped by [Chain.capture].
       |typedef void _ChainHandler(error, Chain chain);
       |
       |/// A class encapsulating the zone specification for a [Chain.capture] zone.
       |///
       |/// Until they're materialized and exposed to the user, stack chains are tracked
       |/// as linked lists of [Trace]s using the [_Node] class. These nodes are stored
       |/// in three distinct ways:
       |///
       |/// * When a callback is registered, a node is created and stored as a captured
       |///   local variable until the callback is run.
       |///
       |/// * When a callback is run, its captured node is set as the [_currentNode] so
       |///   it can be available to [Chain.current] and to be linked into additional
       |///   chains when more callbacks are scheduled.
       |///
       |/// * When a callback throws an error or a Future or Stream emits an error, the
       |///   current node is associated with that error's stack trace using the
       |///   [_chains] expando.
       |///
       |/// Since [ZoneSpecification] can't be extended or even implemented, in order to
       |/// get a real [ZoneSpecification] instance it's necessary to call [toSpec].
       |class StackZoneSpecification {
       |  /// An opaque object used as a zone value to disable chain tracking in a given
       |  /// zone.
       |  ///
       |  /// If `Zone.current[disableKey]` is `true`, no stack chains will be tracked.
       |  static final disableKey = new Object();
       |
       |  /// Whether chain-tracking is disabled in the current zone.
      4|  bool get _disabled => Zone.current[disableKey] == true;
       |
       |  /// The expando that associates stack chains with [StackTrace]s.
       |  ///
       |  /// The chains are associated with stack traces rather than errors themselves
       |  /// because it's a common practice to throw strings as errors, which can't be
       |  /// used with expandos.
       |  ///
       |  /// The chain associated with a given stack trace doesn't contain a node for
       |  /// that stack trace.
       |  final _chains = new Expando<_Node>("stack chains");
       |
       |  /// The error handler for the zone.
       |  ///
       |  /// If this is null, that indicates that any unhandled errors should be passed
       |  /// to the parent zone.
       |  final _ChainHandler _onError;
       |
       |  /// The most recent node of the current stack chain.
       |  _Node _currentNode;
       |
      1|  StackZoneSpecification([this._onError]);
       |
       |  /// Converts [this] to a real [ZoneSpecification].
       |  ZoneSpecification toSpec() {
      1|    return new ZoneSpecification(
      1|        handleUncaughtError: _handleUncaughtError,
      1|        registerCallback: _registerCallback,
      1|        registerUnaryCallback: _registerUnaryCallback,
      1|        registerBinaryCallback: _registerBinaryCallback,
      1|        errorCallback: _errorCallback);
       |  }
       |
       |  /// Returns the current stack chain.
       |  ///
       |  /// By default, the first frame of the first trace will be the line where
       |  /// [currentChain] is called. If [level] is passed, the first trace will start
       |  /// that many frames up instead.
      0|  Chain currentChain([int level=0]) => _createNode(level + 1).toChain();
       |
       |  /// Returns the stack chain associated with [trace], if one exists.
       |  ///
       |  /// The first stack trace in the returned chain will always be [trace]
       |  /// (converted to a [Trace] if necessary). If there is no chain associated
       |  /// with [trace], this just returns a single-trace chain containing [trace].
       |  Chain chainFor(StackTrace trace) {
      1|    if (trace is Chain) return trace;
      2|    var previous = trace == null ? null : _chains[trace];
      2|    return new _Node(trace, previous).toChain();
       |  }
       |
       |  /// Tracks the current stack chain so it can be set to [_currentChain] when
       |  /// [f] is run.
       |  ZoneCallback _registerCallback(Zone self, ZoneDelegate parent, Zone zone,
       |      Function f) {
      1|    if (f == null || _disabled) return parent.registerCallback(zone, f);
      1|    var node = _createNode(1);
      2|    return parent.registerCallback(zone, () => _run(f, node));
       |  }
       |
       |  /// Tracks the current stack chain so it can be set to [_currentChain] when
       |  /// [f] is run.
       |  ZoneUnaryCallback _registerUnaryCallback(Zone self, ZoneDelegate parent,
       |      Zone zone, Function f) {
      1|    if (f == null || _disabled) return parent.registerUnaryCallback(zone, f);
      1|    var node = _createNode(1);
      1|    return parent.registerUnaryCallback(zone, (arg) {
      2|      return _run(() => f(arg), node);
       |    });
       |  }
       |
       |  /// Tracks the current stack chain so it can be set to [_currentChain] when
       |  /// [f] is run.
       |  ZoneBinaryCallback _registerBinaryCallback(Zone self, ZoneDelegate parent,
       |      Zone zone, Function f) {
      1|    if (f == null || _disabled) return parent.registerBinaryCallback(zone, f);
       |
      1|    var node = _createNode(1);
      1|    return parent.registerBinaryCallback(zone, (arg1, arg2) {
      2|      return _run(() => f(arg1, arg2), node);
       |    });
       |  }
       |
       |  /// Looks up the chain associated with [stackTrace] and passes it either to
       |  /// [_onError] or [parent]'s error handler.
       |  _handleUncaughtError(Zone self, ZoneDelegate parent, Zone zone, error,
       |      StackTrace stackTrace) {
      0|    if (_disabled) {
      0|      return parent.handleUncaughtError(zone, error, stackTrace);
       |    }
       |
      0|    var stackChain = chainFor(stackTrace);
      0|    if (_onError == null) {
      0|      return parent.handleUncaughtError(zone, error, stackChain);
       |    }
       |
       |    // TODO(nweiz): Currently this copies a lot of logic from [runZoned]. Just
       |    // allow [runBinary] to throw instead once issue 18134 is fixed.
       |    try {
      0|      return parent.runBinary(zone, _onError, error, stackChain);
       |    } catch (newError, newStackTrace) {
       |      if (identical(newError, error)) {
      0|        return parent.handleUncaughtError(zone, error, stackChain);
       |      } else {
      0|        return parent.handleUncaughtError(zone, newError, newStackTrace);
       |      }
       |    }
       |  }
       |
       |  /// Attaches the current stack chain to [stackTrace], replacing it if
       |  /// necessary.
       |  AsyncError _errorCallback(Zone self, ZoneDelegate parent, Zone zone,
       |      Object error, StackTrace stackTrace) {
      1|    if (_disabled) return parent.errorCallback(zone, error, stackTrace);
       |
       |    // Go up two levels to get through [_CustomZone.errorCallback].
       |    if (stackTrace == null) {
      0|      stackTrace = _createNode(2).toChain();
       |    } else {
      5|      if (_chains[stackTrace] == null) _chains[stackTrace] = _createNode(2);
       |    }
       |
      1|    var asyncError = parent.errorCallback(zone, error, stackTrace);
      1|    return asyncError == null ? new AsyncError(error, stackTrace) : asyncError;
       |  }
       |
       |  /// Creates a [_Node] with the current stack trace and linked to
       |  /// [_currentNode].
       |  ///
       |  /// By default, the first frame of the first trace will be the line where
       |  /// [_createNode] is called. If [level] is passed, the first trace will start
       |  /// that many frames up instead.
       |  _Node _createNode([int level=0]) =>
      4|    new _Node(_currentTrace(level + 1), _currentNode);
       |
       |  // TODO(nweiz): use a more robust way of detecting and tracking errors when
       |  // issue 15105 is fixed.
       |  /// Runs [f] with [_currentNode] set to [node].
       |  ///
       |  /// If [f] throws an error, this associates [node] with that error's stack
       |  /// trace.
       |  _run(Function f, _Node node) {
      1|    var previousNode = _currentNode;
      1|    _currentNode = node;
       |    try {
      1|      return f();
       |    } catch (e, stackTrace) {
      0|      _chains[stackTrace] = node;
       |      rethrow;
       |    } finally {
      1|      _currentNode = previousNode;
       |    }
       |  }
       |}
       |
       |/// A linked list node representing a single entry in a stack chain.
       |class _Node {
       |  /// The stack trace for this link of the chain.
       |  final Trace trace;
       |
       |  /// The previous node in the chain.
       |  final _Node previous;
       |
       |  _Node(StackTrace trace, [this.previous])
      2|      : trace = trace == null ? _currentTrace() : new Trace.from(trace);
       |
       |  /// Converts this to a [Chain].
       |  Chain toChain() {
      1|    var nodes = <Trace>[];
       |    var node = this;
       |    while (node != null) {
      2|      nodes.add(node.trace);
      1|      node = node.previous;
       |    }
      1|    return new Chain(nodes);
       |  }
       |}
       |
       |/// Like [new Trace.current], but if the current stack trace has VM chaining
       |/// enabled, this only returns the innermost sub-trace.
       |Trace _currentTrace([int level]) {
       |  level ??= 0;
      1|  var stackTrace = StackTrace.current;
      1|  return new LazyTrace(() {
       |    // Ignore the VM's stack chains when we generate our own. Otherwise we'll
       |    // end up with duplicate frames all over the place.
      1|    var text = stackTrace.toString();
      1|    var index = text.indexOf(vmChainGap);
      1|    if (index != -1) text = text.substring(0, index);
       |
      1|    var trace = new Trace.parse(text);
       |    // JS includes a frame for the call to StackTrace.current, but the VM
       |    // doesn't, so we skip an extra frame in a JS context.
      5|    return new Trace(trace.frames.skip(level + (inJS ? 2 : 1)));
       |  });
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/all.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |
       |/// A selector that matches all inputs.
       |class All implements BooleanSelector {
       |  final variables = const [];
       |
      1|  const All();
       |
       |  bool evaluate(semantics) => true;
       |
       |  BooleanSelector intersection(BooleanSelector other) => other;
       |
       |  BooleanSelector union(BooleanSelector other) => this;
       |
       |  void validate(bool isDefined(String variable)) {}
       |
       |  String toString() => "<all>";
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/impl.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |import 'ast.dart';
       |import 'evaluator.dart';
       |import 'intersection_selector.dart';
       |import 'parser.dart';
       |import 'union_selector.dart';
       |import 'validator.dart';
       |
       |/// The concrete implementation of a [BooleanSelector] parsed from a string.
       |///
       |/// This is separate from [BooleanSelector] so that [intersect] and [union] can
       |/// check to see whether they're passed a [BooleanSelectorImpl] or a different
       |/// class that implements [BooleanSelector].
       |class BooleanSelectorImpl implements BooleanSelector {
       |  /// The parsed AST.
       |  final Node _selector;
       |
       |  /// Parses [selector].
       |  ///
       |  /// This will throw a [SourceSpanFormatException] if the selector is
       |  /// malformed or if it uses an undefined variable.
       |  BooleanSelectorImpl.parse(String selector)
      0|      : _selector = new Parser(selector).parse();
       |
      0|  BooleanSelectorImpl._(this._selector);
       |
      0|  Iterable<String> get variables => _selector.variables;
       |
      0|  bool evaluate(semantics) => _selector.accept(new Evaluator(semantics));
       |
       |  BooleanSelector intersection(BooleanSelector other) {
      0|    if (other == BooleanSelector.all) return this;
      0|    if (other == BooleanSelector.none) return other;
      0|    return other is BooleanSelectorImpl
      0|        ? new BooleanSelectorImpl._(new AndNode(_selector, other._selector))
      0|        : new IntersectionSelector(this, other);
       |  }
       |
       |  BooleanSelector union(BooleanSelector other) {
      0|    if (other == BooleanSelector.all) return other;
      0|    if (other == BooleanSelector.none) return this;
      0|    return other is BooleanSelectorImpl
      0|        ? new BooleanSelectorImpl._(new OrNode(_selector, other._selector))
      0|        : new UnionSelector(this, other);
       |  }
       |
       |  void validate(bool isDefined(String variable)) {
      0|    _selector.accept(new Validator(isDefined));
       |  }
       |
      0|  String toString() => _selector.toString();
       |
       |  bool operator==(other) =>
      0|      other is BooleanSelectorImpl && _selector == other._selector;
       |
      0|  int get hashCode => _selector.hashCode;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/none.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |
       |/// A selector that matches no inputs.
       |class None implements BooleanSelector {
       |  final variables = const [];
       |
      1|  const None();
       |
       |  bool evaluate(semantics) => false;
       |
       |  BooleanSelector intersection(BooleanSelector other) => this;
       |
       |  BooleanSelector union(BooleanSelector other) => other;
       |
       |  void validate(bool isDefined(String variable)) {}
       |
       |  String toString() => "<none>";
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/term_glyph-1.0.0/lib/src/generated.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// Don't modify this file by hand! It's generated by tool/generate.dart.
       |
       |/// Whether the glyph getters return plain ASCII, as opposed to Unicode
       |/// characters or sequences.
       |///
       |/// Defaults to `false`.
       |bool get ascii => _ascii;
       |var _ascii = false;
       |set ascii(bool value) {
       |  _ascii = value;
       |  if (value) {
       |    _bullet = "*";
       |    _leftArrow = "<";
       |    _rightArrow = ">";
       |    _upArrow = "^";
       |    _downArrow = "v";
       |    _longLeftArrow = "<=";
       |    _longRightArrow = "=>";
       |    _horizontalLine = "-";
       |    _verticalLine = "|";
       |    _topLeftCorner = ",";
       |    _topRightCorner = ",";
       |    _bottomLeftCorner = "'";
       |    _bottomRightCorner = "'";
       |    _cross = "+";
       |    _teeUp = "+";
       |    _teeDown = "+";
       |    _teeLeft = "+";
       |    _teeRight = "+";
       |    _upEnd = "'";
       |    _downEnd = ",";
       |    _leftEnd = "-";
       |    _rightEnd = "-";
       |    _horizontalLineBold = "=";
       |    _verticalLineBold = "|";
       |    _topLeftCornerBold = ",";
       |    _topRightCornerBold = ",";
       |    _bottomLeftCornerBold = "'";
       |    _bottomRightCornerBold = "'";
       |    _crossBold = "+";
       |    _teeUpBold = "+";
       |    _teeDownBold = "+";
       |    _teeLeftBold = "+";
       |    _teeRightBold = "+";
       |    _upEndBold = "'";
       |    _downEndBold = ",";
       |    _leftEndBold = "-";
       |    _rightEndBold = "-";
       |    _horizontalLineDouble = "=";
       |    _verticalLineDouble = "|";
       |    _topLeftCornerDouble = ",";
       |    _topRightCornerDouble = ",";
       |    _bottomLeftCornerDouble = '"';
       |    _bottomRightCornerDouble = '"';
       |    _crossDouble = "+";
       |    _teeUpDouble = "+";
       |    _teeDownDouble = "+";
       |    _teeLeftDouble = "+";
       |    _teeRightDouble = "+";
       |    _horizontalLineDoubleDash = "-";
       |    _horizontalLineDoubleDashBold = "-";
       |    _verticalLineDoubleDash = "|";
       |    _verticalLineDoubleDashBold = "|";
       |    _horizontalLineTripleDash = "-";
       |    _horizontalLineTripleDashBold = "-";
       |    _verticalLineTripleDash = "|";
       |    _verticalLineTripleDashBold = "|";
       |    _horizontalLineQuadrupleDash = "-";
       |    _horizontalLineQuadrupleDashBold = "-";
       |    _verticalLineQuadrupleDash = "|";
       |    _verticalLineQuadrupleDashBold = "|";
       |  } else {
       |    _bullet = "•";
       |    _leftArrow = "←";
       |    _rightArrow = "→";
       |    _upArrow = "↑";
       |    _downArrow = "↓";
       |    _longLeftArrow = "◀━";
       |    _longRightArrow = "━▶";
       |    _horizontalLine = "─";
       |    _verticalLine = "│";
       |    _topLeftCorner = "┌";
       |    _topRightCorner = "┐";
       |    _bottomLeftCorner = "└";
       |    _bottomRightCorner = "┘";
       |    _cross = "┼";
       |    _teeUp = "┴";
       |    _teeDown = "┬";
       |    _teeLeft = "┤";
       |    _teeRight = "├";
       |    _upEnd = "╵";
       |    _downEnd = "╷";
       |    _leftEnd = "╴";
       |    _rightEnd = "╶";
       |    _horizontalLineBold = "━";
       |    _verticalLineBold = "┃";
       |    _topLeftCornerBold = "┏";
       |    _topRightCornerBold = "┓";
       |    _bottomLeftCornerBold = "┗";
       |    _bottomRightCornerBold = "┛";
       |    _crossBold = "╋";
       |    _teeUpBold = "┻";
       |    _teeDownBold = "┳";
       |    _teeLeftBold = "┫";
       |    _teeRightBold = "┣";
       |    _upEndBold = "╹";
       |    _downEndBold = "╻";
       |    _leftEndBold = "╸";
       |    _rightEndBold = "╺";
       |    _horizontalLineDouble = "═";
       |    _verticalLineDouble = "║";
       |    _topLeftCornerDouble = "╔";
       |    _topRightCornerDouble = "╗";
       |    _bottomLeftCornerDouble = "╚";
       |    _bottomRightCornerDouble = "╝";
       |    _crossDouble = "╬";
       |    _teeUpDouble = "╩";
       |    _teeDownDouble = "╦";
       |    _teeLeftDouble = "╣";
       |    _teeRightDouble = "╠";
       |    _horizontalLineDoubleDash = "╌";
       |    _horizontalLineDoubleDashBold = "╍";
       |    _verticalLineDoubleDash = "╎";
       |    _verticalLineDoubleDashBold = "╏";
       |    _horizontalLineTripleDash = "┄";
       |    _horizontalLineTripleDashBold = "┅";
       |    _verticalLineTripleDash = "┆";
       |    _verticalLineTripleDashBold = "┇";
       |    _horizontalLineQuadrupleDash = "┈";
       |    _horizontalLineQuadrupleDashBold = "┉";
       |    _verticalLineQuadrupleDash = "┊";
       |    _verticalLineQuadrupleDashBold = "┋";
       |  }
       |}
       |
       |/// A bullet point.
       |///
       |/// If [ascii] is `false`, this is "•". If it's `true`, this is
       |/// "*" instead.
       |String get bullet => _bullet;
       |var _bullet = "•";
       |
       |/// A left-pointing arrow.
       |///
       |/// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |/// terminal fonts, and should generally be surrounding by spaces.
       |///
       |/// If [ascii] is `false`, this is "←". If it's `true`, this is
       |/// "<" instead.
       |String get leftArrow => _leftArrow;
       |var _leftArrow = "←";
       |
       |/// A right-pointing arrow.
       |///
       |/// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |/// terminal fonts, and should generally be surrounding by spaces.
       |///
       |/// If [ascii] is `false`, this is "→". If it's `true`, this is
       |/// ">" instead.
       |String get rightArrow => _rightArrow;
       |var _rightArrow = "→";
       |
       |/// An upwards-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "↑". If it's `true`, this is
       |/// "^" instead.
       |String get upArrow => _upArrow;
       |var _upArrow = "↑";
       |
       |/// A downwards-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "↓". If it's `true`, this is
       |/// "v" instead.
       |String get downArrow => _downArrow;
       |var _downArrow = "↓";
       |
       |/// A two-character left-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "◀━". If it's `true`, this is
       |/// "<=" instead.
       |String get longLeftArrow => _longLeftArrow;
       |var _longLeftArrow = "◀━";
       |
       |/// A two-character right-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "━▶". If it's `true`, this is
       |/// "=>" instead.
       |String get longRightArrow => _longRightArrow;
       |var _longRightArrow = "━▶";
       |
       |/// A horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "─". If it's `true`, this is
       |/// "-" instead.
       |String get horizontalLine => _horizontalLine;
       |var _horizontalLine = "─";
       |
       |/// A vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "│". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLine => _verticalLine;
       |var _verticalLine = "│";
       |
       |/// The upper left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "┌". If it's `true`, this is
       |/// "," instead.
       |String get topLeftCorner => _topLeftCorner;
       |var _topLeftCorner = "┌";
       |
       |/// The upper right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "┐". If it's `true`, this is
       |/// "," instead.
       |String get topRightCorner => _topRightCorner;
       |var _topRightCorner = "┐";
       |
       |/// The lower left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "└". If it's `true`, this is
       |/// "'" instead.
       |String get bottomLeftCorner => _bottomLeftCorner;
       |var _bottomLeftCorner = "└";
       |
       |/// The lower right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "┘". If it's `true`, this is
       |/// "'" instead.
       |String get bottomRightCorner => _bottomRightCorner;
       |var _bottomRightCorner = "┘";
       |
       |/// An intersection of vertical and horizontal box lines.
       |///
       |/// If [ascii] is `false`, this is "┼". If it's `true`, this is
       |/// "+" instead.
       |String get cross => _cross;
       |var _cross = "┼";
       |
       |/// A horizontal box line with a vertical line going up from the middle.
       |///
       |/// If [ascii] is `false`, this is "┴". If it's `true`, this is
       |/// "+" instead.
       |String get teeUp => _teeUp;
       |var _teeUp = "┴";
       |
       |/// A horizontal box line with a vertical line going down from the middle.
       |///
       |/// If [ascii] is `false`, this is "┬". If it's `true`, this is
       |/// "+" instead.
       |String get teeDown => _teeDown;
       |var _teeDown = "┬";
       |
       |/// A vertical box line with a horizontal line going left from the middle.
       |///
       |/// If [ascii] is `false`, this is "┤". If it's `true`, this is
       |/// "+" instead.
       |String get teeLeft => _teeLeft;
       |var _teeLeft = "┤";
       |
       |/// A vertical box line with a horizontal line going right from the middle.
       |///
       |/// If [ascii] is `false`, this is "├". If it's `true`, this is
       |/// "+" instead.
       |String get teeRight => _teeRight;
       |var _teeRight = "├";
       |
       |/// The top half of a vertical box line.
       |///
       |/// If [ascii] is `false`, this is "╵". If it's `true`, this is
       |/// "'" instead.
       |String get upEnd => _upEnd;
       |var _upEnd = "╵";
       |
       |/// The bottom half of a vertical box line.
       |///
       |/// If [ascii] is `false`, this is "╷". If it's `true`, this is
       |/// "," instead.
       |String get downEnd => _downEnd;
       |var _downEnd = "╷";
       |
       |/// The left half of a horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "╴". If it's `true`, this is
       |/// "-" instead.
       |String get leftEnd => _leftEnd;
       |var _leftEnd = "╴";
       |
       |/// The right half of a horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "╶". If it's `true`, this is
       |/// "-" instead.
       |String get rightEnd => _rightEnd;
       |var _rightEnd = "╶";
       |
       |/// A bold horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "━". If it's `true`, this is
       |/// "=" instead.
       |String get horizontalLineBold => _horizontalLineBold;
       |var _horizontalLineBold = "━";
       |
       |/// A bold vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┃". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineBold => _verticalLineBold;
       |var _verticalLineBold = "┃";
       |
       |/// The bold upper left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "┏". If it's `true`, this is
       |/// "," instead.
       |String get topLeftCornerBold => _topLeftCornerBold;
       |var _topLeftCornerBold = "┏";
       |
       |/// The bold upper right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "┓". If it's `true`, this is
       |/// "," instead.
       |String get topRightCornerBold => _topRightCornerBold;
       |var _topRightCornerBold = "┓";
       |
       |/// The bold lower left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "┗". If it's `true`, this is
       |/// "'" instead.
       |String get bottomLeftCornerBold => _bottomLeftCornerBold;
       |var _bottomLeftCornerBold = "┗";
       |
       |/// The bold lower right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "┛". If it's `true`, this is
       |/// "'" instead.
       |String get bottomRightCornerBold => _bottomRightCornerBold;
       |var _bottomRightCornerBold = "┛";
       |
       |/// An intersection of bold vertical and horizontal box lines.
       |///
       |/// If [ascii] is `false`, this is "╋". If it's `true`, this is
       |/// "+" instead.
       |String get crossBold => _crossBold;
       |var _crossBold = "╋";
       |
       |/// A bold horizontal box line with a vertical line going up from the middle.
       |///
       |/// If [ascii] is `false`, this is "┻". If it's `true`, this is
       |/// "+" instead.
       |String get teeUpBold => _teeUpBold;
       |var _teeUpBold = "┻";
       |
       |/// A bold horizontal box line with a vertical line going down from the middle.
       |///
       |/// If [ascii] is `false`, this is "┳". If it's `true`, this is
       |/// "+" instead.
       |String get teeDownBold => _teeDownBold;
       |var _teeDownBold = "┳";
       |
       |/// A bold vertical box line with a horizontal line going left from the middle.
       |///
       |/// If [ascii] is `false`, this is "┫". If it's `true`, this is
       |/// "+" instead.
       |String get teeLeftBold => _teeLeftBold;
       |var _teeLeftBold = "┫";
       |
       |/// A bold vertical box line with a horizontal line going right from the middle.
       |///
       |/// If [ascii] is `false`, this is "┣". If it's `true`, this is
       |/// "+" instead.
       |String get teeRightBold => _teeRightBold;
       |var _teeRightBold = "┣";
       |
       |/// The top half of a bold vertical box line.
       |///
       |/// If [ascii] is `false`, this is "╹". If it's `true`, this is
       |/// "'" instead.
       |String get upEndBold => _upEndBold;
       |var _upEndBold = "╹";
       |
       |/// The bottom half of a bold vertical box line.
       |///
       |/// If [ascii] is `false`, this is "╻". If it's `true`, this is
       |/// "," instead.
       |String get downEndBold => _downEndBold;
       |var _downEndBold = "╻";
       |
       |/// The left half of a bold horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "╸". If it's `true`, this is
       |/// "-" instead.
       |String get leftEndBold => _leftEndBold;
       |var _leftEndBold = "╸";
       |
       |/// The right half of a bold horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "╺". If it's `true`, this is
       |/// "-" instead.
       |String get rightEndBold => _rightEndBold;
       |var _rightEndBold = "╺";
       |
       |/// A double horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "═". If it's `true`, this is
       |/// "=" instead.
       |String get horizontalLineDouble => _horizontalLineDouble;
       |var _horizontalLineDouble = "═";
       |
       |/// A double vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "║". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineDouble => _verticalLineDouble;
       |var _verticalLineDouble = "║";
       |
       |/// The double upper left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "╔". If it's `true`, this is
       |/// "," instead.
       |String get topLeftCornerDouble => _topLeftCornerDouble;
       |var _topLeftCornerDouble = "╔";
       |
       |/// The double upper right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "╗". If it's `true`, this is
       |/// "," instead.
       |String get topRightCornerDouble => _topRightCornerDouble;
       |var _topRightCornerDouble = "╗";
       |
       |/// The double lower left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "╚". If it's `true`, this is
       |/// """ instead.
       |String get bottomLeftCornerDouble => _bottomLeftCornerDouble;
       |var _bottomLeftCornerDouble = "╚";
       |
       |/// The double lower right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "╝". If it's `true`, this is
       |/// """ instead.
       |String get bottomRightCornerDouble => _bottomRightCornerDouble;
       |var _bottomRightCornerDouble = "╝";
       |
       |/// An intersection of double vertical and horizontal box lines.
       |///
       |/// If [ascii] is `false`, this is "╬". If it's `true`, this is
       |/// "+" instead.
       |String get crossDouble => _crossDouble;
       |var _crossDouble = "╬";
       |
       |/// A double horizontal box line with a vertical line going up from the middle.
       |///
       |/// If [ascii] is `false`, this is "╩". If it's `true`, this is
       |/// "+" instead.
       |String get teeUpDouble => _teeUpDouble;
       |var _teeUpDouble = "╩";
       |
       |/// A double horizontal box line with a vertical line going down from the middle.
       |///
       |/// If [ascii] is `false`, this is "╦". If it's `true`, this is
       |/// "+" instead.
       |String get teeDownDouble => _teeDownDouble;
       |var _teeDownDouble = "╦";
       |
       |/// A double vertical box line with a horizontal line going left from the middle.
       |///
       |/// If [ascii] is `false`, this is "╣". If it's `true`, this is
       |/// "+" instead.
       |String get teeLeftDouble => _teeLeftDouble;
       |var _teeLeftDouble = "╣";
       |
       |/// A double vertical box line with a horizontal line going right from the middle.
       |///
       |/// If [ascii] is `false`, this is "╠". If it's `true`, this is
       |/// "+" instead.
       |String get teeRightDouble => _teeRightDouble;
       |var _teeRightDouble = "╠";
       |
       |/// A dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "╌". If it's `true`, this is
       |/// "-" instead.
       |String get horizontalLineDoubleDash => _horizontalLineDoubleDash;
       |var _horizontalLineDoubleDash = "╌";
       |
       |/// A bold dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "╍". If it's `true`, this is
       |/// "-" instead.
       |String get horizontalLineDoubleDashBold => _horizontalLineDoubleDashBold;
       |var _horizontalLineDoubleDashBold = "╍";
       |
       |/// A dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "╎". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineDoubleDash => _verticalLineDoubleDash;
       |var _verticalLineDoubleDash = "╎";
       |
       |/// A bold dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "╏". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineDoubleDashBold => _verticalLineDoubleDashBold;
       |var _verticalLineDoubleDashBold = "╏";
       |
       |/// A dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┄". If it's `true`, this is
       |/// "-" instead.
       |String get horizontalLineTripleDash => _horizontalLineTripleDash;
       |var _horizontalLineTripleDash = "┄";
       |
       |/// A bold dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┅". If it's `true`, this is
       |/// "-" instead.
       |String get horizontalLineTripleDashBold => _horizontalLineTripleDashBold;
       |var _horizontalLineTripleDashBold = "┅";
       |
       |/// A dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┆". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineTripleDash => _verticalLineTripleDash;
       |var _verticalLineTripleDash = "┆";
       |
       |/// A bold dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┇". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineTripleDashBold => _verticalLineTripleDashBold;
       |var _verticalLineTripleDashBold = "┇";
       |
       |/// A dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┈". If it's `true`, this is
       |/// "-" instead.
       |String get horizontalLineQuadrupleDash => _horizontalLineQuadrupleDash;
       |var _horizontalLineQuadrupleDash = "┈";
       |
       |/// A bold dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┉". If it's `true`, this is
       |/// "-" instead.
       |String get horizontalLineQuadrupleDashBold => _horizontalLineQuadrupleDashBold;
       |var _horizontalLineQuadrupleDashBold = "┉";
       |
       |/// A dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┊". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineQuadrupleDash => _verticalLineQuadrupleDash;
       |var _verticalLineQuadrupleDash = "┊";
       |
       |/// A bold dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "┋". If it's `true`, this is
       |/// "|" instead.
       |String get verticalLineQuadrupleDashBold => _verticalLineQuadrupleDashBold;
       |var _verticalLineQuadrupleDashBold = "┋";
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/file.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |import 'dart:typed_data';
       |
       |import 'location.dart';
       |import 'location_mixin.dart';
       |import 'span.dart';
       |import 'span_mixin.dart';
       |import 'span_with_context.dart';
       |
       |// Constants to determine end-of-lines.
       |const int _LF = 10;
       |const int _CR = 13;
       |
       |/// A class representing a source file.
       |///
       |/// This doesn't necessarily have to correspond to a file on disk, just a chunk
       |/// of text usually with a URL associated with it.
       |class SourceFile {
       |  /// The URL where the source file is located.
       |  ///
       |  /// This may be null, indicating that the URL is unknown or unavailable.
       |  final Uri url;
       |
       |  /// An array of offsets for each line beginning in the file.
       |  ///
       |  /// Each offset refers to the first character *after* the newline. If the
       |  /// source file has a trailing newline, the final offset won't actually be in
       |  /// the file.
       |  final _lineStarts = <int>[0];
       |
       |  /// The code points of the characters in the file.
       |  final Uint32List _decodedChars;
       |
       |  /// The length of the file in characters.
      2|  int get length => _decodedChars.length;
       |
       |  /// The number of lines in the file.
      0|  int get lines => _lineStarts.length;
       |
       |  /// The line that the offset fell on the last time [getLine] was called.
       |  ///
       |  /// In many cases, sequential calls to getLine() are for nearby, usually
       |  /// increasing offsets. In that case, we can find the line for an offset
       |  /// quickly by first checking to see if the offset is on the same line as the
       |  /// previous result.
       |  int _cachedLine;
       |
       |  /// Creates a new source file from [text].
       |  ///
       |  /// [url] may be either a [String], a [Uri], or `null`.
       |  SourceFile(String text, {url})
      2|      : this.decoded(text.runes, url: url);
       |
       |  /// Creates a new source file from a list of decoded characters.
       |  ///
       |  /// [url] may be either a [String], a [Uri], or `null`.
       |  SourceFile.decoded(Iterable<int> decodedChars, {url})
      1|      : url = url is String ? Uri.parse(url) : url,
      3|        _decodedChars = new Uint32List.fromList(decodedChars.toList()) {
      4|    for (var i = 0; i < _decodedChars.length; i++) {
      2|      var c = _decodedChars[i];
      1|      if (c == _CR) {
       |        // Return not followed by newline is treated as a newline
      0|        var j = i + 1;
      0|        if (j >= _decodedChars.length || _decodedChars[j] != _LF) c = _LF;
       |      }
      4|      if (c == _LF) _lineStarts.add(i + 1);
       |    }
       |  }
       |
       |  /// Returns a span in [this] from [start] to [end] (exclusive).
       |  ///
       |  /// If [end] isn't passed, it defaults to the end of the file.
       |  FileSpan span(int start, [int end]) {
      0|    if (end == null) end = length - 1;
      1|    return new _FileSpan(this, start, end);
       |  }
       |
       |  /// Returns a location in [this] at [offset].
      0|  FileLocation location(int offset) => new FileLocation._(this, offset);
       |
       |  /// Gets the 0-based line corresponding to [offset].
       |  int getLine(int offset) {
      0|    if (offset < 0) {
      0|      throw new RangeError("Offset may not be negative, was $offset.");
      0|    } else if (offset > length) {
      0|      throw new RangeError("Offset $offset must not be greater than the number "
      0|          "of characters in the file, $length.");
       |    }
       |
      0|    if (offset < _lineStarts.first) return -1;
      0|    if (offset >= _lineStarts.last) return _lineStarts.length - 1;
       |
      0|    if (_isNearCachedLine(offset)) return _cachedLine;
       |
      0|    _cachedLine = _binarySearch(offset) - 1;
      0|    return _cachedLine;
       |  }
       |
       |  /// Returns `true` if [offset] is near [_cachedLine].
       |  ///
       |  /// Checks on [_cachedLine] and the next line. If it's on the next line, it
       |  /// updates [_cachedLine] to point to that.
       |  bool _isNearCachedLine(int offset) {
      0|    if (_cachedLine == null) return false;
       |
       |    // See if it's before the cached line.
      0|    if (offset < _lineStarts[_cachedLine]) return false;
       |
       |    // See if it's on the cached line.
      0|    if (_cachedLine >= _lineStarts.length - 1 ||
      0|        offset < _lineStarts[_cachedLine + 1]) {
       |      return true;
       |    }
       |
       |    // See if it's on the next line.
      0|    if (_cachedLine >= _lineStarts.length - 2 ||
      0|        offset < _lineStarts[_cachedLine + 2]) {
      0|      _cachedLine++;
       |      return true;
       |    }
       |
       |    return false;
       |  }
       |
       |  /// Binary search through [_lineStarts] to find the line containing [offset].
       |  ///
       |  /// Returns the index of the line in [_lineStarts].
       |  int _binarySearch(int offset) {
       |    int min = 0;
      0|    int max = _lineStarts.length - 1;
      0|    while (min < max) {
      0|      var half = min + ((max - min) ~/ 2);
      0|      if (_lineStarts[half] > offset) {
       |        max = half;
       |      } else {
      0|        min = half + 1;
       |      }
       |    }
       |
       |    return max;
       |  }
       |
       |  /// Gets the 0-based column corresponding to [offset].
       |  ///
       |  /// If [line] is passed, it's assumed to be the line containing [offset] and
       |  /// is used to more efficiently compute the column.
       |  int getColumn(int offset, {int line}) {
      0|    if (offset < 0) {
      0|      throw new RangeError("Offset may not be negative, was $offset.");
      0|    } else if (offset > length) {
      0|      throw new RangeError("Offset $offset must be not be greater than the "
      0|          "number of characters in the file, $length.");
       |    }
       |
       |    if (line == null) {
      0|      line = getLine(offset);
      0|    } else if (line < 0) {
      0|      throw new RangeError("Line may not be negative, was $line.");
      0|    } else if (line >= lines) {
      0|      throw new RangeError("Line $line must be less than the number of "
      0|          "lines in the file, $lines.");
       |    }
       |
      0|    var lineStart = _lineStarts[line];
      0|    if (lineStart > offset) {
      0|      throw new RangeError("Line $line comes after offset $offset.");
       |    }
       |
      0|    return offset - lineStart;
       |  }
       |
       |  /// Gets the offset for a [line] and [column].
       |  ///
       |  /// [column] defaults to 0.
       |  int getOffset(int line, [int column]) {
       |    if (column == null) column = 0;
       |
      0|    if (line < 0) {
      0|      throw new RangeError("Line may not be negative, was $line.");
      0|    } else if (line >= lines) {
      0|      throw new RangeError("Line $line must be less than the number of "
      0|          "lines in the file, $lines.");
      0|    } else if (column < 0) {
      0|      throw new RangeError("Column may not be negative, was $column.");
       |    }
       |
      0|    var result = _lineStarts[line] + column;
      0|    if (result > length ||
      0|        (line + 1 < lines && result >= _lineStarts[line + 1])) {
      0|      throw new RangeError("Line $line doesn't have $column columns.");
       |    }
       |
       |    return result;
       |  }
       |
       |  /// Returns the text of the file from [start] to [end] (exclusive).
       |  ///
       |  /// If [end] isn't passed, it defaults to the end of the file.
       |  String getText(int start, [int end]) =>
      3|      new String.fromCharCodes(_decodedChars.sublist(start, end));
       |}
       |
       |/// A [SourceLocation] within a [SourceFile].
       |///
       |/// Unlike the base [SourceLocation], [FileLocation] lazily computes its line
       |/// and column values based on its offset and the contents of [file].
       |///
       |/// A [FileLocation] can be created using [SourceFile.location].
       |class FileLocation extends SourceLocationMixin implements SourceLocation {
       |  /// The [file] that [this] belongs to.
       |  final SourceFile file;
       |
       |  final int offset;
      0|  Uri get sourceUrl => file.url;
      0|  int get line => file.getLine(offset);
      0|  int get column => file.getColumn(offset);
       |
      0|  FileLocation._(this.file, this.offset) {
      0|    if (offset < 0) {
      0|      throw new RangeError("Offset may not be negative, was $offset.");
      0|    } else if (offset > file.length) {
      0|      throw new RangeError("Offset $offset must not be greater than the number "
      0|          "of characters in the file, ${file.length}.");
       |    }
       |  }
       |
      0|  FileSpan pointSpan() => new _FileSpan(file, offset, offset);
       |}
       |
       |/// A [SourceSpan] within a [SourceFile].
       |///
       |/// Unlike the base [SourceSpan], [FileSpan] lazily computes its line and column
       |/// values based on its offset and the contents of [file]. [FileSpan.message] is
       |/// also able to provide more context then [SourceSpan.message], and
       |/// [FileSpan.union] will return a [FileSpan] if possible.
       |///
       |/// A [FileSpan] can be created using [SourceFile.span].
       |abstract class FileSpan implements SourceSpanWithContext {
       |  /// The [file] that [this] belongs to.
       |  SourceFile get file;
       |
       |  FileLocation get start;
       |  FileLocation get end;
       |
       |  /// Returns a new span that covers both [this] and [other].
       |  ///
       |  /// Unlike [union], [other] may be disjoint from [this]. If it is, the text
       |  /// between the two will be covered by the returned span.
       |  FileSpan expand(FileSpan other);
       |}
       |
       |/// The implementation of [FileSpan].
       |///
       |/// This is split into a separate class so that `is _FileSpan` checks can be run
       |/// to make certain operations more efficient. If we used `is FileSpan`, that
       |/// would break if external classes implemented the interface.
       |class _FileSpan extends SourceSpanMixin implements FileSpan {
       |  final SourceFile file;
       |
       |  /// The offset of the beginning of the span.
       |  ///
       |  /// [start] is lazily generated from this to avoid allocating unnecessary
       |  /// objects.
       |  final int _start;
       |
       |  /// The offset of the end of the span.
       |  ///
       |  /// [end] is lazily generated from this to avoid allocating unnecessary
       |  /// objects.
       |  final int _end;
       |
      0|  Uri get sourceUrl => file.url;
      0|  int get length => _end - _start;
      0|  FileLocation get start => new FileLocation._(file, _start);
      0|  FileLocation get end => new FileLocation._(file, _end);
      4|  String get text => file.getText(_start, _end);
      0|  String get context => file.getText(file.getOffset(start.line),
      0|      end.line == file.lines - 1 ? null : file.getOffset(end.line + 1));
       |
      1|  _FileSpan(this.file, this._start, this._end) {
      3|    if (_end < _start) {
      0|      throw new ArgumentError('End $_end must come after start $_start.');
      4|    } else if (_end > file.length) {
      0|      throw new RangeError("End $_end must not be greater than the number "
      0|          "of characters in the file, ${file.length}.");
      2|    } else if (_start < 0) {
      0|      throw new RangeError("Start may not be negative, was $_start.");
       |    }
       |  }
       |
       |  int compareTo(SourceSpan other) {
      0|    if (other is! _FileSpan) return super.compareTo(other);
       |
       |    _FileSpan otherFile = other;
      0|    var result = _start.compareTo(otherFile._start);
      0|    return result == 0 ? _end.compareTo(otherFile._end) : result;
       |  }
       |
       |  SourceSpan union(SourceSpan other) {
      0|    if (other is! FileSpan) return super.union(other);
       |
       |    
      0|    _FileSpan span = expand(other);
       |
      0|    if (other is _FileSpan) {
      0|      if (this._start > other._end || other._start > this._end) {
      0|        throw new ArgumentError("Spans $this and $other are disjoint.");
       |      }
       |    } else {
      0|      if (this._start > other.end.offset || other.start.offset > this._end) {
      0|        throw new ArgumentError("Spans $this and $other are disjoint.");
       |      }
       |    }
       |
       |    return span;
       |  }
       |
       |  bool operator ==(other) {
      0|    if (other is! FileSpan) return super == other;
      0|    if (other is! _FileSpan) {
      0|      return super == other && sourceUrl == other.sourceUrl;
       |    }
       |
      0|    return _start == other._start && _end == other._end &&
      0|        sourceUrl == other.sourceUrl;
       |  }
       |
       |  // Eliminates dart2js warning about overriding `==`, but not `hashCode`
      0|  int get hashCode => super.hashCode;
       |
       |  /// Returns a new span that covers both [this] and [other].
       |  ///
       |  /// Unlike [union], [other] may be disjoint from [this]. If it is, the text
       |  /// between the two will be covered by the returned span.
       |  FileSpan expand(FileSpan other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw new ArgumentError("Source URLs \"${sourceUrl}\" and "
      0|          " \"${other.sourceUrl}\" don't match.");
       |    }
       |
      0|    if (other is _FileSpan) {
      1|      var start = math.min(this._start, other._start);
      1|      var end = math.max(this._end, other._end);
      0|      return new _FileSpan(file, start, end);
       |    } else {
      1|      var start = math.min(this._start, other.start.offset);
      1|      var end = math.max(this._end, other.end.offset);
      0|      return new _FileSpan(file, start, end);
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/location.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'span.dart';
       |
       |// TODO(nweiz): Use SourceLocationMixin once we decide to cut a release with
       |// breaking changes. See SourceLocationMixin for details.
       |
       |/// A class that describes a single location within a source file.
       |///
       |/// This class should not be extended. Instead, [SourceLocationBase] should be
       |/// extended instead.
       |class SourceLocation implements Comparable<SourceLocation> {
       |  /// URL of the source containing this location.
       |  ///
       |  /// This may be null, indicating that the source URL is unknown or
       |  /// unavailable.
       |  final Uri sourceUrl;
       |
       |  /// The 0-based offset of this location in the source.
       |  final int offset;
       |
       |  /// The 0-based line of this location in the source.
       |  final int line;
       |
       |  /// The 0-based column of this location in the source
       |  final int column;
       |
       |  /// Returns a representation of this location in the `source:line:column`
       |  /// format used by text editors.
       |  ///
       |  /// This prints 1-based lines and columns.
       |  String get toolString {
      0|    var source = sourceUrl == null ? 'unknown source' : sourceUrl;
      0|    return '$source:${line + 1}:${column + 1}';
       |  }
       |
       |  /// Creates a new location indicating [offset] within [sourceUrl].
       |  ///
       |  /// [line] and [column] default to assuming the source is a single line. This
       |  /// means that [line] defaults to 0 and [column] defaults to [offset].
       |  ///
       |  /// [sourceUrl] may be either a [String], a [Uri], or `null`.
       |  SourceLocation(int offset, {sourceUrl, int line, int column})
      0|      : sourceUrl = sourceUrl is String ? Uri.parse(sourceUrl) : sourceUrl,
       |        offset = offset,
       |        line = line == null ? 0 : line,
      0|        column = column == null ? offset : column {
      0|    if (offset < 0) {
      0|      throw new RangeError("Offset may not be negative, was $offset.");
      0|    } else if (line != null && line < 0) {
      0|      throw new RangeError("Line may not be negative, was $line.");
      0|    } else if (column != null && column < 0) {
      0|      throw new RangeError("Column may not be negative, was $column.");
       |    }
       |  }
       |
       |  /// Returns the distance in characters between [this] and [other].
       |  ///
       |  /// This always returns a non-negative value.
       |  int distance(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw new ArgumentError("Source URLs \"${sourceUrl}\" and "
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return (offset - other.offset).abs();
       |  }
       |
       |  /// Returns a span that covers only a single point: this location.
      0|  SourceSpan pointSpan() => new SourceSpan(this, this, "");
       |
       |  /// Compares two locations.
       |  ///
       |  /// [other] must have the same source URL as [this].
       |  int compareTo(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw new ArgumentError("Source URLs \"${sourceUrl}\" and "
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return offset - other.offset;
       |  }
       |
       |  bool operator ==(other) =>
      0|      other is SourceLocation && sourceUrl == other.sourceUrl &&
      0|      offset == other.offset;
       |
      0|  int get hashCode => sourceUrl.hashCode + offset;
       |
      0|  String toString() => '<$runtimeType: $offset $toolString>';
       |}
       |
       |/// A base class for source locations with [offset], [line], and [column] known
       |/// at construction time.
       |class SourceLocationBase extends SourceLocation {
       |  SourceLocationBase(int offset, {sourceUrl, int line, int column})
      0|      : super(offset, sourceUrl: sourceUrl, line: line, column: column);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/location_mixin.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'location.dart';
       |import 'span.dart';
       |
       |// Note: this class duplicates a lot of functionality of [SourceLocation]. This
       |// is because in order for SourceLocation to use SourceLocationMixin,
       |// SourceLocationMixin couldn't implement SourceLocation. In SourceSpan we
       |// handle this by making the class itself non-extensible, but that would be a
       |// breaking change for SourceLocation. So until we want to endure the pain of
       |// cutting a release with breaking changes, we duplicate the code here.
       |
       |/// A mixin for easily implementing [SourceLocation].
       |abstract class SourceLocationMixin implements SourceLocation {
       |  String get toolString {
      0|    var source = sourceUrl == null ? 'unknown source' : sourceUrl;
      0|    return '$source:${line + 1}:${column + 1}';
       |  }
       |
       |  int distance(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw new ArgumentError("Source URLs \"${sourceUrl}\" and "
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return (offset - other.offset).abs();
       |  }
       |
      0|  SourceSpan pointSpan() => new SourceSpan(this, this, "");
       |
       |  int compareTo(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw new ArgumentError("Source URLs \"${sourceUrl}\" and "
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return offset - other.offset;
       |  }
       |
       |  bool operator ==(other) =>
      0|      other is SourceLocation &&
      0|      sourceUrl == other.sourceUrl &&
      0|      offset == other.offset;
       |
      0|  int get hashCode => sourceUrl.hashCode + offset;
       |
      0|  String toString() => '<$runtimeType: $offset $toolString>';
       |}
       |
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/span.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'location.dart';
       |import 'span_mixin.dart';
       |
       |/// A class that describes a segment of source text.
       |abstract class SourceSpan implements Comparable<SourceSpan> {
       |  /// The start location of this span.
       |  final SourceLocation start;
       |
       |  /// The end location of this span, exclusive.
       |  final SourceLocation end;
       |
       |  /// The source text for this span.
       |  final String text;
       |
       |  /// The URL of the source (typically a file) of this span.
       |  ///
       |  /// This may be null, indicating that the source URL is unknown or
       |  /// unavailable.
       |  final Uri sourceUrl;
       |
       |  /// The length of this span, in characters.
       |  final int length;
       |
       |  /// Creates a new span from [start] to [end] (exclusive) containing [text].
       |  ///
       |  /// [start] and [end] must have the same source URL and [start] must come
       |  /// before [end]. [text] must have a number of characters equal to the
       |  /// distance between [start] and [end].
       |  factory SourceSpan(SourceLocation start, SourceLocation end, String text) =>
      0|      new SourceSpanBase(start, end, text);
       |
       |  /// Creates a new span that's the union of [this] and [other].
       |  ///
       |  /// The two spans must have the same source URL and may not be disjoint.
       |  /// [text] is computed by combining [this.text] and [other.text].
       |  SourceSpan union(SourceSpan other);
       |
       |  /// Compares two spans.
       |  ///
       |  /// [other] must have the same source URL as [this]. This orders spans by
       |  /// [start] then [length].
       |  int compareTo(SourceSpan other);
       |
       |  /// Formats [message] in a human-friendly way associated with this span.
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an ANSII terminal color escape that should be used to
       |  /// highlight the span's text. If it's `true`, it indicates that the text
       |  /// should be highlighted using the default color. If it's `false` or `null`,
       |  /// it indicates that the text shouldn't be highlighted.
       |  String message(String message, {color});
       |
       |  /// Prints the text associated with this span in a user-friendly way.
       |  ///
       |  /// This is identical to [message], except that it doesn't print the file
       |  /// name, line number, column number, or message. If [length] is 0 and this
       |  /// isn't a [SourceSpanWithContext], returns an empty string.
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an ANSII terminal color escape that should be used to
       |  /// highlight the span's text. If it's `true`, it indicates that the text
       |  /// should be highlighted using the default color. If it's `false` or `null`,
       |  /// it indicates that the text shouldn't be highlighted.
       |  String highlight({color});
       |}
       |
       |/// A base class for source spans with [start], [end], and [text] known at
       |/// construction time.
       |class SourceSpanBase extends SourceSpanMixin {
       |  final SourceLocation start;
       |  final SourceLocation end;
       |  final String text;
       |
      0|  SourceSpanBase(this.start, this.end, this.text) {
      0|    if (end.sourceUrl != start.sourceUrl) {
      0|      throw new ArgumentError("Source URLs \"${start.sourceUrl}\" and "
      0|          " \"${end.sourceUrl}\" don't match.");
      0|    } else if (end.offset < start.offset) {
      0|      throw new ArgumentError('End $end must come after start $start.');
      0|    } else if (text.length != start.distance(end)) {
      0|      throw new ArgumentError('Text "$text" must be ${start.distance(end)} '
      0|          'characters long.');
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/span_exception.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'span.dart';
       |
       |/// A class for exceptions that have source span information attached.
       |class SourceSpanException implements Exception {
       |  // This is a getter so that subclasses can override it.
       |  /// A message describing the exception.
      0|  String get message => _message;
       |  final String _message;
       |
       |  // This is a getter so that subclasses can override it.
       |  /// The span associated with this exception.
       |  ///
       |  /// This may be `null` if the source location can't be determined.
      0|  SourceSpan get span => _span;
       |  final SourceSpan _span;
       |
      0|  SourceSpanException(this._message, this._span);
       |
       |  /// Returns a string representation of [this].
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an ANSII terminal color escape that should be used to
       |  /// highlight the span's text. If it's `true`, it indicates that the text
       |  /// should be highlighted using the default color. If it's `false` or `null`,
       |  /// it indicates that the text shouldn't be highlighted.
       |  String toString({color}) {
      0|    if (span == null) return message;
      0|    return "Error on " + span.message(message, color: color);
       |  }
       |}
       |
       |/// A [SourceSpanException] that's also a [FormatException].
       |class SourceSpanFormatException extends SourceSpanException
       |    implements FormatException {
       |  // This is a getter so that subclasses can override it.
      0|  dynamic get source => _source;
       |  final _source;
       |
      0|  int get offset => span == null ? null : span.start.offset;
       |
       |  SourceSpanFormatException(String message, SourceSpan span, [this._source])
      0|      : super(message, span);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/span_mixin.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |
       |import 'package:charcode/charcode.dart';
       |import 'package:path/path.dart' as p;
       |
       |import 'colors.dart' as colors;
       |import 'span.dart';
       |import 'span_with_context.dart';
       |import 'utils.dart';
       |
       |/// A mixin for easily implementing [SourceSpan].
       |///
       |/// This implements the [SourceSpan] methods in terms of [start], [end], and
       |/// [text]. This assumes that [start] and [end] have the same source URL, that
       |/// [start] comes before [end], and that [text] has a number of characters equal
       |/// to the distance between [start] and [end].
       |abstract class SourceSpanMixin implements SourceSpan {
      0|  Uri get sourceUrl => start.sourceUrl;
      0|  int get length => end.offset - start.offset;
       |
       |  int compareTo(SourceSpan other) {
      0|    var result = start.compareTo(other.start);
      0|    return result == 0 ? end.compareTo(other.end) : result;
       |  }
       |
       |  SourceSpan union(SourceSpan other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw new ArgumentError("Source URLs \"${sourceUrl}\" and "
      0|          " \"${other.sourceUrl}\" don't match.");
       |    }
       |
      0|    var start = min(this.start, other.start);
      0|    var end = max(this.end, other.end);
      0|    var beginSpan = start == this.start ? this : other;
      0|    var endSpan = end == this.end ? this : other;
       |
      0|    if (beginSpan.end.compareTo(endSpan.start) < 0) {
      0|      throw new ArgumentError("Spans $this and $other are disjoint.");
       |    }
       |
      0|    var text = beginSpan.text +
      0|        endSpan.text.substring(beginSpan.end.distance(endSpan.start));
      0|    return new SourceSpan(start, end, text);
       |  }
       |
       |  String message(String message, {color}) {
      0|    var buffer = new StringBuffer();
      0|    buffer.write('line ${start.line + 1}, column ${start.column + 1}');
      0|    if (sourceUrl != null) buffer.write(' of ${p.prettyUri(sourceUrl)}');
      0|    buffer.write(': $message');
       |
      0|    var highlight = this.highlight(color: color);
      0|    if (!highlight.isEmpty) {
      0|      buffer.writeln();
      0|      buffer.write(highlight);
       |    }
       |
      0|    return buffer.toString();
       |  }
       |
       |  String highlight({color}) {
      0|    if (color == true) color = colors.RED;
      0|    if (color == false) color = null;
       |
      0|    var column = start.column;
      0|    var buffer = new StringBuffer();
       |    String textLine;
      0|    if (this is SourceSpanWithContext) {
      0|      var context = (this as SourceSpanWithContext).context;
      0|      var lineStart = findLineStart(context, text, column);
      0|      if (lineStart != null && lineStart > 0) {
      0|        buffer.write(context.substring(0, lineStart));
      0|        context = context.substring(lineStart);
       |      }
      0|      var endIndex = context.indexOf('\n');
      0|      textLine = endIndex == -1 ? context : context.substring(0, endIndex + 1);
      1|      column = math.min(column, textLine.length);
      0|    } else if (length == 0) {
       |      return "";
       |    } else {
      0|      textLine = text.split("\n").first;
       |      column = 0;
       |    }
       |
       |    var toColumn =
      1|        math.min(column + end.offset - start.offset, textLine.length);
       |    if (color != null) {
      0|      buffer.write(textLine.substring(0, column));
      0|      buffer.write(color);
      0|      buffer.write(textLine.substring(column, toColumn));
      0|      buffer.write(colors.NONE);
      0|      buffer.write(textLine.substring(toColumn));
       |    } else {
      0|      buffer.write(textLine);
       |    }
      0|    if (!textLine.endsWith('\n')) buffer.write('\n');
       |
      0|    for (var i = 0; i < column; i++) {
      0|      if (textLine.codeUnitAt(i) == $tab) {
      0|        buffer.writeCharCode($tab);
       |      } else {
      0|        buffer.writeCharCode($space);
       |      }
       |    }
       |
      0|    if (color != null) buffer.write(color);
      1|    buffer.write('^' * math.max(toColumn - column, 1));
      0|    if (color != null) buffer.write(colors.NONE);
      0|    return buffer.toString();
       |  }
       |
      0|  bool operator ==(other) => other is SourceSpan &&
      0|      start == other.start && end == other.end;
       |
      0|  int get hashCode => start.hashCode + (31 * end.hashCode);
       |
      0|  String toString() => '<$runtimeType: from $start to $end "$text">';
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/span_with_context.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'location.dart';
       |import 'span.dart';
       |import 'utils.dart';
       |
       |/// A class that describes a segment of source text with additional context.
       |class SourceSpanWithContext extends SourceSpanBase {
       |  // This is a getter so that subclasses can override it.
       |  /// Text around the span, which includes the line containing this span.
      0|  String get context => _context;
       |  final String _context;
       |
       |  /// Creates a new span from [start] to [end] (exclusive) containing [text], in
       |  /// the given [context].
       |  ///
       |  /// [start] and [end] must have the same source URL and [start] must come
       |  /// before [end]. [text] must have a number of characters equal to the
       |  /// distance between [start] and [end]. [context] must contain [text], and
       |  /// [text] should start at `start.column` from the beginning of a line in
       |  /// [context].
       |  SourceSpanWithContext(
       |          SourceLocation start, SourceLocation end, String text, this._context)
      0|      : super(start, end, text) {
      0|    if (!context.contains(text)) {
      0|      throw new ArgumentError(
      0|          'The context line "$context" must contain "$text".');
       |    }
       |
      0|    if (findLineStart(context, text, start.column) == null) {
      0|      throw new ArgumentError('The span text "$text" must start at '
      0|          'column ${start.column + 1} in a line within "$context".');
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/lazy_trace.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'frame.dart';
       |import 'trace.dart';
       |
       |/// A thunk for lazily constructing a [Trace].
       |typedef Trace TraceThunk();
       |
       |/// A wrapper around a [TraceThunk]. This works around issue 9579 by avoiding
       |/// the conversion of native [StackTrace]s to strings until it's absolutely
       |/// necessary.
       |class LazyTrace implements Trace {
       |  final TraceThunk _thunk;
       |  Trace _inner;
       |
      1|  LazyTrace(this._thunk);
       |
       |  Trace get _trace {
      4|    if (_inner == null) _inner = _thunk();
      1|    return _inner;
       |  }
       |
      2|  List<Frame> get frames => _trace.frames;
      0|  StackTrace get vmTrace => _trace.vmTrace;
      0|  Trace get terse => new LazyTrace(() => _trace.terse);
       |  Trace foldFrames(bool predicate(Frame frame), {bool terse: false}) =>
      3|    new LazyTrace(() => _trace.foldFrames(predicate, terse: terse));
      0|  String toString() => _trace.toString();
       |
       |  // Work around issue 14075.
      0|  set frames(_) => throw new UnimplementedError();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.7.3/lib/src/vm_trace.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'frame.dart';
       |
       |/// An implementation of [StackTrace] that emulates the behavior of the VM's
       |/// implementation.
       |///
       |/// In particular, when [toString] is called, this returns a string in the VM's
       |/// stack trace format.
       |class VMTrace implements StackTrace {
       |  /// The stack frames that comprise this stack trace.
       |  final List<Frame> frames;
       |
      0|  VMTrace(this.frames);
       |
       |  String toString() {
       |    var i = 1;
      0|    return frames.map((frame) {
      0|      var number = "#${i++}".padRight(8);
      0|      var member = frame.member
      0|          .replaceAllMapped(new RegExp(r"[^.]+\.<async>"),
      0|              (match) => "${match[1]}.<${match[1]}_async_body>")
      0|          .replaceAll("<fn>", "<anonymous closure>");
      0|      var line = frame.line == null ? 0 : frame.line;
      0|      var column = frame.column == null ? 0 : frame.column;
      0|      return "$number$member (${frame.uri}:$line:$column)\n";
      0|    }).join();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/path-1.4.1/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'characters.dart' as chars;
       |
       |/// Returns whether [char] is the code for an ASCII letter (uppercase or
       |/// lowercase).
       |bool isAlphabetic(int char) =>
      0|    (char >= chars.UPPER_A && char <= chars.UPPER_Z) ||
      0|        (char >= chars.LOWER_A && char <= chars.LOWER_Z);
       |
       |/// Returns whether [char] is the code for an ASCII digit.
      0|bool isNumeric(int char) => char >= chars.ZERO && char <= chars.NINE;
       |
       |/// Returns whether [path] has a URL-formatted Windows drive letter beginning at
       |/// [index].
       |bool isDriveLetter(String path, int index) {
      0|  if (path.length < index + 2) return false;
      0|  if (!isAlphabetic(path.codeUnitAt(index))) return false;
      0|  if (path.codeUnitAt(index + 1) != chars.COLON) return false;
      0|  if (path.length == index + 2) return true;
      0|  return path.codeUnitAt(index + 2) == chars.SLASH;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/typed/future.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |class TypeSafeFuture<T> implements Future<T> {
       |  final Future _future;
       |
      0|  TypeSafeFuture(this._future);
       |
      0|  Stream<T> asStream() => _future.then((value) => value as T).asStream();
       |
       |  Future<T> catchError(Function onError, {bool test(Object error)}) async =>
      0|      new TypeSafeFuture<T>(_future.catchError(onError, test: test));
       |
       |  Future<S> then<S>(dynamic onValue(T value), {Function onError}) =>
      0|      _future.then((value) => onValue(value as T), onError: onError);
       |
       |  Future<T> whenComplete(action()) =>
      0|      new TypeSafeFuture<T>(_future.whenComplete(action));
       |
       |  Future<T> timeout(Duration timeLimit, {onTimeout()}) =>
      0|      new TypeSafeFuture<T>(_future.timeout(timeLimit, onTimeout: onTimeout));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/typed/stream.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:collection/collection.dart';
       |
       |import '../utils.dart';
       |import 'stream_subscription.dart';
       |import '../delegate/event_sink.dart';
       |
       |class TypeSafeStream<T> implements Stream<T> {
       |  final Stream _stream;
       |
      0|  Future<T> get first async => (await _stream.first) as T;
      0|  Future<T> get last async => (await _stream.last) as T;
      0|  Future<T> get single async => (await _stream.single) as T;
       |
      0|  bool get isBroadcast => _stream.isBroadcast;
      0|  Future<bool> get isEmpty => _stream.isEmpty;
      0|  Future<int> get length => _stream.length;
       |
      0|  TypeSafeStream(this._stream);
       |
       |  Stream<T> asBroadcastStream(
       |      {void onListen(StreamSubscription<T> subscription),
       |      void onCancel(StreamSubscription<T> subscription)}) {
      0|    return new TypeSafeStream<T>(_stream.asBroadcastStream(
       |        onListen: onListen == null
       |            ? null
       |            : (subscription) =>
      0|                  onListen(new TypeSafeStreamSubscription<T>(subscription)),
       |        onCancel: onCancel == null
       |            ? null
       |            : (subscription) =>
      0|                  onCancel(new TypeSafeStreamSubscription<T>(subscription))));
       |  }
       |
       |  Stream<E> asyncExpand<E>(Stream<E> convert(T event)) =>
      0|      _stream.asyncExpand(_validateType(convert));
       |
       |  Stream<E> asyncMap<E>(convert(T event)) =>
      0|      _stream.asyncMap(_validateType(convert));
       |
       |  Stream<T> distinct([bool equals(T previous, T next)]) =>
      0|      new TypeSafeStream<T>(_stream.distinct(equals == null
       |          ? null
      0|          : (previous, next) => equals(previous as T, next as T)));
       |
       |  Future<E> drain<E>([E futureValue]) =>
      0|      _stream.drain(futureValue);
       |
       |  Stream<S> expand<S>(Iterable<S> convert(T value)) =>
      0|      _stream.expand(_validateType(convert));
       |
       |  Future firstWhere(bool test(T element), {Object defaultValue()}) =>
      0|      _stream.firstWhere(_validateType(test), defaultValue: defaultValue);
       |
       |  Future lastWhere(bool test(T element), {Object defaultValue()}) =>
      0|      _stream.lastWhere(_validateType(test), defaultValue: defaultValue);
       |
       |  Future<T> singleWhere(bool test(T element)) async =>
      0|      (await _stream.singleWhere(_validateType(test))) as T;
       |
       |  Future<S> fold<S>(S initialValue,
       |          S combine(S previous, T element)) =>
      0|      _stream.fold(initialValue,
      0|          (previous, element) => combine(previous, element as T));
       |
       |  Future forEach(void action(T element)) =>
      0|      _stream.forEach(_validateType(action));
       |
       |  Stream<T> handleError(Function onError, {bool test(error)}) =>
      0|      new TypeSafeStream<T>(_stream.handleError(onError, test: test));
       |
       |  StreamSubscription<T> listen(void onData(T value),
       |          {Function onError, void onDone(), bool cancelOnError}) =>
      0|      new TypeSafeStreamSubscription<T>(_stream.listen(_validateType(onData),
       |          onError: onError, onDone: onDone, cancelOnError: cancelOnError));
       |
       |  Stream<S> map<S>(S convert(T event)) =>
      0|      _stream.map(_validateType(convert));
       |
       |  // Don't forward to `_stream.pipe` because we want the consumer to see the
       |  // type-asserted stream.
       |  Future pipe(StreamConsumer<T> consumer) =>
      0|      consumer.addStream(this).then((_) => consumer.close());
       |
       |  Future<T> reduce(T combine(T previous, T element)) async {
      0|    var result = await _stream.reduce(
      0|        (previous, element) => combine(previous as T, element as T));
      0|    return result as T;
       |  }
       |
       |  Stream<T> skipWhile(bool test(T element)) =>
      0|      new TypeSafeStream<T>(_stream.skipWhile(_validateType(test)));
       |
       |  Stream<T> takeWhile(bool test(T element)) =>
      0|      new TypeSafeStream<T>(_stream.takeWhile(_validateType(test)));
       |
       |  Stream<T> timeout(Duration timeLimit, {void onTimeout(EventSink<T> sink)}) =>
      0|      new TypeSafeStream<T>(_stream.timeout(
       |          timeLimit,
      0|          onTimeout: (sink) => onTimeout(DelegatingEventSink.typed(sink))));
       |
       |  Future<List<T>> toList() async =>
      0|      DelegatingList.typed<T>(await _stream.toList());
       |
       |  Future<Set<T>> toSet() async =>
      0|      DelegatingSet.typed<T>(await _stream.toSet());
       |
       |  // Don't forward to `_stream.transform` because we want the transformer to see
       |  // the type-asserted stream.
       |  Stream<S> transform<S>(
       |          StreamTransformer<T, S> transformer) =>
      0|      transformer.bind(this);
       |
       |  Stream<T> where(bool test(T element)) =>
      0|      new TypeSafeStream<T>(_stream.where(_validateType(test)));
       |
       |  Future<bool> every(bool test(T element)) =>
      0|      _stream.every(_validateType(test));
       |
      0|  Future<bool> any(bool test(T element)) => _stream.any(_validateType(test));
      0|  Stream<T> skip(int count) => new TypeSafeStream<T>(_stream.skip(count));
      0|  Stream<T> take(int count) => new TypeSafeStream<T>(_stream.take(count));
      0|  Future<T> elementAt(int index) async => (await _stream.elementAt(index)) as T;
      0|  Future<bool> contains(Object needle) => _stream.contains(needle);
      0|  Future<String> join([String separator = ""]) => _stream.join(separator);
      0|  String toString() => _stream.toString();
       |
       |  /// Returns a version of [function] that asserts that its argument is an
       |  /// instance of `T`.
       |  UnaryFunction<dynamic, S> _validateType<S>(
       |          S function(T value)) =>
      0|      function == null ? null : (value) => function(value as T);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/typed/stream_subscription.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |class TypeSafeStreamSubscription<T> implements StreamSubscription<T> {
       |  final StreamSubscription _subscription;
       |
      0|  bool get isPaused => _subscription.isPaused;
       |
      0|  TypeSafeStreamSubscription(this._subscription);
       |
       |  void onData(void handleData(T data)) {
      0|    _subscription.onData((data) => handleData(data as T));
       |  }
       |
       |  void onError(Function handleError) {
      0|    _subscription.onError(handleError);
       |  }
       |
       |  void onDone(void handleDone()) {
      0|    _subscription.onDone(handleDone);
       |  }
       |
       |  void pause([Future resumeFuture]) {
      0|    _subscription.pause(resumeFuture);
       |  }
       |
       |  void resume() {
      0|    _subscription.resume();
       |  }
       |
      0|  Future cancel() => _subscription.cancel();
       |
       |  Future<E> asFuture<E>([E futureValue]) =>
      0|      _subscription.asFuture(futureValue);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result/capture_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../result.dart';
       |
       |/// Use [Result.captureSinkTransformer].
       |@Deprecated("Will be removed in async 2.0.0.")
       |class CaptureSink<T> implements EventSink<T> {
       |  final EventSink _sink;
       |
      0|  CaptureSink(EventSink<Result<T>> sink) : _sink = sink;
       |
       |  void add(T value) {
      0|    _sink.add(new Result.value(value));
       |  }
       |
       |  void addError(Object error, [StackTrace stackTrace]) {
      0|    _sink.add(new Result.error(error, stackTrace));
       |  }
       |
       |  void close() {
      0|    _sink.close();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/result/release_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../result.dart';
       |
       |/// Use [Result.captureSinkTransformer].
       |@Deprecated("Will be removed in async 2.0.0.")
       |class ReleaseSink<T> implements EventSink<Result<T>> {
       |  final EventSink _sink;
       |
      0|  ReleaseSink(EventSink<T> sink) : _sink = sink;
       |
       |  void add(Result<T> result) {
      0|    if (result.isValue) {
      0|      _sink.add(result.asValue.value);
       |    } else {
      0|      var error = result.asError;
      0|      _sink.addError(error.error, error.stackTrace);
       |    }
       |  }
       |
       |  void addError(Object error, [StackTrace stackTrace]) {
       |    // Errors may be added by intermediate processing, even if it is never
       |    // added by CaptureSink.
      0|    _sink.addError(error, stackTrace);
       |  }
       |
       |  void close() {
      0|    _sink.close();
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_sink_transformer/handler_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_sink_transformer.dart';
       |import '../delegate/stream_sink.dart';
       |
       |/// The type of the callback for handling data events.
       |typedef void HandleData<S, T>(S data, EventSink<T> sink);
       |
       |/// The type of the callback for handling error events.
       |typedef void HandleError<T>(
       |    Object error, StackTrace stackTrace, EventSink<T> sink);
       |
       |/// The type of the callback for handling done events.
       |typedef void HandleDone<T>(EventSink<T> sink);
       |
       |/// A [StreamSinkTransformer] that delegates events to the given handlers.
       |class HandlerTransformer<S, T> implements StreamSinkTransformer<S, T> {
       |  /// The handler for data events.
       |  final HandleData<S, T> _handleData;
       |
       |  /// The handler for error events.
       |  final HandleError<T> _handleError;
       |
       |  /// The handler for done events.
       |  final HandleDone<T> _handleDone;
       |
       |  HandlerTransformer(
      0|      this._handleData, this._handleError, this._handleDone);
       |
      0|  StreamSink<S> bind(StreamSink<T> sink) => new _HandlerSink<S, T>(this, sink);
       |}
       |
       |/// A sink created by [HandlerTransformer].
       |class _HandlerSink<S, T> implements StreamSink<S> {
       |  /// The transformer that created this sink.
       |  final HandlerTransformer<S, T> _transformer;
       |
       |  /// The original sink that's being transformed.
       |  final StreamSink<T> _inner;
       |
       |  /// The wrapper for [_inner] whose [StreamSink.close] method can't emit
       |  /// errors.
       |  final StreamSink<T> _safeCloseInner;
       |
      0|  Future get done => _inner.done;
       |
       |  _HandlerSink(this._transformer, StreamSink<T> inner)
       |      : _inner = inner,
      0|        _safeCloseInner = new _SafeCloseSink<T>(inner);
       |
       |  void add(S event) {
      0|    if (_transformer._handleData == null) {
      0|      _inner.add(event as T);
       |    } else {
      0|      _transformer._handleData(event, _safeCloseInner);
       |    }
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_transformer._handleError == null) {
      0|      _inner.addError(error, stackTrace);
       |    } else {
      0|      _transformer._handleError(error, stackTrace, _safeCloseInner);
       |    }
       |  }
       |
       |  Future addStream(Stream<S> stream) {
      0|    return _inner.addStream(stream.transform(
      0|        new StreamTransformer<S, T>.fromHandlers(
      0|            handleData: _transformer._handleData,
      0|            handleError: _transformer._handleError,
       |            handleDone: _closeSink)));
       |  }
       |
       |  Future close() {
      0|    if (_transformer._handleDone == null) return _inner.close();
       |
      0|    _transformer._handleDone(_safeCloseInner);
      0|    return _inner.done;
       |  }
       |}
       |
       |/// A wrapper for [StreamSink]s that swallows any errors returned by [close].
       |///
       |/// [HandlerTransformer] passes this to its handlers to ensure that when they
       |/// call [close], they don't leave any dangling [Future]s behind that might emit
       |/// unhandleable errors.
       |class _SafeCloseSink<T> extends DelegatingStreamSink<T> {
      0|  _SafeCloseSink(StreamSink<T> inner) : super(inner);
       |
      0|  Future close() => super.close().catchError((_) {});
       |}
       |
       |/// A function to pass as a [StreamTransformer]'s `handleDone` callback.
       |void _closeSink(EventSink sink) {
      0|  sink.close();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_sink_transformer/stream_transformer_wrapper.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_sink_transformer.dart';
       |
       |/// A [StreamSinkTransformer] that wraps a pre-existing [StreamTransformer].
       |class StreamTransformerWrapper<S, T> implements StreamSinkTransformer<S, T> {
       |  /// The wrapped transformer.
       |  final StreamTransformer<S, T> _transformer;
       |
      0|  const StreamTransformerWrapper(this._transformer);
       |
       |  StreamSink<S> bind(StreamSink<T> sink) =>
      0|      new _StreamTransformerWrapperSink<S, T>(_transformer, sink);
       |}
       |
       |/// A sink created by [StreamTransformerWrapper].
       |class _StreamTransformerWrapperSink<S, T> implements StreamSink<S> {
       |  /// The controller through which events are passed.
       |  ///
       |  /// This is used to create a stream that can be transformed by the wrapped
       |  /// transformer.
       |  final _controller = new StreamController<S>(sync: true);
       |
       |  /// The original sink that's being transformed.
       |  final StreamSink<T> _inner;
       |
      0|  Future get done => _inner.done;
       |
       |  _StreamTransformerWrapperSink(StreamTransformer<S, T> transformer,
      0|      this._inner) {
      0|    _controller.stream.transform(transformer).listen(
      0|        _inner.add,
      0|        onError: _inner.addError,
       |        onDone: () {
       |          // Ignore any errors that come from this call to [_inner.close]. The
       |          // user can access them through [done] or the value returned from
       |          // [this.close], and we don't want them to get top-leveled.
      0|          _inner.close().catchError((_) {});
       |        });
       |  }
       |
       |  void add(S event) {
      0|    _controller.add(event);
       |  }
       |
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _controller.addError(error, stackTrace);
       |  }
       |
      0|  Future addStream(Stream<S> stream) => _controller.addStream(stream);
       |
       |  Future close() {
      0|    _controller.close();
      0|    return _inner.done;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/async-1.13.2/lib/src/stream_sink_transformer/typed.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../delegate/stream_sink.dart';
       |import '../stream_sink_transformer.dart';
       |
       |/// A wrapper that coerces the generic type of the sink returned by an inner
       |/// transformer to `S`.
       |class TypeSafeStreamSinkTransformer<S, T>
       |    implements StreamSinkTransformer<S, T> {
       |  final StreamSinkTransformer _inner;
       |
      0|  TypeSafeStreamSinkTransformer(this._inner);
       |
       |  StreamSink<S> bind(StreamSink<T> sink) =>
      0|      DelegatingStreamSink.typed(_inner.bind(sink));
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A pair of values.
       |class Pair<E, F> {
       |  E first;
       |  F last;
       |
      0|  Pair(this.first, this.last);
       |}
       |
       |/// Returns a [Comparator] that asserts that its first argument is comparable.
       |Comparator/*<T>*/ defaultCompare/*<T>*/() =>
      0|    (value1, value2) => (value1 as Comparable).compareTo(value2);
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/empty_unmodifiable_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'unmodifiable_wrappers.dart';
       |
       |// Unfortunately, we can't use UnmodifiableSetMixin here, since const classes
       |// can't use mixins.
       |/// An unmodifiable, empty set that can have a const constructor.
       |class EmptyUnmodifiableSet<E> extends IterableBase<E>
       |    implements UnmodifiableSetView<E> {
       |  static /*=T*/ _throw/*<T>*/() {
      0|    throw new UnsupportedError("Cannot modify an unmodifiable Set");
       |  }
       |
      0|  Iterator<E> get iterator => new Iterable<E>.empty().iterator;
       |  int get length => 0;
       |
      0|  const EmptyUnmodifiableSet();
       |
       |  bool contains(Object element) => false;
      0|  bool containsAll(Iterable<Object> other) => other.isEmpty;
       |  E lookup(Object element) => null;
      0|  Set<E> toSet() => new Set();
      0|  Set<E> union(Set<E> other) => new Set.from(other);
      0|  Set<E> intersection(Set<Object> other) => new Set();
      0|  Set<E> difference(Set<Object> other) => new Set();
       |
      0|  bool add(E value) => _throw();
      0|  void addAll(Iterable<E> elements) => _throw();
      0|  void clear() => _throw();
      0|  bool remove(Object element) => _throw();
      0|  void removeAll(Iterable<Object> elements) => _throw();
      0|  void removeWhere(bool test(E element)) => _throw();
      0|  void retainWhere(bool test(E element)) => _throw();
      0|  void retainAll(Iterable<Object> elements) => _throw();
       |}
       |
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/collection-1.14.0/lib/src/typed_wrappers.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:collection";
       |import "dart:math" as math;
       |
       |import "wrappers.dart";
       |
       |typedef F _UnaryFunction<E, F>(E argument);
       |
       |/// The base class for delegating, type-asserting iterables.
       |///
       |/// Subclasses can provide a [_base] that should be delegated to. Unlike
       |/// [TypeSafeIterable], this allows the base to be created on demand.
       |abstract class _TypeSafeIterableBase<E> implements Iterable<E> {
       |  /// The base iterable to which operations are delegated.
       |  Iterable get _base;
       |
      0|  _TypeSafeIterableBase();
       |
      0|  bool any(bool test(E element)) => _base.any(_validate(test));
       |
      0|  bool contains(Object element) => _base.contains(element);
       |
      0|  E elementAt(int index) => _base.elementAt(index) as E;
       |
      0|  bool every(bool test(E element)) => _base.every(_validate(test));
       |
       |  Iterable/*<T>*/ expand/*<T>*/(Iterable/*<T>*/ f(E element)) =>
      0|      _base.expand(_validate(f));
       |
      0|  E get first => _base.first as E;
       |
       |  E firstWhere(bool test(E element), {E orElse()}) =>
      0|      _base.firstWhere(_validate(test), orElse: orElse) as E;
       |
       |  /*=T*/ fold/*<T>*/(
       |          /*=T*/ initialValue,
       |          /*=T*/ combine(/*=T*/ previousValue, E element)) =>
      0|      _base.fold(initialValue,
      0|          (previousValue, element) => combine(previousValue, element as E));
       |
      0|  void forEach(void f(E element)) => _base.forEach(_validate(f));
       |
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      0|  Iterator<E> get iterator => _base.map((element) => element as E).iterator;
       |
      0|  String join([String separator = ""]) => _base.join(separator);
       |
      0|  E get last => _base.last as E;
       |
       |  E lastWhere(bool test(E element), {E orElse()}) =>
      0|      _base.lastWhere(_validate(test), orElse: orElse) as E;
       |
      0|  int get length => _base.length;
       |
      0|  Iterable/*<T>*/ map/*<T>*/(/*=T*/ f(E element)) => _base.map(_validate(f));
       |
       |  E reduce(E combine(E value, E element)) =>
      0|      _base.reduce((value, element) => combine(value as E, element as E)) as E;
       |
      0|  E get single => _base.single as E;
       |
       |  E singleWhere(bool test(E element)) =>
      0|    _base.singleWhere(_validate(test)) as E;
       |
      0|  Iterable<E> skip(int n) => new TypeSafeIterable<E>(_base.skip(n));
       |
       |  Iterable<E> skipWhile(bool test(E value)) =>
      0|      new TypeSafeIterable<E>(_base.skipWhile(_validate(test)));
       |
      0|  Iterable<E> take(int n) => new TypeSafeIterable<E>(_base.take(n));
       |
       |  Iterable<E> takeWhile(bool test(E value)) =>
      0|      new TypeSafeIterable<E>(_base.takeWhile(_validate(test)));
       |
       |  List<E> toList({bool growable: true}) =>
      0|      new TypeSafeList<E>(_base.toList(growable: growable));
       |
      0|  Set<E> toSet() => new TypeSafeSet<E>(_base.toSet());
       |
       |  Iterable<E> where(bool test(E element)) =>
      0|      new TypeSafeIterable<E>(_base.where(_validate(test)));
       |
      0|  String toString() => _base.toString();
       |
       |  /// Returns a version of [function] that asserts that its argument is an
       |  /// instance of `E`.
       |  _UnaryFunction/*<dynamic, F>*/ _validate/*<F>*/(/*=F*/ function(E value)) =>
      0|      (value) => function(value as E);
       |}
       |
       |/// An [Iterable] that asserts the types of values in a base iterable.
       |///
       |/// This is instantiated using [DelegatingIterable.typed].
       |class TypeSafeIterable<E> extends _TypeSafeIterableBase<E>
       |    implements DelegatingIterable<E> {
       |  final Iterable _base;
       |
      0|  TypeSafeIterable(Iterable base) : _base = base;
       |}
       |
       |/// A [List] that asserts the types of values in a base list.
       |///
       |/// This is instantiated using [DelegatingList.typed].
       |class TypeSafeList<E> extends TypeSafeIterable<E> implements DelegatingList<E> {
      0|  TypeSafeList(List base) : super(base);
       |
       |  /// A [List]-typed getter for [_base].
      0|  List get _listBase => _base;
       |
      0|  E operator [](int index) => _listBase[index] as E;
       |
       |  void operator []=(int index, E value) {
      0|    _listBase[index] = value;
       |  }
       |
       |  void add(E value) {
      0|    _listBase.add(value);
       |  }
       |
       |  void addAll(Iterable<E> iterable) {
      0|    _listBase.addAll(iterable);
       |  }
       |
      0|  Map<int, E> asMap() => new TypeSafeMap<int, E>(_listBase.asMap());
       |
       |  void clear() {
      0|    _listBase.clear();
       |  }
       |
       |  void fillRange(int start, int end, [E fillValue]) {
      0|    _listBase.fillRange(start, end, fillValue);
       |  }
       |
       |  Iterable<E> getRange(int start, int end) =>
      0|      new TypeSafeIterable<E>(_listBase.getRange(start, end));
       |
      0|  int indexOf(E element, [int start = 0]) => _listBase.indexOf(element, start);
       |
       |  void insert(int index, E element) {
      0|    _listBase.insert(index, element);
       |  }
       |
       |  void insertAll(int index, Iterable<E> iterable) {
      0|    _listBase.insertAll(index, iterable);
       |  }
       |
       |  int lastIndexOf(E element, [int start]) =>
      0|      _listBase.lastIndexOf(element, start);
       |
       |  void set length(int newLength) {
      0|    _listBase.length = newLength;
       |  }
       |
      0|  bool remove(Object value) => _listBase.remove(value);
       |
      0|  E removeAt(int index) => _listBase.removeAt(index) as E;
       |
      0|  E removeLast() => _listBase.removeLast() as E;
       |
       |  void removeRange(int start, int end) {
      0|    _listBase.removeRange(start, end);
       |  }
       |
       |  void removeWhere(bool test(E element)) {
      0|    _listBase.removeWhere(_validate(test));
       |  }
       |
       |  void replaceRange(int start, int end, Iterable<E> iterable) {
      0|    _listBase.replaceRange(start, end, iterable);
       |  }
       |
       |  void retainWhere(bool test(E element)) {
      0|    _listBase.retainWhere(_validate(test));
       |  }
       |
      0|  Iterable<E> get reversed => new TypeSafeIterable<E>(_listBase.reversed);
       |
       |  void setAll(int index, Iterable<E> iterable) {
      0|    _listBase.setAll(index, iterable);
       |  }
       |
       |  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {
      0|    _listBase.setRange(start, end, iterable, skipCount);
       |  }
       |
       |  void shuffle([math.Random random]) {
      0|    _listBase.shuffle(random);
       |  }
       |
       |  void sort([int compare(E a, E b)]) {
       |    if (compare == null) {
      0|      _listBase.sort();
       |    } else {
      0|      _listBase.sort((a, b) => compare(a as E, b as E));
       |    }
       |  }
       |
       |  List<E> sublist(int start, [int end]) =>
      0|      new TypeSafeList<E>(_listBase.sublist(start, end));
       |}
       |
       |/// A [Set] that asserts the types of values in a base set.
       |///
       |/// This is instantiated using [DelegatingSet.typed].
       |class TypeSafeSet<E> extends TypeSafeIterable<E> implements DelegatingSet<E> {
      0|  TypeSafeSet(Set base) : super(base);
       |
       |  /// A [Set]-typed getter for [_base].
      0|  Set get _setBase => _base;
       |
      0|  bool add(E value) => _setBase.add(value);
       |
       |  void addAll(Iterable<E> elements) {
      0|    _setBase.addAll(elements);
       |  }
       |
       |  void clear() {
      0|    _setBase.clear();
       |  }
       |
      0|  bool containsAll(Iterable<Object> other) => _setBase.containsAll(other);
       |
       |  Set<E> difference(Set<Object> other) =>
      0|      new TypeSafeSet<E>(_setBase.difference(other));
       |
       |  Set<E> intersection(Set<Object> other) =>
      0|      new TypeSafeSet<E>(_setBase.intersection(other));
       |
      0|  E lookup(Object element) => _setBase.lookup(element) as E;
       |
      0|  bool remove(Object value) => _setBase.remove(value);
       |
       |  void removeAll(Iterable<Object> elements) {
      0|    _setBase.removeAll(elements);
       |  }
       |
       |  void removeWhere(bool test(E element)) {
      0|    _setBase.removeWhere(_validate(test));
       |  }
       |
       |  void retainAll(Iterable<Object> elements) {
      0|    _setBase.retainAll(elements);
       |  }
       |
       |  void retainWhere(bool test(E element)) {
      0|    _setBase.retainWhere(_validate(test));
       |  }
       |
      0|  Set<E> union(Set<E> other) => new TypeSafeSet<E>(_setBase.union(other));
       |}
       |
       |/// A [Queue] that asserts the types of values in a base queue.
       |///
       |/// This is instantiated using [DelegatingQueue.typed].
       |class TypeSafeQueue<E> extends TypeSafeIterable<E>
       |    implements DelegatingQueue<E> {
      0|  TypeSafeQueue(Queue queue) : super(queue);
       |
       |  /// A [Queue]-typed getter for [_base].
      0|  Queue get _baseQueue => _base;
       |
       |  void add(E value) {
      0|    _baseQueue.add(value);
       |  }
       |
       |  void addAll(Iterable<E> iterable) {
      0|    _baseQueue.addAll(iterable);
       |  }
       |
       |  void addFirst(E value) {
      0|    _baseQueue.addFirst(value);
       |  }
       |
       |  void addLast(E value) {
      0|    _baseQueue.addLast(value);
       |  }
       |
       |  void clear() {
      0|    _baseQueue.clear();
       |  }
       |
      0|  bool remove(Object object) => _baseQueue.remove(object);
       |
       |  void removeWhere(bool test(E element)) {
      0|    _baseQueue.removeWhere(_validate(test));
       |  }
       |
       |  void retainWhere(bool test(E element)) {
      0|    _baseQueue.retainWhere(_validate(test));
       |  }
       |
      0|  E removeFirst() => _baseQueue.removeFirst() as E;
       |
      0|  E removeLast() => _baseQueue.removeLast() as E;
       |}
       |
       |/// A [Map] that asserts the types of keys and values in a base map.
       |///
       |/// This is instantiated using [DelegatingMap.typed].
       |class TypeSafeMap<K, V> implements DelegatingMap<K, V> {
       |  /// The base map to which operations are delegated.
       |  final Map _base;
       |
      0|  TypeSafeMap(Map base) : _base = base;
       |
      0|  V operator [](Object key) => _base[key] as V;
       |
       |  void operator []=(K key, V value) {
      0|    _base[key] = value;
       |  }
       |
       |  void addAll(Map<K, V> other) {
      0|    _base.addAll(other);
       |  }
       |
       |  void clear() {
      0|    _base.clear();
       |  }
       |
      0|  bool containsKey(Object key) => _base.containsKey(key);
       |
      0|  bool containsValue(Object value) => _base.containsValue(value);
       |
       |  void forEach(void f(K key, V value)) {
      0|    _base.forEach((key, value) => f(key as K, value as V));
       |  }
       |
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      0|  Iterable<K> get keys => new TypeSafeIterable<K>(_base.keys);
       |
      0|  int get length => _base.length;
       |
      0|  V putIfAbsent(K key, V ifAbsent()) => _base.putIfAbsent(key, ifAbsent) as V;
       |
      0|  V remove(Object key) => _base.remove(key) as V;
       |
      0|  Iterable<V> get values => new TypeSafeIterable<V>(_base.values);
       |
      0|  String toString() => _base.toString();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/stream_channel-1.6.1/lib/src/transformer/typed.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../../stream_channel.dart';
       |
       |/// A wrapper that coerces the generic type of the channel returned by an inner
       |/// transformer to `S`.
       |class TypeSafeStreamChannelTransformer<S, T>
       |    implements StreamChannelTransformer<S, T> {
       | final StreamChannelTransformer _inner;
       |
      0|  TypeSafeStreamChannelTransformer(this._inner);
       |
       |  StreamChannel<S> bind(StreamChannel<T> channel) =>
      0|      _inner.bind(channel).cast();
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/ast.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'visitor.dart';
       |
       |/// The superclass of nodes in the boolean selector abstract syntax tree.
       |abstract class Node {
       |  /// The span indicating where this node came from.
       |  ///
       |  /// This is a [FileSpan] because the nodes are parsed from a single continuous
       |  /// string, but the string itself isn't actually a file. It might come from a
       |  /// statically-parsed annotation or from a parameter.
       |  ///
       |  /// This may be `null` for nodes without source information.
       |  FileSpan get span;
       |
       |  /// All the variables in this node, in the order they appear.
       |  Iterable<String> get variables;
       |
       |  /// Calls the appropriate [Visitor] method on [this] and returns the result.
       |  accept(Visitor visitor);
       |}
       |
       |/// A single variable.
       |class VariableNode implements Node {
       |  final FileSpan span;
       |
       |  /// The variable name.
       |  final String name;
       |
      0|  Iterable<String> get variables => [name];
       |
      0|  VariableNode(this.name, [this.span]);
       |
      0|  accept(Visitor visitor) => visitor.visitVariable(this);
       |
      0|  String toString() => name;
       |
      0|  bool operator==(other) => other is VariableNode && name == other.name;
       |
      0|  int get hashCode => name.hashCode;
       |}
       |
       |/// A negation expression.
       |class NotNode implements Node {
       |  final FileSpan span;
       |
       |  /// The expression being negated.
       |  final Node child;
       |
      0|  Iterable<String> get variables => child.variables;
       |
      0|  NotNode(this.child, [this.span]);
       |
      0|  accept(Visitor visitor) => visitor.visitNot(this);
       |
      0|  String toString() => child is VariableNode || child is NotNode
      0|      ? "!$child"
      0|      : "!($child)";
       |
      0|  bool operator==(other) => other is NotNode && child == other.child;
       |
      0|  int get hashCode => ~child.hashCode;
       |}
       |
       |/// An or expression.
       |class OrNode implements Node {
      0|  FileSpan get span => _expandSafe(left.span, right.span);
       |
       |  /// The left-hand branch of the expression.
       |  final Node left;
       |
       |  /// The right-hand branch of the expression.
       |  final Node right;
       |
       |  Iterable<String> get variables sync* {
      0|    yield* left.variables;
      0|    yield* right.variables;
       |  }
       |
      0|  OrNode(this.left, this.right);
       |
      0|  accept(Visitor visitor) => visitor.visitOr(this);
       |
       |  String toString() {
      0|    var string1 = left is AndNode || left is ConditionalNode
      0|        ? "($left)"
      0|        : left;
      0|    var string2 = right is AndNode || right is ConditionalNode
      0|        ? "($right)"
      0|        : right;
       |
      0|    return "$string1 || $string2";
       |  }
       |
       |  bool operator==(other) =>
      0|      other is OrNode && left == other.left && right == other.right;
       |
      0|  int get hashCode => left.hashCode ^ right.hashCode;
       |}
       |
       |/// An and expression.
       |class AndNode implements Node {
      0|  FileSpan get span => _expandSafe(left.span, right.span);
       |
       |  /// The left-hand branch of the expression.
       |  final Node left;
       |
       |  /// The right-hand branch of the expression.
       |  final Node right;
       |
       |  Iterable<String> get variables sync* {
      0|    yield* left.variables;
      0|    yield* right.variables;
       |  }
       |
      0|  AndNode(this.left, this.right);
       |
      0|  accept(Visitor visitor) => visitor.visitAnd(this);
       |
       |  String toString() {
      0|    var string1 = left is OrNode || left is ConditionalNode
      0|        ? "($left)"
      0|        : left;
      0|    var string2 = right is OrNode || right is ConditionalNode
      0|        ? "($right)"
      0|        : right;
       |
      0|    return "$string1 && $string2";
       |  }
       |
       |  bool operator==(other) =>
      0|      other is AndNode && left == other.left && right == other.right;
       |
      0|  int get hashCode => left.hashCode ^ right.hashCode;
       |}
       |
       |/// A ternary conditional expression.
       |class ConditionalNode implements Node {
      0|  FileSpan get span => _expandSafe(condition.span, whenFalse.span);
       |
       |  /// The condition expression to check.
       |  final Node condition;
       |
       |  /// The branch to run if the condition is true.
       |  final Node whenTrue;
       |
       |  /// The branch to run if the condition is false.
       |  final Node whenFalse;
       |
       |  Iterable<String> get variables sync* {
      0|    yield* condition.variables;
      0|    yield* whenTrue.variables;
      0|    yield* whenFalse.variables;
       |  }
       |
      0|  ConditionalNode(this.condition, this.whenTrue, this.whenFalse);
       |
      0|  accept(Visitor visitor) => visitor.visitConditional(this);
       |
       |  String toString() {
       |    var conditionString =
      0|        condition is ConditionalNode ? "($condition)" : condition;
      0|    var trueString = whenTrue is ConditionalNode ? "($whenTrue)" : whenTrue;
      0|    return "$conditionString ? $trueString : $whenFalse";
       |  }
       |
       |  bool operator==(other) =>
      0|      other is ConditionalNode &&
      0|      condition == other.condition &&
      0|      whenTrue == other.whenTrue &&
      0|      whenFalse == other.whenFalse;
       |
       |  int get hashCode =>
      0|      condition.hashCode ^ whenTrue.hashCode ^ whenFalse.hashCode;
       |}
       |
       |/// Like [FileSpan.expand], except if [start] and [end] are `null` or from
       |/// different files it returns `null` rather than throwing an error.
       |FileSpan _expandSafe(FileSpan start, FileSpan end) {
       |  if (start == null || end == null) return null;
      0|  if (start.file != end.file) return null;
      0|  return start.expand(end);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/evaluator.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:collection/collection.dart';
       |
       |import 'ast.dart';
       |import 'visitor.dart';
       |
       |typedef bool _Semantics(String variable);
       |
       |/// A visitor for evaluating boolean selectors against a specific set of
       |/// semantics.
       |class Evaluator implements Visitor<bool> {
       |  /// The semantics to evaluate against.
       |  final _Semantics _semantics;
       |
       |  Evaluator(semantics)
      0|      : _semantics = semantics is Iterable
      0|            ? DelegatingIterable.typed(semantics.toSet()).contains
      0|            : semantics as _Semantics;
       |
      0|  bool visitVariable(VariableNode node) => _semantics(node.name);
       |
      0|  bool visitNot(NotNode node) => !node.child.accept(this);
       |
       |  bool visitOr(OrNode node) =>
      0|      node.left.accept(this) || node.right.accept(this);
       |
       |  bool visitAnd(AndNode node) =>
      0|      node.left.accept(this) && node.right.accept(this);
       |
      0|  bool visitConditional(ConditionalNode node) => node.condition.accept(this)
      0|      ? node.whenTrue.accept(this)
      0|      : node.whenFalse.accept(this);
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/intersection_selector.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |import 'union_selector.dart';
       |
       |/// A selector that matches inputs that both of its sub-selectors match.
       |class IntersectionSelector implements BooleanSelector {
       |  final BooleanSelector _selector1;
       |  final BooleanSelector _selector2;
       |
       |  Iterable<String> get variables sync* {
      0|    yield* _selector1.variables;
      0|    yield* _selector2.variables;
       |  }
       |
      0|  IntersectionSelector(this._selector1, this._selector2);
       |
       |  bool evaluate(semantics) =>
      0|      _selector1.evaluate(semantics) && _selector2.evaluate(semantics);
       |
       |  BooleanSelector intersection(BooleanSelector other) =>
      0|      new IntersectionSelector(this, other);
       |
       |  BooleanSelector union(BooleanSelector other) =>
      0|      new UnionSelector(this, other);
       |
       |  void validate(bool isDefined(String variable)) {
      0|    _selector1.validate(isDefined);
      0|    _selector2.validate(isDefined);
       |  }
       |
      0|  String toString() => "($_selector1) && ($_selector2)";
       |
       |  bool operator==(other) =>
      0|      other is IntersectionSelector &&
      0|      _selector1 == other._selector1 &&
      0|      _selector2 == other._selector2;
       |
      0|  int get hashCode => _selector1.hashCode ^ _selector2.hashCode;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/parser.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'ast.dart';
       |import 'scanner.dart';
       |import 'token.dart';
       |
       |/// A class for parsing a boolean selector.
       |///
       |/// Boolean selectors use a stripped-down version of the Dart expression syntax
       |/// that only contains variables, parentheses, and boolean operators. Variables
       |/// may also contain dashes, contrary to Dart's syntax; this allows consistency
       |/// with command-line arguments.
       |class Parser {
       |  /// The scanner that tokenizes the selector.
       |  final Scanner _scanner;
       |
       |  Parser(String selector)
      0|      : _scanner = new Scanner(selector);
       |
       |  /// Parses the selector.
       |  ///
       |  /// This must only be called once per parser.
       |  Node parse() {
      0|    var selector = _conditional();
       |
      0|    if (_scanner.peek().type != TokenType.endOfFile) {
      0|      throw new SourceSpanFormatException(
      0|          "Expected end of input.", _scanner.peek().span);
       |    }
       |
       |    return selector;
       |  }
       |
       |  /// Parses a conditional:
       |  ///
       |  ///     conditionalExpression:
       |  ///       logicalOrExpression ("?" conditionalExpression ":"
       |  ///           conditionalExpression)?
       |  Node _conditional() {
      0|    var condition = _or();
      0|    if (!_scanner.scan(TokenType.questionMark)) return condition;
       |
      0|    var whenTrue = _conditional();
      0|    if (!_scanner.scan(TokenType.colon)) {
      0|      throw new SourceSpanFormatException(
      0|          'Expected ":".', _scanner.peek().span);
       |    }
       |
      0|    var whenFalse = _conditional();
      0|    return new ConditionalNode(condition, whenTrue, whenFalse);
       |  }
       |
       |  /// Parses a logical or:
       |  ///
       |  ///     logicalOrExpression:
       |  ///       logicalAndExpression ("||" logicalOrExpression)?
       |  Node _or() {
      0|    var left = _and();
      0|    if (!_scanner.scan(TokenType.or)) return left;
      0|    return new OrNode(left, _or());
       |  }
       |
       |  /// Parses a logical and:
       |  ///
       |  ///     logicalAndExpression:
       |  ///       simpleExpression ("&&" logicalAndExpression)?
       |  Node _and() {
      0|    var left = _simpleExpression();
      0|    if (!_scanner.scan(TokenType.and)) return left;
      0|    return new AndNode(left, _and());
       |  }
       |
       |  /// Parses a simple expression:
       |  ///
       |  ///     simpleExpression:
       |  ///       "!" simpleExpression |
       |  ///           "(" conditionalExpression ")" |
       |  ///           IDENTIFIER
       |  Node _simpleExpression() {
      0|    var token = _scanner.next();
      0|    switch (token.type) {
      0|      case TokenType.not:
      0|        var child = _simpleExpression();
      0|        return new NotNode(child, token.span.expand(child.span));
       |
      0|      case TokenType.leftParen:
      0|        var child = _conditional();
      0|        if (!_scanner.scan(TokenType.rightParen)) {
      0|          throw new SourceSpanFormatException(
      0|              'Expected ")".', _scanner.peek().span);
       |        }
       |        return child;
       |
      0|      case TokenType.identifier:
      0|        return new VariableNode((token as IdentifierToken).name, token.span);
       |
       |      default:
      0|        throw new SourceSpanFormatException("Expected expression.", token.span);
       |    }
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/union_selector.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |import 'intersection_selector.dart';
       |
       |/// A selector that matches inputs that either of its sub-selectors match.
       |class UnionSelector implements BooleanSelector {
       |  final BooleanSelector _selector1;
       |  final BooleanSelector _selector2;
       |
      0|  UnionSelector(this._selector1, this._selector2);
       |
       |  List<String> get variables =>
      0|      _selector1.variables.toList()..addAll(_selector2.variables);
       |
       |  bool evaluate(semantics) =>
      0|      _selector1.evaluate(semantics) || _selector2.evaluate(semantics);
       |
       |  BooleanSelector intersection(BooleanSelector other) =>
      0|      new IntersectionSelector(this, other);
       |
       |  BooleanSelector union(BooleanSelector other) =>
      0|      new UnionSelector(this, other);
       |
       |  void validate(bool isDefined(String variable)) {
      0|    _selector1.validate(isDefined);
      0|    _selector2.validate(isDefined);
       |  }
       |
      0|  String toString() => "($_selector1) && ($_selector2)";
       |
       |  bool operator==(other) =>
      0|      other is UnionSelector &&
      0|      _selector1 == other._selector1 &&
      0|      _selector2 == other._selector2;
       |
      0|  int get hashCode => _selector1.hashCode ^ _selector2.hashCode;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/validator.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'ast.dart';
       |import 'visitor.dart';
       |
       |typedef bool _IsDefined(String variable);
       |
       |/// An AST visitor that ensures that all variables are valid.
       |class Validator extends RecursiveVisitor {
       |  final _IsDefined _isDefined;
       |
      0|  Validator(this._isDefined);
       |
       |  void visitVariable(VariableNode node) {
      0|    if (_isDefined(node.name)) return;
      0|    throw new SourceSpanFormatException("Undefined variable.", node.span);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/source_span-1.3.1/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Returns the minimum of [obj1] and [obj2] according to
       |/// [Comparable.compareTo].
       |Comparable min(Comparable obj1, Comparable obj2) =>
      0|    obj1.compareTo(obj2) > 0 ? obj2 : obj1;
       |
       |/// Returns the maximum of [obj1] and [obj2] according to
       |/// [Comparable.compareTo].
       |Comparable max(Comparable obj1, Comparable obj2) =>
      0|    obj1.compareTo(obj2) > 0 ? obj1 : obj2;
       |
       |/// Finds a line in [context] containing [text] at the specified [column].
       |///
       |/// Returns the index in [context] where that line begins, or null if none
       |/// exists.
       |int findLineStart(String context, String text, int column) {
      0|  var isEmpty = text == '';
      0|  var index = context.indexOf(text);
      0|  while (index != -1) {
      0|    var lineStart = context.lastIndexOf('\n', index) + 1;
      0|    var textColumn = index - lineStart;
      0|    if (column == textColumn || (isEmpty && column == textColumn + 1)) {
       |      return lineStart;
       |    }
      0|    index = context.indexOf(text, index + 1);
       |  }
       |  return null;
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/visitor.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'ast.dart';
       |
       |/// The interface for visitors of the boolean selector AST.
       |abstract class Visitor<T> {
       |  T visitVariable(VariableNode node);
       |  T visitNot(NotNode node);
       |  T visitOr(OrNode node);
       |  T visitAnd(AndNode node);
       |  T visitConditional(ConditionalNode node);
       |}
       |
       |/// An abstract superclass for side-effect-based visitors.
       |///
       |/// The default implementations of this visitor's methods just traverse the AST
       |/// and do nothing with it.
       |abstract class RecursiveVisitor implements Visitor {
      0|  const RecursiveVisitor();
       |
       |  void visitVariable(VariableNode node) {}
       |
       |  void visitNot(NotNode node) {
      0|    node.child.accept(this);
       |  }
       |
       |  void visitOr(OrNode node) {
      0|    node.left.accept(this);
      0|    node.right.accept(this);
       |  }
       |
       |  void visitAnd(AndNode node) {
      0|    node.left.accept(this);
      0|    node.right.accept(this);
       |  }
       |
       |  void visitConditional(ConditionalNode node) {
      0|    node.condition.accept(this);
      0|    node.whenTrue.accept(this);
      0|    node.whenFalse.accept(this);
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/scanner.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:string_scanner/string_scanner.dart';
       |
       |import 'token.dart';
       |
       |/// A regular expression matching both whitespace and single-line comments.
       |///
       |/// This will only match if consumes at least one character.
       |final _whitespaceAndSingleLineComments =
       |    new RegExp(r"([ \t\n]+|//[^\n]*(\n|$))+");
       |
       |/// A regular expression matching the body of a multi-line comment, after `/*`
       |/// but before `*/` or a nested `/*`.
       |///
       |/// This will only match if it consumes at least one character.
       |final _multiLineCommentBody = new RegExp(r"([^/*]|/[^*]|\*[^/])+");
       |
       |/// A regular expression matching a hyphenated identifier.
       |///
       |/// This is like a standard Dart identifier, except that it can also contain
       |/// hyphens.
       |final _hyphenatedIdentifier = new RegExp(r"[a-zA-Z_-][a-zA-Z0-9_-]*");
       |
       |/// A scanner that converts a boolean selector string into a stream of tokens.
       |class Scanner {
       |  /// The underlying string scanner.
       |  final SpanScanner _scanner;
       |
       |  /// The next token to emit.
       |  Token _next;
       |
       |  /// Whether the scanner has emitted a [TokenType.endOfFile] token.
       |  bool _endOfFileEmitted = false;
       |
       |  Scanner(String selector)
      0|      : _scanner = new SpanScanner(selector);
       |
       |  /// Returns the next token that will be returned by [next].
       |  ///
       |  /// Throws a [StateError] if a [TokenType.endOfFile] token has already been
       |  /// consumed.
       |  Token peek() {
      0|    if (_next == null) _next = _getNext();
      0|    return _next;
       |  }
       |
       |  /// Consumes and returns the next token in the stream.
       |  ///
       |  /// Throws a [StateError] if a [TokenType.endOfFile] token has already been
       |  /// consumed.
       |  Token next() {
      0|    var token = _next == null ? _getNext() : _next;
      0|    _endOfFileEmitted = token.type == TokenType.endOfFile;
      0|    _next = null;
       |    return token;
       |  }
       |
       |  /// If the next token matches [type], consumes it and returns `true`;
       |  /// otherwise, returns `false`.
       |  ///
       |  /// Throws a [StateError] if a [TokenType.endOfFile] token has already been
       |  /// consumed.
       |  bool scan(TokenType type) {
      0|    if (peek().type != type) return false;
      0|    next();
       |    return true;
       |  }
       |
       |  /// Scan and return the next token in the stream.
       |  Token _getNext() {
      0|    if (_endOfFileEmitted) throw new StateError("No more tokens.");
       |
      0|    _consumeWhitespace();
      0|    if (_scanner.isDone) {
      0|      return new Token(
      0|          TokenType.endOfFile, _scanner.spanFrom(_scanner.state));
       |    }
       |
      0|    switch (_scanner.peekChar()) {
      0|      case 0x28 /* ( */: return _scanOperator(TokenType.leftParen);
      0|      case 0x29 /* ) */: return _scanOperator(TokenType.rightParen);
      0|      case 0x3F /* ? */: return _scanOperator(TokenType.questionMark);
      0|      case 0x3A /* : */: return _scanOperator(TokenType.colon);
      0|      case 0x21 /* ! */: return _scanOperator(TokenType.not);
      0|      case 0x7C /* | */: return _scanOr();
      0|      case 0x26 /* & */: return _scanAnd();
      0|      default: return _scanIdentifier();
       |    }
       |  }
       |
       |  /// Scans a single-character operator and returns a token of type [type].
       |  ///
       |  /// This assumes that the caller has already verified that the next character
       |  /// is correct for the given operator.
       |  Token _scanOperator(TokenType type) {
      0|    var start = _scanner.state;
      0|    _scanner.readChar();
      0|    return new Token(type, _scanner.spanFrom(start));
       |  }
       |
       |  /// Scans a `||` operator and returns the appropriate token.
       |  ///
       |  /// This validates that the next two characters are `||`.
       |  Token _scanOr() {
      0|    var start = _scanner.state;
      0|    _scanner.expect("||");
      0|    return new Token(TokenType.or, _scanner.spanFrom(start));
       |  }
       |
       |  /// Scans a `&&` operator and returns the appropriate token.
       |  ///
       |  /// This validates that the next two characters are `&&`.
       |  Token _scanAnd() {
      0|    var start = _scanner.state;
      0|    _scanner.expect("&&");
      0|    return new Token(TokenType.and, _scanner.spanFrom(start));
       |  }
       |
       |  /// Scans and returns an identifier token.
       |  Token _scanIdentifier() {
      0|    _scanner.expect(_hyphenatedIdentifier, name: "expression");
      0|    return new IdentifierToken(_scanner.lastMatch[0], _scanner.lastSpan);
       |  }
       |
       |  /// Consumes all whitespace and comments immediately following the cursor's
       |  /// current position.
       |  void _consumeWhitespace() {
      0|    while (_scanner.scan(_whitespaceAndSingleLineComments) ||
      0|        _multiLineComment()) {
       |      // Do nothing.
       |    }
       |  }
       |
       |  /// Consumes a single multi-line comment.
       |  ///
       |  /// Returns whether or not a comment was consumed.
       |  bool _multiLineComment() {
      0|    if (!_scanner.scan("/*")) return false;
       |
      0|    while (_scanner.scan(_multiLineCommentBody) || _multiLineComment()) {
       |      // Do nothing.
       |    }
      0|    _scanner.expect("*/");
       |
       |    return true;
       |  }
       |}
/Users/tobe/.pub-cache/hosted/pub.dartlang.org/boolean_selector-1.0.2/lib/src/token.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |/// A token in a boolean selector.
       |class Token {
       |  /// The type of the token.
       |  final TokenType type;
       |
       |  /// The span indicating where this token came from.
       |  ///
       |  /// This is a [FileSpan] because the tokens are parsed from a single
       |  /// continuous string, but the string itself isn't actually a file. It might
       |  /// come from a statically-parsed annotation or from a parameter.
       |  final FileSpan span;
       |
      0|  Token(this.type, this.span);
       |}
       |
       |/// A token representing an identifier.
       |class IdentifierToken implements Token {
       |  final type = TokenType.identifier;
       |  final FileSpan span;
       |
       |  /// The name of the identifier.
       |  final String name;
       |
      0|  IdentifierToken(this.name, this.span);
       |
      0|  String toString() => 'identifier "$name"';
       |}
       |
       |/// An enumeration of types of tokens.
       |class TokenType {
       |  /// A `(` character.
       |  static const leftParen = const TokenType._("left paren");
       |
       |  /// A `)` character.
       |  static const rightParen = const TokenType._("right paren");
       |
       |  /// A `||` sequence.
       |  static const or = const TokenType._("or");
       |
       |  /// A `&&` sequence.
       |  static const and = const TokenType._("and");
       |
       |  /// A `!` character.
       |  static const not = const TokenType._("not");
       |
       |  /// A `?` character.
       |  static const questionMark = const TokenType._("question mark");
       |
       |  /// A `:` character.
       |  static const colon = const TokenType._("colon");
       |
       |  /// A named identifier.
       |  static const identifier = const TokenType._("identifier");
       |
       |  /// The end of the selector.
       |  static const endOfFile = const TokenType._("end of file");
       |
       |  /// The name of the token type.
       |  final String name;
       |
      1|  const TokenType._(this.name);
       |
      0|  String toString() => name;
       |}
